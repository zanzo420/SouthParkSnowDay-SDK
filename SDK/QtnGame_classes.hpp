#pragma once

// Dumped with Dumper-7!


namespace SDK
{
//---------------------------------------------------------------------------------------------------------------------
// CLASSES
//---------------------------------------------------------------------------------------------------------------------

// 0x38 (0x60 - 0x28)
// Class QtnGame.QtnAchievementsManager
class UQtnAchievementsManager : public UObject
{
public:
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_10B8[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UDataTable*                            AchievementsDataTable;                             // 0x50(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                            UnlocksDataTable;                                  // 0x58(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAchievementsManager* GetDefaultObj();

};

// 0xB0 (0x300 - 0x250)
// Class QtnGame.QtnActorContentSlot
class AQtnActorContentSlot : public AActor
{
public:
	uint8                                        Pad_10BB[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	uint8                                        bEnabled : 1;                                      // Mask: 0x1, PropSize: 0x10x258(0x1)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        BitPad_A0 : 7;                                     // Fixing Bit-Field Size  [ Dumper-7 ]
	uint8                                        Pad_10BC[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                ContentType;                                       // 0x260(0x10)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class AActor>                  DefaultActor;                                      // 0x270(0x28)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftClassPtr<class AActor>> ContentMap;                                        // 0x298(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	class AActor*                                CurrentActor;                                      // 0x2E8(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x2F0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnActorContentSlot* GetDefaultObj();

	void UseDefaultAppearance();
	void SetContent(class FString& ContentId);
	void ServerSetContent(class FString& ContentId);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnContentSpawned(class AActor* NewActorObject);
	void MulticastSetContent(class FString& ContentId);
	void ClearContent();
};

// 0x58 (0x80 - 0x28)
// Class QtnGame.QtnActorPoolManager
class UQtnActorPoolManager : public UObject
{
public:
	TMap<TSubclassOf<class AQtnPoolableActor>, struct FQtnActorPool> M_WorldActorPools;                                 // 0x28(0x50)(Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_10D2[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnActorPoolManager* GetDefaultObj();

	void WarmUp_ServerOnly(class UObject* WorldContextObject, TSubclassOf<class AQtnPoolableActor> ActorClass, int32 Count);
	void Reclaim_ServerOnly(class AQtnPoolableActor* PActor);
	bool IsActorPoolingEnabled();
	class UQtnActorPoolManager* GetInstance(class UObject* PWorldReference);
	void Cleanup_ServerOnly();
	class AQtnPoolableActor* Acquire_ServerOnly(class UObject* WorldContextObject, TSubclassOf<class AQtnPoolableActor> ActorClass, struct FTransform& Transform, class AActor* Owner, class APawn* Instigator);
};

// 0x150 (0x178 - 0x28)
// Class QtnGame.QtnAIBarkManager
class UQtnAIBarkManager : public UObject
{
public:
	TArray<class UObject*>                       M_idleBarkInhibitors;                              // 0x28(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UClass*, float>                   M_nextClassExclusiveBarkTimes;                     // 0x38(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                     M_nextTagBarkTimes;                                // 0x88(0x50)(Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_10D8[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class FName, float>                     M_barkInhibitionTimers;                            // 0x128(0x50)(Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAIBarkManager* GetDefaultObj();

};

// 0x10 (0x260 - 0x250)
// Class QtnGame.QtnAIJobActorBaseNative
class AQtnAIJobActorBaseNative : public AActor
{
public:
	TArray<int32>                                ValidArcs;                                         // 0x250(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnAIJobActorBaseNative* GetDefaultObj();

	bool IsJobActorViableNative(bool IsComponentEmploymentOpen);
};

// 0x100 (0x128 - 0x28)
// Class QtnGame.QtnAIJobCluster
class UQtnAIJobCluster : public UObject
{
public:
	class UQtnAIJobManager*                      M_pCachedJobManager;                               // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UQtnAIJobRole*>      M_jobRoles;                                        // 0x30(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_isClusterEmploymentOpen;                         // 0x80(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1133[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnAIJobComponent*                    OwningAIJobComponent;                              // 0x88(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  JobClusterID;                                      // 0x90(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                         JobBehavior;                                       // 0x98(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnAIJobFilter                       JobFilter;                                         // 0xA0(0x50)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	enum class EQtnSalaryTier                    SalaryTier;                                        // 0xF0(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1135[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AutoEmploymentRange;                               // 0xF4(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       AutoEmploymentCooldown;                            // 0xF8(0x8)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         IsCombatCluster;                                   // 0x100(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1137[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnAIEmployed;                                      // 0x108(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIUnEmployed;                                    // 0x118(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAIJobCluster* GetDefaultObj();

	void SetClusterEmploymentOpen(bool WantEmploymentOpen);
	void QtnAIClusterEmployEvent__DelegateSignature(class UQtnAIJobRole* AiJobRole, class FName RoleID, class AQtnBodyController* AIController, class UBlackboardComponent* BlackboardComponent);
	bool IsClusterEmploymentOpen();
	bool IsAIJobClusterViable_ServerOnly(class AQtnPawn* Pawn, bool ForInitialAdoption);
	class UQtnAIJobRole* GetJobRole(class FName JobRoleID);
	void GetCurrentlyEmployedJobRoles(TArray<class UQtnAIJobRole*>* EmployedJobRoles);
	void GetAllJobRoles(TArray<class UQtnAIJobRole*>* JobRoles);
	float GetAIJobClusterHeuristic(class AQtnPawn* UnemployedPawn);
	class UQtnAIJobRole* AddJobRole(class FName JobRoleID, struct FQtnAIJobRoleDefinition& JobRoleDef);
};

// 0x188 (0x3B0 - 0x228)
// Class QtnGame.QtnAIJobComponent
class UQtnAIJobComponent : public USceneComponent
{
public:
	class UQtnAIJobManager*                      M_pCachedJobManager_ServerOnly;                    // 0x228(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UQtnAIJobCluster*>   M_combatJobClusters;                               // 0x230(0x50)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UQtnAIJobCluster*>   M_ambientJobClusters;                              // 0x280(0x50)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         M_isComponentEmploymentOpen;                       // 0x2D0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_haveDefaultClustersBeenAdded_ServerOnly;         // 0x2D1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1194[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnBodyPawn*>                  M_employedBodies;                                  // 0x2D8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         StartComponentWithOpenEmployment;                  // 0x2E8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1196[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class FName, struct FQtnAIJobClusterDefinition> CombatJobClusters;                                 // 0x2F0(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FQtnAIJobClusterDefinition> AmbientJobClusters;                                // 0x340(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIEmployed;                                      // 0x390(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIUnEmployed;                                    // 0x3A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAIJobComponent* GetDefaultObj();

	void SetComponentEmploymentOpen(bool WantEmploymentOpen);
	void QtnAIEmployEvent__DelegateSignature(class UQtnAIJobRole* AiJobRole, class FName ClusterID, class FName RoleID, class AQtnBodyController* AIController, class UBlackboardComponent* BlackboardComponent, bool IsCombatJob);
	bool IsComponentEmploymentOpen();
	bool IsAIJobViable_ServerOnly(class AQtnPawn* Pawn, bool ForInitialAdoption);
	class UQtnAIJobCluster* GetJobCluster(class FName JobClusterID, bool ForCombat);
	TArray<class AQtnBodyPawn*> GetEmployedBodies_ServerOnly();
	void GetCurrentlyEmployedJobRoles(TArray<class UQtnAIJobRole*>* EmployedJobRoles, bool ForCombat);
	void GetAllJobRoles(TArray<class UQtnAIJobRole*>* JobRoles, bool ForCombat);
	void GetAllJobClusters(TArray<class UQtnAIJobCluster*>* JobClusters, bool ForCombat);
	class UQtnAIJobCluster* AddJobCluster(class FName JobClusterID, bool ForCombat, struct FQtnAIJobClusterDefinition& JobClusterDefinition);
};

// 0x0 (0x3B0 - 0x3B0)
// Class QtnGame.QtnAIJobComponentBaseNative
class UQtnAIJobComponentBaseNative : public UQtnAIJobComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnAIJobComponentBaseNative* GetDefaultObj();

};

// 0x130 (0x158 - 0x28)
// Class QtnGame.QtnAIJobManager
class UQtnAIJobManager : public UObject
{
public:
	TArray<class UQtnAIJobComponent*>            M_knownAIJobComponents;                            // 0x28(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                        M_aiJobComponentIndex;                             // 0x38(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_119C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnBodyController*>            M_knownBodyControllers;                            // 0x40(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                        M_bodyControllerIndex;                             // 0x50(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_119D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnBodyController*>            M_pendingCombatJobSeekers;                         // 0x58(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyController*>            M_pendingAmbientJobSeekers;                        // 0x68(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UQtnAIJobRole*>                 M_openAmbientJobRoles;                             // 0x78(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnAIJobRole*>                 M_openCombatJobRoles;                              // 0x88(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FQtnAIJobBoard>                M_openCombatJobBoards;                             // 0x98(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FQtnAIJobBoard>                M_openAmbientJobBoards;                            // 0xA8(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnAIJobCluster>, int32> JobClusterTickets;                                 // 0xB8(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnAIJobCluster>, struct FQtnAIJobClusterTicketRecord> M_jobClusterTicketRecords;                         // 0x108(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAIJobManager* GetDefaultObj();

};

// 0x58 (0x80 - 0x28)
// Class QtnGame.QtnAIJobRole
class UQtnAIJobRole : public UObject
{
public:
	class UQtnAIJobManager*                      M_pCachedJobManager;                               // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyController*                    M_pEmployedAIController;                           // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyController*                    M_pPendingAIController;                            // 0x38(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_nextEmploymentAllowedTime;                       // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isRoleEmploymentOpen;                            // 0x44(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_11CC[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  JobRoleID;                                         // 0x4C(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_11CD[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnAIJobCluster*                      OwningAIJobCluster;                                // 0x58(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIEmployed;                                      // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIUnEmployed;                                    // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAIJobRole* GetDefaultObj();

	void SetRoleEmploymentOpen(bool WantEmploymentOpen);
	bool RequestAIUnEmployment();
	void QtnAIRoleEmployEvent__DelegateSignature(class AQtnBodyController* AIController, class UBlackboardComponent* BlackboardComponent);
	bool IsRoleEmploymentOpen();
	bool IsAIJobRoleViable_ServerOnly(class AQtnPawn* Pawn, bool ForInitialAdoption);
	class AActor* GetOwningActor_ServerOnly();
	class AQtnBodyPawn* GetEmployedBodyPawn();
	class AQtnBodyController* GetEmployedBodyController();
	class UBlackboardComponent* GetEmployedBlackboard();
	bool ForceAIEmployment(class AQtnBodyController* AIController);
};

// 0x48 (0x70 - 0x28)
// Class QtnGame.QtnAINoiseFX
class UQtnAINoiseFX : public UObject
{
public:
	bool                                         M_bIsActive;                                       // 0x28(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_11D9[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPawn*                              M_pNoiseCulpritPawn;                               // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pNoisyActor;                                     // 0x38(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_noiseOrigin;                                     // 0x40(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_nextPlayNoiseTime;                               // 0x4C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bIsLooping;                                        // 0x50(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_11DC[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TimeBetweenNoises;                                 // 0x54(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnNoiseEnum                     NoiseType;                                         // 0x58(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_11DF[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnNoiseConfig                       CustomNoiseConfig;                                 // 0x5C(0x10)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_11E0[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAINoiseFX* GetDefaultObj();

};

// 0x160 (0x320 - 0x1C0)
// Class QtnGame.QtnAIPerceptionComponent
class UQtnAIPerceptionComponent : public UAIPerceptionComponent
{
public:
	class AQtnBodyController*                    M_pOwningController;                               // 0x1C0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AQtnPawn*, struct FQtnPerceptionInfo> M_pawnPerceptions;                                 // 0x1C8(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AQtnPawn*, float>                 M_psychicAwareness;                                // 0x218(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnPerceptionConfig                  PerceptionConfig;                                  // 0x268(0x44)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        MinVisibilityRatioPerception;                      // 0x2AC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_usePerceptionOverride;                           // 0x2B0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1219[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPerceptionConfig                  M_perceptionOverride;                              // 0x2B4(0x44)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                        M_nonPawnTargets;                                  // 0x2F8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                  AggregationKey;                                    // 0x308(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        RoundRobinBucketSize;                              // 0x310(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_121D[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAIPerceptionComponent* GetDefaultObj();

	bool IsObstructedByDeepSnow(class AQtnPawn* OtherPawn);
	void HandleTargetPerceptionUpdated(class AActor* PActor, const struct FAIStimulus& Stimulus);
	void GetPerceivedLocation(class AQtnPawn* OtherPawn, enum class EQtnSensoryEvidenceCategory SenseCategory, struct FVector* PerceivedLocation, float* AwarenessRatio);
	void GetAllKnownEnemies(TArray<class AQtnPawn*>* KnownEnemies);
};

// 0x0 (0x130 - 0x130)
// Class QtnGame.QtnAIPerceptionSystem
class UQtnAIPerceptionSystem : public UAIPerceptionSystem
{
public:

	static class UClass* StaticClass();
	static class UQtnAIPerceptionSystem* GetDefaultObj();

};

// 0x70 (0xF0 - 0x80)
// Class QtnGame.QtnAISense_Hearing
class UQtnAISense_Hearing : public UAISense
{
public:
	TArray<struct FQtnAINoiseEvent>              M_pendingNoiseEvents;                              // 0x80(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                        M_cachedSpeedOfSoundReciprocal;                    // 0x90(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1232[0x54];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SpeedOfSound;                                      // 0xE8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AttenuationSilenceThreshold;                       // 0xEC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAISense_Hearing* GetDefaultObj();

};

// 0x10 (0x58 - 0x48)
// Class QtnGame.QtnAISenseConfig_Hearing
class UQtnAISenseConfig_Hearing : public UAISenseConfig
{
public:
	TSubclassOf<class UQtnAISense_Hearing>       Implementation;                                    // 0x48(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        HearingRange;                                      // 0x50(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter             DetectionByAffiliation;                            // 0x54(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAISenseConfig_Hearing* GetDefaultObj();

};

// 0xD0 (0x200 - 0x130)
// Class QtnGame.QtnAISystem
class UQtnAISystem : public UAISystem
{
public:
	uint8                                        Pad_124E[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UWorld*                                M_pWorld;                                          // 0x138(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnGameInstance*                      M_pGameInstance;                                   // 0x140(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnGameState*                         M_pGameState;                                      // 0x148(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_aiCognitionInhibitors;                           // 0x150(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                        CorpsePopulationCap;                               // 0x160(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1252[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnBodyPawn*>                  M_registeredAICorpses;                             // 0x168(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UQtnAISystemSettings*                  M_pAISystemSettings;                               // 0x178(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1253[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnPatrolManager*                     M_pPatrolManager;                                  // 0x1D0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnTicketManager*                     M_pTicketManager;                                  // 0x1D8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnAIBarkManager*                     M_pAIBarkManager;                                  // 0x1E0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnAIJobManager*                      M_pAIJobManager;                                   // 0x1E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnAllyBotManager*                    M_pAllyBotManager;                                 // 0x1F0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnDangerManager*                     M_pDangerManager;                                  // 0x1F8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAISystem* GetDefaultObj();

	void RemoveAICognitionInhibitor(class UObject* Inhibitor);
	class UQtnAISystem* GetQtnAISystem_ServerOnly(class UObject* WorldContextObject);
	void AddAICognitionInhibitor(class UObject* Inhibitor);
};

// 0x20 (0x48 - 0x28)
// Class QtnGame.QtnAISystemSettings
class UQtnAISystemSettings : public UObject
{
public:
	TSubclassOf<class UQtnAIJobManager>          AIJobManagerClass;                                 // 0x28(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       ThreatLevelRange;                                  // 0x30(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                             NeglectDistance;                                   // 0x38(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnAllyBotManager>        AllyBotManagerClass;                               // 0x40(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAISystemSettings* GetDefaultObj();

};

// 0x70 (0x98 - 0x28)
// Class QtnGame.QtnAllyBotManager
class UQtnAllyBotManager : public UObject
{
public:
	class AQtnGameState*                         M_pOwningGameState;                                // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UQtnHintVolumeComponent*>       M_deepSnowVolumes;                                 // 0x30(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyPawn*>                  M_spawnedBots;                                     // 0x40(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_currentRequestingBody;                           // 0x50(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyPawn*>                  M_pendingRequestingBodies;                         // 0x58(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_allyBotInhibitors;                               // 0x68(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UQtnNavigationSystem*                  M_pNavSys;                                         // 0x78(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_12A2[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_currentDeepSnowIndex;                            // 0x90(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                       M_asyncQueryID;                                    // 0x94(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAllyBotManager* GetDefaultObj();

	class AQtnBodyPawn* SpawnAllyBot_ServerOnly(TSubclassOf<class AQtnBodyPawn> botClass, const struct FVector& Location, struct FRotator& Rotation);
	void RequestPathableDeepSnow_ServerOnly(class AQtnBodyPawn* RequestingBody);
	void RemoveAllyBotInhibitor_ServerOnly(class UObject* Inhibitor);
	void OnToggleBots(bool Inhibited);
	void OnInitAllyBotManager_ServerOnly(class AQtnGameState* OwningGameState);
	void OnDeepSnowRequestComplete(bool Success, class AQtnBodyPawn* RequestingBody, struct FVector& DeepSnowLocation);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnBotDestroy(class AQtnBodyPawn* DestroyedBot);
	void HandleBotDestroyed(class AActor* PDestroyedActor);
	TArray<class AQtnBodyPawn*> GetSpawnedBots_ServerOnly();
	class AQtnGameState* GetOwningGameState();
	class UQtnAllyBotManager* GetAllyBotManager_ServerOnly(class UObject* WorldContextObject);
	bool AreAllyBotsInhibited();
	bool AreAllyBotsInCombat();
	void AddAllyBotInhibitor_ServerOnly(class UObject* Inhibitor);
};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnAnimNotify
class UQtnAnimNotify : public UAnimNotify
{
public:

	static class UClass* StaticClass();
	static class UQtnAnimNotify* GetDefaultObj();

	void OnVerbNotify(class AQtnPawn* AffectedPawn, class UQtnVerb* EncompassingVerb);
};

// 0x10 (0x68 - 0x58)
// Class QtnGame.QtnAnimNotify_PlaySound
class UQtnAnimNotify_PlaySound : public UAnimNotify_PlaySound
{
public:
	float                                        M_lastTriggerTime;                                 // 0x58(0x4)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        RetriggerDelay;                                    // 0x5C(0x4)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         LocalPlayerOnly;                                   // 0x60(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         RequirePlayerControl;                              // 0x61(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_12B0[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimNotify_PlaySound* GetDefaultObj();

};

// 0x30 (0x68 - 0x38)
// Class QtnGame.QtnAnimNotifyBeginEffect
class UQtnAnimNotifyBeginEffect : public UAnimNotify
{
public:
	TSubclassOf<class AQtnFXActor>               FxClass;                                           // 0x38(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LocationOverride;                                  // 0x40(0xC)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                              RotationOverride;                                  // 0x4C(0xC)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                  SocketOverride;                                    // 0x58(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAttachmentRule                   LocationRule;                                      // 0x60(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAttachmentRule                   RotationRule;                                      // 0x61(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAttachmentRule                   ScaleRule;                                         // 0x62(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_12B6[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimNotifyBeginEffect* GetDefaultObj();

};

// 0x30 (0x60 - 0x30)
// Class QtnGame.QtnAnimNotifyDurationEffect
class UQtnAnimNotifyDurationEffect : public UAnimNotifyState
{
public:
	TSubclassOf<class AQtnFXActor>               FxClass;                                           // 0x30(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LocationOverride;                                  // 0x38(0xC)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                              RotationOverride;                                  // 0x44(0xC)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                  SocketOverride;                                    // 0x50(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAttachmentRule                   LocationRule;                                      // 0x58(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAttachmentRule                   RotationRule;                                      // 0x59(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAttachmentRule                   ScaleRule;                                         // 0x5A(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_12BB[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimNotifyDurationEffect* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnAnimNotifyEndEffect
class UQtnAnimNotifyEndEffect : public UAnimNotify
{
public:
	TSubclassOf<class AQtnFXActor>               FxClass;                                           // 0x38(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAnimNotifyEndEffect* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnAnimNotifyEvent
class UQtnAnimNotifyEvent : public UQtnAnimNotify
{
public:
	struct FGameplayTag                          M_eventType;                                       // 0x38(0x8)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAnimNotifyEvent* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnAnimNotifyItemAction
class UQtnAnimNotifyItemAction : public UQtnAnimNotify
{
public:
	enum class EQtnEquipSlot                     EquipSlot;                                         // 0x38(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnItemUseAction                 UseAction;                                         // 0x39(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_12C8[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimNotifyItemAction* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnAnimNotifyItemEquip
class UQtnAnimNotifyItemEquip : public UQtnAnimNotify
{
public:
	enum class EQtnEquipSlot                     EquipSlot;                                         // 0x38(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_12CE[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimNotifyItemEquip* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnAnimNotifyItemUnEquip
class UQtnAnimNotifyItemUnEquip : public UQtnAnimNotify
{
public:
	enum class EQtnEquipSlot                     EquipSlot;                                         // 0x38(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_12D3[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimNotifyItemUnEquip* GetDefaultObj();

};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnAnimNotifyRagdoll
class UQtnAnimNotifyRagdoll : public UQtnAnimNotify
{
public:

	static class UClass* StaticClass();
	static class UQtnAnimNotifyRagdoll* GetDefaultObj();

};

// 0x10 (0x48 - 0x38)
// Class QtnGame.QtnAnimNotifyVO
class UQtnAnimNotifyVO : public UQtnAnimNotify
{
public:
	class FName                                  M_voEvent;                                         // 0x38(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                          M_voEventType;                                     // 0x40(0x8)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAnimNotifyVO* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class QtnGame.QtnAnimWindow
class UQtnAnimWindow : public UAnimNotifyState
{
public:

	static class UClass* StaticClass();
	static class UQtnAnimWindow* GetDefaultObj();

	void OnVerbWindowEnd(class AQtnPawn* AffectedPawn, class UQtnVerb* EncompassingVerb, bool Interrupted);
	void OnVerbWindowBegin(class AQtnPawn* AffectedPawn, class UQtnVerb* EncompassingVerb, float TotalDuration);
};

// 0x8 (0x38 - 0x30)
// Class QtnGame.QtnAnimWindowAITrackingImmunity
class UQtnAnimWindowAITrackingImmunity : public UQtnAnimWindow
{
public:
	float                                        LingerDuration;                                    // 0x30(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_130F[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimWindowAITrackingImmunity* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class QtnGame.QtnAnimWindowAllowCancel
class UQtnAnimWindowAllowCancel : public UQtnAnimWindow
{
public:

	static class UClass* StaticClass();
	static class UQtnAnimWindowAllowCancel* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class QtnGame.QtnAnimWindowBlock
class UQtnAnimWindowBlock : public UQtnAnimWindow
{
public:
	struct FQtnRangedFloat                       ScaledBlockAngle;                                  // 0x30(0x8)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        BlockScaleDistance;                                // 0x38(0x4)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1315[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimWindowBlock* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class QtnGame.QtnAnimWindowDamageImmunity
class UQtnAnimWindowDamageImmunity : public UQtnAnimWindow
{
public:
	TArray<TSubclassOf<class UQtnDamageType>>    DamageImmunities;                                  // 0x30(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAnimWindowDamageImmunity* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class QtnGame.QtnAnimWindowInput
class UQtnAnimWindowInput : public UQtnAnimWindow
{
public:

	static class UClass* StaticClass();
	static class UQtnAnimWindowInput* GetDefaultObj();

};

// 0x58 (0x88 - 0x30)
// Class QtnGame.QtnAnimWindowMelee
class UQtnAnimWindowMelee : public UQtnAnimWindow
{
public:
	float                                        DamageMultiplier;                                  // 0x30(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        KnockbackMultiplier;                               // 0x34(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttackMotion                  AttackMotion;                                      // 0x38(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnWeaponSocketLocation          WeaponSocketLocation;                              // 0x39(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1324[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  MeleeSocketBaseName;                               // 0x3C(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  MeleeSocketTipName;                                // 0x44(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ColliderRadius;                                    // 0x4C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseActorSpaceMath;                                 // 0x50(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1327[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               BaseSocketOffset;                                  // 0x54(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               TipSocketOffset;                                   // 0x60(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  FXSetKey;                                          // 0x6C(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnHitStopResponse               HitStopResponse;                                   // 0x74(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CausesKnockdown;                                   // 0x75(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1329[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        KnockdownDuration;                                 // 0x78(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CanBeParried;                                      // 0x7C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CanBeBlocked;                                      // 0x7D(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1332[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        SharedMeleeIndex;                                  // 0x80(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1334[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimWindowMelee* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class QtnGame.QtnAnimWindowParry
class UQtnAnimWindowParry : public UQtnAnimWindow
{
public:
	struct FQtnRangedFloat                       ScaledParryAngle;                                  // 0x30(0x8)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        ParryScaleDistance;                                // 0x38(0x4)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1340[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimWindowParry* GetDefaultObj();

};

// 0x90 (0xC0 - 0x30)
// Class QtnGame.QtnAnimWindowRotation
class UQtnAnimWindowRotation : public UQtnAnimWindow
{
public:
	float                                        MaxRotation;                                       // 0x30(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1343[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRuntimeFloatCurve                    RotationCurve;                                     // 0x38(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAnimWindowRotation* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class QtnGame.QtnAnimWindowTransition
class UQtnAnimWindowTransition : public UQtnAnimWindow
{
public:

	static class UClass* StaticClass();
	static class UQtnAnimWindowTransition* GetDefaultObj();

};

// 0x1B8 (0x1E8 - 0x30)
// Class QtnGame.QtnAnimWindowTranslation
class UQtnAnimWindowTranslation : public UQtnAnimWindow
{
public:
	float                                        TranslationDistanceForward;                        // 0x30(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_134B[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRuntimeFloatCurve                    TranslationCurveForward;                           // 0x38(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                        DistanceMultiplierWithoutTarget;                   // 0xC0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TranslationDistanceUp;                             // 0xC4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                    TranslationCurveUp;                                // 0xC8(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                        TranslationDistanceRight;                          // 0x150(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_134F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRuntimeFloatCurve                    TranslationCurveRight;                             // 0x158(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                        StrikingDistance;                                  // 0x1E0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         TrackTargetZ;                                      // 0x1E4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1351[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAnimWindowTranslation* GetDefaultObj();

};

// 0x28 (0x4A0 - 0x478)
// Class QtnGame.QtnAssetManager
class UQtnAssetManager : public UAssetManager
{
public:
	int32                                        LastInitialChunkId;                                // 0x478(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_135E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnPakChunk>>      PakChunkArchetypes;                                // 0x480(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FQtnDLCPakChunkArray>          DLCPakChunkArrays;                                 // 0x490(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAssetManager* GetDefaultObj();

	bool IsFullGameInstalled();
};

// 0x40 (0x70 - 0x30)
// Class QtnGame.QtnAsyncInterpolateValue
class UQtnAsyncInterpolateValue : public UBlueprintAsyncActionBase
{
public:
	class UObject*                               WorldContext;                                      // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_136F[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_StartValue;                                      // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_TargetValue;                                     // 0x44(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_RunTime;                                         // 0x48(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_CurrentRunTime;                                  // 0x4C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            Tick;                                              // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            Completed;                                         // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAsyncInterpolateValue* GetDefaultObj();

	void TickTask();
	void QtnFloatOutputPin__DelegateSignature(float Value);
	void CompleteTask();
	class UQtnAsyncInterpolateValue* AsyncInterpolateValue(class UObject* WorldContextObject, float StartValue, float TargetValue, float Duration, struct FTimerHandle& OptionalTimerHandle);
};

// 0x40 (0x70 - 0x30)
// Class QtnGame.QtnAsyncInterpolateValueRealtime
class UQtnAsyncInterpolateValueRealtime : public UBlueprintAsyncActionBase
{
public:
	class UObject*                               WorldContext;                                      // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1387[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_StartValue;                                      // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_TargetValue;                                     // 0x44(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_RunTime;                                         // 0x48(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_CurrentRunTime;                                  // 0x4C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            Tick;                                              // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            Completed;                                         // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAsyncInterpolateValueRealtime* GetDefaultObj();

	bool TickTask(float Delta);
	void QtnFloatOutputPin__DelegateSignature(float Value);
	void CompleteTask();
	class UQtnAsyncInterpolateValueRealtime* AsyncInterpolateValueRealtime(class UObject* WorldContextObject, float StartValue, float TargetValue, float Duration, struct FDelegateHandleBlueprint& OptionalHandle);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.DelegateHandleBlueprintLibrary
class UDelegateHandleBlueprintLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UDelegateHandleBlueprintLibrary* GetDefaultObj();

	void ClearAndInvalidateDelegateHandleBlueprint(struct FDelegateHandleBlueprint& Handle, class UObject* WorldContextObject);
};

// 0x28 (0x58 - 0x30)
// Class QtnGame.QtnAsyncWaitUntilMaterialFullyStreamed
class UQtnAsyncWaitUntilMaterialFullyStreamed : public UBlueprintAsyncActionBase
{
public:
	class UObject*                               WorldContext;                                      // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1398[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInterface*                    M_pTargetMaterial;                                 // 0x40(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            Completed;                                         // 0x48(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAsyncWaitUntilMaterialFullyStreamed* GetDefaultObj();

	void TickTask();
	void QtnExecuteOutputPin__DelegateSignature();
	void CompleteTask();
	class UQtnAsyncWaitUntilMaterialFullyStreamed* AsyncWaitUntilMaterialFullyStreamed(class UObject* WorldContextObject, class UMaterialInterface* TargetMaterial, struct FTimerHandle& OptionalTimerHandle);
};

// 0xA8 (0xD0 - 0x28)
// Class QtnGame.QtnAttribute
class UQtnAttribute : public UObject
{
public:
	uint8                                        Pad_13B3[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        R_currentValue;                                    // 0x2C(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_oldValue;                                        // 0x30(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_currentMin;                                      // 0x34(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_currentMax;                                      // 0x38(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_locked;                                          // 0x3C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_13B4[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UObject*                               M_pOwningObject;                                   // 0x40(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pAffectedBody;                                   // 0x48(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_nextTickTime;                                    // 0x50(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_13B5[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pReferenceActor;                                 // 0x60(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                  M_name;                                            // 0x68(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                        M_defaultValue;                                    // 0x80(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttributeRounding             M_rounding;                                        // 0x84(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttributeReplication          M_replication;                                     // 0x85(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttributeTick                 M_tick;                                            // 0x86(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_13B7[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_tickRate;                                        // 0x88(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_clampMin;                                        // 0x8C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_13B8[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_defaultMin;                                      // 0x90(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_clampMax;                                        // 0x94(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_13B9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_defaultMax;                                      // 0x98(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_useModifiedValuesForEvents;                      // 0x9C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_13BA[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnAttributeTrigger>          M_triggers;                                        // 0xA0(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnValueChangedEvent;                               // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAttributePreRemovedEvent;                        // 0xC0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAttribute* GetDefaultObj();

	float OverrideSetCurrentValue(float NewValue);
	void OnTriggerHit(int32 Index, float Threshold, enum class EQtnAttributeThresholdDirection Direction);
	void OnTick(float DeltaTime);
	void OnRep_CurrentValue();
	void OnRemoved();
	void OnIncreased(float AmountIncreased);
	void OnDecreased(float AmountDecreased);
	void OnAdded();
	void HasAuthority(enum class EQtnOutputAuthorityEnum* OutputPin);
	void GetRange(bool UseDefaultRange, float* MinValue, float* MaxValue);
	class UObject* GetOwningObject();
	TScriptInterface<class IQtnAttributeContainerInterface> GetOwningInterface();
	float GetCurrentValue(bool ApplyModifiers);
	float GetCurrentRatio(bool ApplyModifiers);
	class AQtnBodyPawn* GetAffectedBody();
};

// 0x2A0 (0x380 - 0xE0)
// Class QtnGame.QtnAttributeComponent
class UQtnAttributeComponent : public UActorComponent
{
public:
	uint8                                        Pad_13C7[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnAttributeContainer                R_attributeContainer;                              // 0xF0(0x258)(Edit, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPrivate)
	bool                                         M_areAttributesSafeToTick;                         // 0x348(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_13C8[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnAttributeAddedEvent;                             // 0x350(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAttributeRemovedEvent;                           // 0x360(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x370(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAttributeComponent* GetDefaultObj();

	void OnRep_AttributeContainer();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnAttributeContainerInterface
class IQtnAttributeContainerInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnAttributeContainerInterface* GetDefaultObj();

	void UnTriggerModifierEvent(TSubclassOf<class UQtnAttributeModifierEvent> AttributeModifierEvent);
	void UnlockAttribute(TSubclassOf<class UQtnAttribute> Attribute);
	void TriggerModifierEvent(TSubclassOf<class UQtnAttributeModifierEvent> AttributeModifierEvent);
	void SetAttributeValue(TSubclassOf<class UQtnAttribute> Attribute, float Value);
	void SetAttributeMin(TSubclassOf<class UQtnAttribute> Attribute, float NewMin);
	void SetAttributeMax(TSubclassOf<class UQtnAttribute> Attribute, float NewMax);
	void RemoveModifier(TSubclassOf<class UQtnAttributeModifier> Modifier);
	void RemoveAttribute(TSubclassOf<class UQtnAttribute> Attribute);
	void OnAttributeRemoved(TSubclassOf<class UQtnAttribute> AttributeClass, class UQtnAttribute* Attribute);
	void OnAttributeAdded(TSubclassOf<class UQtnAttribute> AttributeClass, class UQtnAttribute* Attribute);
	void LockAttribute(TSubclassOf<class UQtnAttribute> Attribute);
	bool IsModifierEventActive(TSubclassOf<class UQtnAttributeModifierEvent> AttributeModifierEvent);
	void IncreaseAttributeValue(TSubclassOf<class UQtnAttribute> Attribute, float Amount);
	bool HasModifier(TSubclassOf<class UQtnAttributeModifier> Modifier);
	bool HasDefaultAttribute(TSubclassOf<class UQtnAttribute> Attribute);
	bool HasAttribute(TSubclassOf<class UQtnAttribute> Attribute);
	class AActor* GetReferenceActor();
	float GetDefaultAttributeValue(TSubclassOf<class UQtnAttribute> Attribute);
	float GetAttributeValue(TSubclassOf<class UQtnAttribute> Attribute, bool ApplyModifiers);
	TArray<class UQtnAttribute*> GetAttributes(TArray<TSubclassOf<class UQtnAttribute>>& Attributes);
	struct FQtnRangedFloat GetAttributeRange(TSubclassOf<class UQtnAttribute> Attribute, bool* ClampedMin, bool* ClampedMax);
	float GetAttributeMin(TSubclassOf<class UQtnAttribute> Attribute);
	float GetAttributeMax(TSubclassOf<class UQtnAttribute> Attribute);
	TSubclassOf<class UQtnAttribute> GetAttributeClassByName(class FName AttributeName);
	class UQtnAttribute* GetAttribute(TSubclassOf<class UQtnAttribute> Attribute);
	TArray<class UQtnAttribute*> GetAllAttributes();
	void DecreaseAttributeValue(TSubclassOf<class UQtnAttribute> Attribute, float Amount);
	float ApplyModifiersToEnumAttributeValue(enum class EQtnAttributeEnum EnumAttribute, float Value);
	float ApplyModifiersToAttributeValue(TSubclassOf<class UQtnAttribute> Attribute, float Value);
	void AdjustAttributeValue(TSubclassOf<class UQtnAttribute> Attribute, float Amount);
	void AddModifier(TSubclassOf<class UQtnAttributeModifier> Modifier);
	class UQtnAttribute* AddAttribute(TSubclassOf<class UQtnAttribute> Attribute);
};

// 0x8 (0xD8 - 0xD0)
// Class QtnGame.QtnAttributeHitReactionThreshold
class UQtnAttributeHitReactionThreshold : public UQtnAttribute
{
public:
	float                                        RecoveryRate;                                      // 0xD0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ShowLog;                                           // 0xD4(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_14A8[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAttributeHitReactionThreshold* GetDefaultObj();

};

// 0x20 (0x48 - 0x28)
// Class QtnGame.QtnAttributeModifier
class UQtnAttributeModifier : public UObject
{
public:
	TSubclassOf<class UQtnAttributeModifierEvent> M_event;                                           // 0x28(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnAttribute>             M_attribute;                                       // 0x30(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttributeEnum                 M_enumAttribute;                                   // 0x38(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttributeModifierFunction     M_function;                                        // 0x39(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_14B1[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_value;                                           // 0x3C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAttributeModifierReplication  M_replication;                                     // 0x40(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_14B3[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAttributeModifier* GetDefaultObj();

};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnAttributeModifierEvent
class UQtnAttributeModifierEvent : public UObject
{
public:
	enum class EQtnAttributeModifierEventReplication M_replication;                                     // 0x28(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_14BA[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnAttributeModifierEvent* GetDefaultObj();

};

// 0x10 (0xE0 - 0xD0)
// Class QtnGame.QtnAttributePinkEye
class UQtnAttributePinkEye : public UQtnAttribute
{
public:
	float                                        ReducePinkEyePerSecond;                            // 0xD0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_14C1[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnStatusEffect>          StatusEffect;                                      // 0xD8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAttributePinkEye* GetDefaultObj();

};

// 0x70 (0x2D0 - 0x260)
// Class QtnGame.QtnAttributePipWidget
class UQtnAttributePipWidget : public UUserWidget
{
public:
	class UMaterialInstanceDynamic*              M_pAttributePipMaterial;                           // 0x260(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnAttribute*                         M_pAssociatedAttribute;                            // 0x268(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bHasMetAttributeThreshold;                       // 0x270(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bIsVisible;                                      // 0x271(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_14E1[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  M_AttributeRadialPropertyName;                     // 0x274(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  M_AttributeBGColorPropertyName;                    // 0x27C(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  M_AttributeIconFlipbookPropertyName;               // 0x284(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  M_IsActivePropertyName;                            // 0x28C(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  M_IconColorPropertyName;                           // 0x294(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_14E4[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnRequestVisibilityEvent;                          // 0x2A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnClearVisibilityEvent;                            // 0x2B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnRequestRemovalEvent;                             // 0x2C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnAttributePipWidget* GetDefaultObj();

	void QtnAttributePipWidgetEvent__DelegateSignature(class UQtnAttributePipWidget* SourceWidget);
	void QtnAttributePipClassWidgetEvent__DelegateSignature(class UQtnAttributePipWidget* SourceWidget, TSubclassOf<class UQtnAttribute> AttributeClass);
	void OnAttributeValueMetThreshold(class UQtnAttribute* Attribute, float Value);
	void OnAttributeValueDepleted(class UQtnAttribute* Attribute, float Value);
	void OnAttributeValueChanged(class UQtnAttribute* Attribute, float Value);
	void OnAttributeRemoved(class UQtnAttribute* Attribute);
	void InitializeAttributePipWidget(struct FQtnAttributePipInitializationParameters& InitializationParameters);
	class UQtnAttribute* GetAssociatedAttribute();
};

// 0x8 (0xD8 - 0xD0)
// Class QtnGame.QtnAttributeRage
class UQtnAttributeRage : public UQtnAttribute
{
public:
	bool                                         R_Upgrade_Ragaholic;                               // 0xD0(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_14FB[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        R_Ragaholic_Scaler;                                // 0xD4(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAttributeRage* GetDefaultObj();

	void SetUpgrade_Ragaholic(bool NewValue);
	void SetRagaholic_Scaler(float NewValue);
	bool GetUpgrade_Ragaholic();
	float GetRagaholic_Scaler();
};

// 0x28 (0xF8 - 0xD0)
// Class QtnGame.QtnAttributeStamina
class UQtnAttributeStamina : public UQtnAttribute
{
public:
	float                                        ExhaustionDuration;                                // 0xD0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RegenPerSecondDuringVerb;                          // 0xD4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RegenPerSecondWhileIdle;                           // 0xD8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ExhaustionTimer;                                   // 0xDC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnStaminaChanged;                                  // 0xE0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          M_owningBodyPawn;                                  // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAttributeStamina* GetDefaultObj();

};

// 0x20 (0x100 - 0xE0)
// Class QtnGame.QtnAuraComponent
class UQtnAuraComponent : public UActorComponent
{
public:
	class AQtnPawn*                              OwningPawn;                                        // 0xE0(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SquaredRadius;                                     // 0xE8(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_150B[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnPawn*>                      AppliedPawns;                                      // 0xF0(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnAuraComponent* GetDefaultObj();

	void RemoveEffect(class AQtnPawn* Target);
	void CleanupAppliedEffects();
	void ApplyEffectToPawns(TArray<class AQtnPawn*>& PlayerAndAllyPawns);
	void ApplyEffect(class AQtnPawn* Target);
};

// 0x0 (0x2C8 - 0x2C8)
// Class QtnGame.QtnBehaviorTreeComponent
class UQtnBehaviorTreeComponent : public UBehaviorTreeComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnBehaviorTreeComponent* GetDefaultObj();

};

// 0x0 (0x1E8 - 0x1E8)
// Class QtnGame.QtnBlackboardComponent
class UQtnBlackboardComponent : public UBlackboardComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnBlackboardComponent* GetDefaultObj();

};

// 0x38 (0x2F0 - 0x2B8)
// Class QtnGame.QtnBodyAnimInstance
class UQtnBodyAnimInstance : public UAnimInstance
{
public:
	class AQtnBodyPawn*                          M_pOwningBodyPawn;                                 // 0x2B8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnLocoIntentionEnum             LocoIntention;                                     // 0x2C0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnBodyStance                    bodyStance;                                        // 0x2C1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EMovementMode                     MovementMode;                                      // 0x2C2(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1516[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LocoDirection;                                     // 0x2C4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LocoThrottle;                                      // 0x2C8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AimYaw;                                            // 0x2CC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AimPitch;                                          // 0x2D0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LeanRoll;                                          // 0x2D4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsLeftHandUp;                                      // 0x2D8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsLeftHandEquipped;                                // 0x2D9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsRightHandUp;                                     // 0x2DA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsRightHandEquipped;                               // 0x2DB(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseHeadAim;                                        // 0x2DC(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_151A[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LookAimRatio;                                      // 0x2E0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        NormalizedTime;                                    // 0x2E4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsLocalPlayer;                                     // 0x2E8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsPlayerControlled;                                // 0x2E9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_151D[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBodyAnimInstance* GetDefaultObj();

};

// 0xF8 (0x3E8 - 0x2F0)
// Class QtnGame.QtnBodyAnimGraphTP
class UQtnBodyAnimGraphTP : public UQtnBodyAnimInstance
{
public:
	class UAimOffsetBlendSpace1D*                LeanBlendTP;                                       // 0x2F0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                  UpperBodyAimBlendTP;                               // 0x2F8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           HeadAimBlendTP;                                    // 0x300(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                         AimPitchBlend;                                     // 0x308(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseAimPitchBlend;                                  // 0x310(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1526[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UBlendSpace*                           UprightLocoBlendTP;                                // 0x318(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           SearchUprightLocoBlendTP;                          // 0x320(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           CombatUprightLocoBlendTP;                          // 0x328(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           FleeLocoBlendTP;                                   // 0x330(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           SprintLocoBlendTP;                                 // 0x338(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           LeftArmAimBlendTP;                                 // 0x340(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                         LeftArmEquippedPoseTP;                             // 0x348(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                           RightArmAimBlendTP;                                // 0x350(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                         RightArmEquippedPoseTP;                            // 0x358(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                         JumpIntro;                                         // 0x360(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                         JumpLoop;                                          // 0x368(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                         JumpOutro;                                         // 0x370(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LeftFootIKEffectorLocation;                        // 0x378(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LeftFootIKTargetLocation;                          // 0x384(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LeftFootIKInfluence;                               // 0x390(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               RightFootIKEffectorLocation;                       // 0x394(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               RightFootIKTargetLocation;                         // 0x3A0(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RightFootIKInfluence;                              // 0x3AC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               RightHandIKEffectorLocation;                       // 0x3B0(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               RightHandIKTargetLocation;                         // 0x3BC(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RightHandIKInfluence;                              // 0x3C8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LeftHandIKEffectorLocation;                        // 0x3CC(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LeftHandIKTargetLocation;                          // 0x3D8(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LeftHandIKInfluence;                               // 0x3E4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnBodyAnimGraphTP* GetDefaultObj();

};

// 0x2B8 (0x608 - 0x350)
// Class QtnGame.QtnBodyController
class AQtnBodyController : public AAIController
{
public:
	float                                        LocoSpeedMultipliers[0x3];                         // 0x350(0xC)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RelaxedThinkInterval;                              // 0x35C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       BackgroundCombatThinkInterval;                     // 0x364(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       ActiveCombatThinkInterval;                         // 0x36C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_thinkInduced;                                    // 0x374(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isCurrentlyDoingThink;                           // 0x375(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1682[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_timeUntilNextForcedThinkInduction;               // 0x378(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_timeSinceLastThought;                            // 0x37C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnGameState*                         M_pCachedGameState;                                // 0x380(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_readyForGameplayPending;                         // 0x388(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1688[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               M_homeLocation;                                    // 0x38C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_generalSearchLocation;                           // 0x398(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_168B[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnVerb>                  M_pendingCheatVerbClass;                           // 0x3A8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnVerb>                  M_knownDodgeVerbClass;                             // 0x3B0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            BodyControllerOccupied;                            // 0x3B8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintAuthorityOnly, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            BodyControllerUnOccupied;                          // 0x3C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintAuthorityOnly, NativeAccessSpecifierProtected)
	struct FQtnPawnIntentions                    M_bodyIntentionsFromAI;                            // 0x3D8(0x78)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          M_pPossessedPawn;                                  // 0x450(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AbleToSenseDangerVolumes;                          // 0x458(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1693[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnDangerVolume*                      M_pLastAcknowledgedDangerVolume;                   // 0x460(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_wantsAIToDodge;                                  // 0x468(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ForceFlee;                                         // 0x469(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_169C[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnPathFollowingComponent*            M_pPathFollowingComponent;                         // 0x470(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnAIPerceptionComponent*             M_pPerceptionComponent;                            // 0x478(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ThreatLevel;                                       // 0x480(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ReactionTimeBeforeThreatIsInvalid;                 // 0x484(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                       SystemicBlackboardAsset;                           // 0x488(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateCombat*                 M_pCombatState;                                    // 0x490(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateFollowAlly*             M_pFollowAllyState;                                // 0x498(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateFlee*                   M_pFleeState;                                      // 0x4A0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateInvestigate*            M_pInvestigateState;                               // 0x4A8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStatePatrol*                 M_pPatrolState;                                    // 0x4B0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStatePlayerControlled*       M_pPlayerControlledState;                          // 0x4B8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateScriptedAction*         M_pScriptedActionState;                            // 0x4C0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateScriptedBT*             M_pScriptedBTState;                                // 0x4C8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateScriptedDestination*    M_pScriptedDestinationState;                       // 0x4D0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateSearch*                 M_pSearchState;                                    // 0x4D8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalStateIncapacitated*          M_pIncapacitatedState;                             // 0x4E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalFSM*                         M_pMentalFSM;                                      // 0x4E8(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAILOD                         M_aiLOD;                                           // 0x4F0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_16AC[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UObject*                               M_pUpperBodyScriptedActionCaller;                  // 0x4F8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_upperBodyScriptedActionTimer;                    // 0x500(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_upperBodyScriptedActionOverridesCombat;          // 0x504(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_16AD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_perceptionOverrideTimer;                         // 0x508(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_cognitiveFunctionsDelay;                         // 0x50C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnSensoryEvidenceCategory       M_reasonForInvestigate;                            // 0x510(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_16B2[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pTetherAnchor;                                   // 0x518(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnSkirmish*                          M_pOwningSkirmish;                                 // 0x520(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       M_tetherRadii;                                     // 0x528(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        M_tetherVerticalRatio;                             // 0x530(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_16B7[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          M_pRoamingTarget;                                  // 0x538(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pBodyToDefend;                                   // 0x540(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>            M_ignoredEmployerArchetypes;                       // 0x548(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AQtnWaypoint*                          M_pAdoptedWaypoint;                                // 0x558(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pAllyInNeedOfHelp;                               // 0x560(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_cachedNearestAllyDestination;                    // 0x568(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_cachedNarrowestAllyDestination;                  // 0x574(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_nearestAllyDestinationNeedsRefresh;              // 0x580(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_16BF[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_aiJobInhibitors;                                 // 0x588(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UQtnAISystem*                          M_pCachedAISystem;                                 // 0x598(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIEmployed;                                      // 0x5A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAIUnEmployed;                                    // 0x5B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       RoamingPatience;                                   // 0x5C0(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       DefaultTetherRadii;                                // 0x5C8(0x8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        MinCombatAvoidanceRange;                           // 0x5D0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         NeverHideFromEnemy;                                // 0x5D4(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IgnoreForegroundTickets;                           // 0x5D5(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IgnoreAttackTickets;                               // 0x5D6(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CanTeleportToDestination;                          // 0x5D7(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         PreferAttacksFromDestinations;                     // 0x5D8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_16C7[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnMentalSubStateReviveTactics*       M_pSystemicReviveTactics;                          // 0x5E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         OnlyAcceptFilteredAIJobs;                          // 0x5E8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         NeverAcceptAnyAIJob;                               // 0x5E9(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_16C9[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPlayerPawn*                        M_pOccupyingPlayerPawn;                            // 0x5F0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        M_pLastKnownOccupyingPlayerPawn;                   // 0x5F8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isWaitingForOccupy;                              // 0x600(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_16CC[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnBodyController* GetDefaultObj();

	void TempPsychicAwareness_Server(float Time, class AQtnBodyPawn* Target, float MinAwarenessRatio);
	void SetTetheredPatrolRouteComponent(class UQtnPatrolRouteComponent* PatrolRouteComponent);
	void SetTetherAnchor(class AActor* TetherAnchor, struct FQtnRangedFloat& TetherRadii, float TetherVerticalRatio);
	void SetScriptedDestinationManually(const struct FVector& Position, const struct FRotator& Rotation, enum class EQtnLocoSpeedEnum LocoSpeed, enum class EQtnBodyStance bodyStance, bool OverrideCombat, float TimeBeforeGivingUp, bool FinishUponReachingDestination);
	void SetScriptedDestination(class AActor* DestinationActor, enum class EQtnLocoSpeedEnum LocoSpeed, enum class EQtnBodyStance bodyStance, bool OverrideCombat, float TimeBeforeGivingUp, bool FinishUponReachingDestination);
	void SetScriptedAction(class UObject* ScriptedActionCaller, struct FQtnActionIntention& ActionIntention, bool OverrideCombat, float Duration, class AActor* LookFocus, bool InterruptCombat);
	void SetRoamingTarget(class AQtnBodyPawn* RoamingTarget);
	void SetPerceptionOverride(struct FQtnPerceptionConfig& PerceptionOverride, float Duration);
	void SetHomeLocation(struct FVector& HomeLocation);
	void SetHearingVisionOverride(bool WantHearing, bool WantVision, float Duration);
	void SetGeneralSearchLocation(struct FVector& GeneralSearchLocation);
	void SetCheatVerbClass(TSubclassOf<class UQtnVerb> CheatVerbClass);
	void ReturnForegroundTicket();
	void ReturnAttackTicket();
	void RemovePsychicAwareness(class AQtnPawn* Perpetrator);
	void RemoveIgnoredEmployer(TSubclassOf<class AActor> EmployerArchetype);
	void RemoveAIJobInhibitor(class UObject* JobInhibitor);
	void QtnBodyControllerEmployEvent__DelegateSignature(class UQtnAIJobRole* AiJobRole, class FName ClusterID, class FName RoleID, class UQtnAIJobComponent* JobComponent, bool IsCombatJob);
	void PushScriptedAction(struct FQtnActionIntention& NonLoopingActionIntention);
	void OnThink(float TimeSinceLastThought);
	void OnQtnReadyForGameplay(class AQtnBodyPawn* bodyPawn);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnBodyControllerUnOccupied(class AQtnPlayerPawn* OccupyingPlayerPawn);
	void OnBodyControllerOccupied(class AQtnPlayerPawn* OccupyingPlayerPawn);
	bool IsUsingScriptedDestination(class AActor** DestinationActor);
	bool IsUsingScriptedAction(class UObject** ScriptedActionCaller);
	bool IsTrackingEnemyForCombat();
	bool IsReadyForGameplay();
	bool IsOccupiedAndUnsuppressed();
	bool IsInActiveCombatPursuit();
	bool IsEmployerIgnored(class AActor* JobComponentOwner);
	bool IsCurrentlyOnPatrol();
	bool HasForegroundTicket();
	bool HasAttackTicket();
	void HandleInventoryItemRemoved(class AQtnItem* PRemovedItem);
	void HandleInventoryItemAdded(class AQtnItem* PAddedItem);
	class UQtnPatrolRouteComponent* GetTetheredPatrolRouteComponent();
	struct FVector GetTetherAnchorLocation();
	class AActor* GetTetherAnchor();
	class AQtnBodyPawn* GetRoamingTarget();
	class AQtnPawn* GetRelevantEnemy();
	class UQtnAIPerceptionComponent* GetQtnPerceptionComponent();
	class UQtnPathFollowingComponent* GetQtnPathFollowingComponent();
	struct FVector GetPerceivedTargetLocation();
	class AQtnSkirmish* GetOwningSkirmish();
	struct FVector GetNearestFormationParticipantDestination(struct FVector& ReferenceLocation, struct FVector* NearestBasedOnAngle);
	struct FVector GetLastNavLocation();
	struct FVector GetHomeLocation();
	struct FVector GetGeneralSearchLocation();
	class AActor* GetFormationTarget();
	class UQtnVerb* GetFavoriteAttackVerb();
	float GetFavoriteAttackRange(bool* IsRangedCombatant);
	class UQtnNavLinkCustomComponent* GetCurrentNavLink(bool* IsMovingForward);
	float GetCombatAvoidanceRange();
	class AQtnBodyPawn* GetClosestPlayer();
	class AQtnBodyPawn* GetBodyPawn();
	class AQtnBodyPawn* GetAllyInNeedOfHelp();
	void GetAllBodyControllers(class UObject* SelfReference, TArray<class AQtnBodyController*>* FoundBodyControllers, class FName ActorTagFilter, class FName SpawnerRegionFilter);
	class UQtnAIJobRole* GetAIJobRole();
	void ForgetEverything();
	void FindAllyToHelp();
	void DefendOtherBody(class AQtnBodyPawn* bodyToDefend);
	void ClearPerceptionOverride();
	void ClearAllIgnoredEmployers();
	class AQtnBodyPawn* ChooseAllyToHelp(TArray<class AQtnBodyPawn*>& AllyBodies);
	void CancelScriptedDestination();
	void CancelScriptedAction(class UObject* ScriptedActionCaller);
	void AddPsychicAwarenessOfAllPlayers_ServerOnly(bool bBotsToo, float MinAwarenessRatio);
	void AddPsychicAwareness(class AQtnPawn* Perpetrator, float MinAwarenessRatio);
	void AddIgnoredEmployer(TSubclassOf<class AActor> EmployerArchetype);
	void AddAIJobInhibitor(class UObject* JobInhibitor);
};

// 0xF8 (0x120 - 0x28)
// Class QtnGame.QtnDataBag
class UQtnDataBag : public UObject
{
public:
	bool                                         M_hasBeenLoaded;                                   // 0x28(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1720[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<TSubclassOf<class UQtnDataBag>, class UQtnDataBag*> M_dataBagInstances;                                // 0x30(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnDataBag>, struct FQtnDataBagBytes> M_dataBagBytes;                                    // 0x80(0x50)(SaveGame, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnDataBag>>       ChildDataBags;                                     // 0xD0(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UQtnSaveData*                          M_pOwningSaveData;                                 // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnDataBag*                           M_pParentDataBag;                                  // 0xE8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnVersion                           M_storedDataBagVersion;                            // 0xF0(0xC)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FQtnVersion                           DeprecatedDataBagVersion;                          // 0xFC(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnVersion                           LatestDataBagVersion;                              // 0x108(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnVersion                           M_currentDataBagVersion;                           // 0x114(0xC)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDataBag* GetDefaultObj();

	void PreSaveDataBP(class UQtnSaveData* SaveData, class AQtnBodyPawn* LocalOriginalBody);
	void PreLoadDataBP(class UQtnSaveData* SaveData, class AQtnBodyPawn* LocalOriginalBody);
	void PostSaveDataBP(class UQtnSaveData* SaveData, bool Success, class AQtnBodyPawn* LocalOriginalBody);
	void PostLoadDataBP(class UQtnSaveData* SaveData, bool Success, class AQtnBodyPawn* LocalOriginalBody);
	void OnReadyForGameplay(class AQtnPlayerController* LocalPlayerController, class AQtnPlayerUI* LocalPlayerUI, class AQtnBodyPawn* LocalOccupiedBodyPawn);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool HasValidBagData();
	class UQtnDataBag* GetParentDataBag();
	class UQtnDataBag* GetChildDataBag(TSubclassOf<class UQtnDataBag> DatabagArchetype);
};

// 0x8 (0x128 - 0x120)
// Class QtnGame.QtnBodyDataBag
class UQtnBodyDataBag : public UQtnDataBag
{
public:
	class AQtnBodyPawn*                          M_pAssociatedBodyPawn;                             // 0x120(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnBodyDataBag* GetDefaultObj();

	void OnBodyDataBagUnOccupy(class AQtnBodyPawn* OccupiedBodyPawn);
	void OnBodyDataBagOccupy(class AQtnBodyPawn* OccupiedBodyPawn);
};

// 0x5E0 (0xAD0 - 0x4F0)
// Class QtnGame.QtnPawn
class AQtnPawn : public ACharacter
{
public:
	uint8                                        Pad_191D[0x40];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UActorComponent*>               M_pawnLODComponents;                               // 0x530(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_clientAdjustmentInhibitors;                      // 0x540(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UQtnTeam*                              R_pCachedTeam;                                     // 0x550(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnTeam*                              L_pCachedTeam;                                     // 0x558(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_191F[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_readyForGameplayPending;                         // 0x570(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1920[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               M_respawnLocation;                                 // 0x574(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_numTimesOutOfWorld;                              // 0x580(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lastOutOfWorldSafeLocation;                      // 0x584(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_numTimesLastSafeLocationUsed;                    // 0x590(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                              M_originalMeshRelativeRotation;                    // 0x594(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                               M_originalMeshRelativeLocation;                    // 0x5A0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_originalMeshScale;                               // 0x5AC(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_targetPawnScale;                                 // 0x5B8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1922[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPendingVerbRequest                R_pendingVerbRequest;                              // 0x5C0(0x18)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnPendingVerbRequest                L_pendingVerbRequest;                              // 0x5D8(0x18)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FText                                  DisplayName;                                       // 0x5F0(0x18)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnDisplayNameChangedEvent;                         // 0x608(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0x618(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                        OnScreenLODMovementTickRate;                       // 0x630(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1924[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnGameState*                         M_pCachedGameState;                                // 0x638(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnCameraComponent*                   CameraComponent;                                   // 0x640(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                       M_onlyRenderInSceneCaptureRequestors;              // 0x648(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                M_pLastBlockingActor;                              // 0x658(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnPawnIntentions                    R_pawnIntentions;                                  // 0x660(0x78)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	enum class EQtnPawnLOD                       M_pawnLOD;                                         // 0x6D8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1927[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          M_pBodyToBlame;                                    // 0x6E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnCarryComponent*                    M_pCarryComponent;                                 // 0x6E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AQtnPawn*>                      M_overlappingPawns;                                // 0x6F0(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                        M_overlappingNonPawns;                             // 0x700(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                        M_overlappingDroppedActors;                        // 0x710(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                        M_recentlyTouchedActors;                           // 0x720(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                        M_recentlyHitActorResetCountdown;                  // 0x730(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ActorRetouchDelay;                                 // 0x734(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQtnHintVolumeComponent*>       M_encompassingDeepSnowVolumes;                     // 0x738(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                        LaunchSlipperyDuration;                            // 0x748(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_slipperyTimer;                                   // 0x74C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            ReadyForGameplayEvent;                             // 0x750(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnTouchOtherActor;                                 // 0x760(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnStatusEffectStart;                               // 0x770(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnStatusEffectEnd;                                 // 0x780(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMovementBlocked;                                 // 0x790(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            HijackStartEvent;                                  // 0x7A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            HijackStopEvent;                                   // 0x7B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        FrobDistance;                                      // 0x7C0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        VisibilityDistanceOverride;                        // 0x7C4(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseNavWalkingIfPreferred;                         // 0x7C8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bCanEverLeaveNavWalking;                           // 0x7C9(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1933[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_movementPredictionCertainty;                     // 0x7CC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MovementPredictionInterval;                        // 0x7D0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_movementPredictionTimer;                         // 0x7D4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lastKnownVelocity;                               // 0x7D8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_canTrustCachedTouchingGroundResult;              // 0x7E4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_cachedTouchingGroundResult;                      // 0x7E5(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_canTrustCachedIsOnNavMeshResult;                 // 0x7E6(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_cachedIsOnNavMeshResult;                         // 0x7E7(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_combatTargetingInhibitors_serverOnly;            // 0x7E8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_aggroContributors_ServerOnly;                    // 0x7F8(0x50)(Transient, NativeAccessSpecifierPrivate)
	float                                        M_calculatedAggro_ServerOnly;                      // 0x848(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_queuedLaunchVelocity;                            // 0x84C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnTeam>                  DefaultTeamClass;                                  // 0x858(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnTeamChangedEvent;                                // 0x860(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                          Faction;                                           // 0x870(0x8)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnJumpEvent;                                       // 0x878(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLandedEvent;                                     // 0x888(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLaunchedEvent;                                   // 0x898(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnWalkOffLedgeEvent;                               // 0x8A8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UQtnDamageReceptorComponent*           M_pDamageReceptor;                                 // 0x8B8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UObject*, float>                  M_attackDamageMultipliers;                         // 0x8C0(0x50)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                        R_aggregateAttackDamageMultiplier;                 // 0x910(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_remainingAITrackingImmunity;                     // 0x914(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnOutgoingDamage;                                  // 0x918(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnKilledSomething;                                 // 0x928(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         R_markedForCleanup;                                // 0x938(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         ImmuneToCleanup;                                   // 0x939(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1942[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnVerbRequest>               M_localVerbRequests;                               // 0x940(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<enum class EQtnUIBodyActionEnum>      M_verbInputsWaitingForRelease;                     // 0x950(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UQtnVerbComponent*                     M_pVerbComponent;                                  // 0x960(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnAttributeComponent*                M_pAttributeComponent;                             // 0x968(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnLootManagementComponent*           M_pLootManagementComponent;                        // 0x970(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnUnlocksComponent*                  M_pUnlocksComponent;                               // 0x978(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                          M_activeBullshitTag;                               // 0x980(0x8)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            VerbStartEvent;                                    // 0x988(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            VerbStopEvent;                                     // 0x998(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            AnimWindowBeginEvent;                              // 0x9A8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            AnimWindowEndEvent;                                // 0x9B8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            AnimNotifyEvent;                                   // 0x9C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                  PawnSocketLeftGrip;                                // 0x9D8(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  PawnSocketRightGrip;                               // 0x9E0(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  PawnSocketVision;                                  // 0x9E8(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  PawnSocketCamera;                                  // 0x9F0(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQtnDefaultTicket>             DefaultTickets;                                    // 0x9F8(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnQtnTeleport;                                     // 0xA08(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        M_teleportCountdown;                               // 0xA18(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_194C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnCarryComponent*>            M_managedCarryComponents;                          // 0xA20(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                M_pCarryingActor;                                  // 0xA30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        R_timeDilation;                                    // 0xA38(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_194E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class UObject*, struct FQtnTimeDilationInfo> M_timeDilators_ServerOnly;                         // 0xA40(0x50)(Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_194F[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AllyNameFontScale;                                 // 0xAA0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                AllyNameFontColor;                                 // 0xAA4(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MinHUDRenderingDistance;                           // 0xAA8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxHUDRenderingDistance;                           // 0xAAC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MinHUDRenderingAlpha;                              // 0xAB0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1953[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                R_HudLabel;                                        // 0xAB8(0x10)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnDamageType>            GracefulDespawnDamageType;                         // 0xAC8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AQtnPawn* GetDefaultObj();

	bool WasThirdPersonRecentlyRendered(float Recently);
	void WaitForReadyForGameplay(class AQtnPawn* Pawn, const struct FLatentActionInfo& LatentInfo, class AQtnPawn** ReadyPawn);
	void UnSetActiveBullshit(class UObject* Caller);
	float TestSlidePawnToLocation(const struct FVector& StartLocation, const struct FVector& DesiredLocation, struct FVector* OutReachedLocation);
	void TeleportQtnPawnToActor(class AActor* DestinationActor);
	void TeleportQtnPawn(struct FVector& Destination, struct FRotator& Orientation);
	void StopVerbByInstance_LocalOnly(class UQtnVerb* PVerbInstance);
	void StartVerbByClass_LocalOnly(TSubclassOf<class UQtnVerb> VerbClass, class UObject* IntendedTarget);
	class AQtnProjectile* SpawnProjectileFromPawn_ServerOnly(TSubclassOf<class AQtnProjectile> ProjectileClass, class AActor* SourceActor, class UQtnVerb* SourceVerb, const struct FVector& MuzzlePosition, const struct FVector& ProjectileVelocity, class AQtnPawn* Culprit);
	void SpawnProjectileFromPawn_LocalOnly(TSubclassOf<class AQtnProjectile> ProjectileClass, class AActor* SourceActor, class UQtnVerb* SourceVerb, const struct FVector& MuzzlePosition, const struct FVector& ProjectileVelocity);
	float SlidePawnToLocation(const struct FVector& DesiredLocation, struct FHitResult* HitResult, bool SendImpactEvents);
	bool ShouldUseNavWalking();
	void SetTeam_ServerOnly(TSubclassOf<class UQtnTeam> NewTeamClass);
	void SetPawnScale(float TargetScale);
	void SetHUDLabel_ServerOnly(class FString& HudLabel);
	void SetDisplayName(class FText NewDisplayName);
	void SetBodyToBlame(class AQtnBodyPawn* bodyPawn);
	void SetActiveBullshit(const struct FGameplayTag& ActiveBullshitTag, class UObject* Caller);
	void ServerTeleportQtnPawn(const struct FVector& Destination, const struct FRotator& Orientation);
	void ServerSpawnProjectileFromPawn(TSubclassOf<class AQtnProjectile> ProjectileClass, class AActor* SourceActor, class UQtnVerb* SourceVerb, const struct FVector& MuzzlePosition, const struct FVector& ProjectileVelocity);
	void ServerSetRootMotionSmoothMoveToDynamicLocation(const struct FVector& TargetLocation, class FName InstanceName);
	void ServerSetRootMotionInstantMoveToDynamicLocation(const struct FVector& TargetLocation, class FName InstanceName);
	void ServerSetPendingVerbAndTarget(class UQtnVerb* PPendingVerb, class UObject* PPendingVerbTarget);
	void ServerSetCharacterMovementMode(enum class EMovementMode MovementMode);
	void ServerOutgoingPlayerDamage(class UQtnDamageReceptorComponent* PDamageRecipient, const struct FQtnDamageInfo& DamageInfo);
	void ServerGenerateAINoise(class AActor* EmittingActor, enum class EQtnNoiseEnum NoiseType, float NoiseStrength);
	void ServerEndRootMotion(class FName InstanceName);
	void ServerDropOtherActor(class AActor* OtherActor, bool DestroyAfterDrop);
	void ServerBeginRootMotionSmoothMoveToDynamic(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName, float ClientTimeStamp, bool FromVerb);
	void ServerBeginRootMotionSmoothMoveTo(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName, float ClientTimeStamp, bool FromVerb);
	void ServerBeginRootMotionInstantMoveToDynamic(const struct FVector& TargetLocation, float Duration, bool OverrideVelocity, bool ZeroVelocityWhenFinished, class FName InstanceName, float ClientTimeStamp, bool FromVerb);
	void ServerBeginRootMotionImpulse(const struct FVector& Impulse, bool OverrideVelocity, class FName InstanceName, float ClientTimeStamp);
	void ServerBeginRootMotionConstantForce(const struct FVector& Direction, float Strength, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName, float ClientTimeStamp, bool FromVerb);
	void ServerAddAndRequestVerb(const struct FQtnVerbRequest& VerbRequest);
	void RequestVerb_ServerOnly(struct FQtnVerbRequest& VerbRequest, bool AddIfMissing);
	void RequestVerb_LocalOnly(struct FQtnVerbRequest& VerbRequest, bool AddIfMissing);
	void RemoveTimeDilation_ServerOnly(class UObject* TimeDilator);
	void RemoveDamageImmunity(TSubclassOf<class UQtnDamageType> DamageTypeClass);
	void RemoveCombatTargetingInhibitor_ServerOnly(class UObject* Inhibitor);
	void RemoveAttackDamageMultiplier_ServerOnly(class UObject* SourceObject);
	void RemoveAggro_ServerOnly(class UObject* AggroCauser);
	void RegisterPawnLODComponent(class UActorComponent* PActorComponent);
	void QueueLaunch(const struct FVector& LaunchVelocity);
	void QtnWalkOffLedgeSignature__DelegateSignature(class AQtnPawn* Pawn, struct FVector& PreviousFloorImpactNormal, struct FVector& PreviousFloorContactNormal, struct FVector& PreviousLocation);
	void QtnTeleportEvent__DelegateSignature(const struct FVector& OldLocation, const struct FRotator& OldRotation, const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void QtnStatusEffectEvent__DelegateSignature(class UQtnStatusEffect* StatusEffect);
	void QtnPawnVerbEvent__DelegateSignature(class UQtnVerb* Verb, bool IsServer);
	void QtnPawnTouchEvent__DelegateSignature(class AQtnPawn* SelfPawn, class AActor* OtherActor, struct FVector& TouchLocation, struct FVector& TouchNormal);
	void QtnPawnTeamChangeEvent__DelegateSignature(class UQtnTeam* OldTeam, class UQtnTeam* NewTeam);
	void QtnPawnAnimNotifyEvent__DelegateSignature(class UQtnAnimNotify* AnimNotify);
	void QtnOutgoingDamageEvent__DelegateSignature(class AActor* DamagedActor, struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo, bool IsServer);
	void QtnOnReadyForGameplayEvent__DelegateSignature(class AQtnPawn* ReadyPawn);
	void QtnOnDisplayNameChangedEvent__DelegateSignature(class FText NewDisplayName);
	void QtnMovementBlockedEvent__DelegateSignature(struct FHitResult& Impact);
	void QtnLaunchedSignature__DelegateSignature(class AQtnPawn* Pawn, struct FVector& LaunchVelocity);
	void QtnLandedSignature__DelegateSignature(class AQtnPawn* Pawn, struct FHitResult& Hit);
	void QtnKilledSomethingEvent__DelegateSignature(class AQtnPawn* Culprit, class AActor* KilledActor, bool IsServer);
	void QtnJumpSignature__DelegateSignature(class AQtnPawn* Pawn);
	void QtnAnimWindowEndEvent__DelegateSignature(class UQtnAnimWindow* AnimWindow);
	void QtnAnimWindowBeginEvent__DelegateSignature(class UQtnAnimWindow* AnimWindow, float TotalDuration);
	void OnRep_PendingVerbRequest();
	void OnRep_PawnIntentionsSimulatedProxy();
	void OnRep_HudLabel();
	void OnRep_DisplayName();
	void OnRep_CachedTeam();
	void OnQtnReadyForGameplay();
	void OnManualStartedVerbEvent(struct FQtnPawnMontage& VerbAction, float PlayRate, float StartTime);
	void OnManualFinishedVerbEvent(struct FQtnPawnMontage& VerbAction, bool JumpToOutro);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnCheatVerbRequested(const struct FQtnVerbRequest& VerbRequest);
	void OnAnimWindowEnd(class UQtnAnimWindow* AnimWindow);
	void OnAnimWindowBegin(class UQtnAnimWindow* AnimWindow, float TotalDuration);
	void OnAnimNotify(class UQtnAnimNotify* AnimNotify);
	void MulticastTeleportQtnPawn(const struct FVector& Destination, const struct FRotator& Orientation);
	void MulticastOutgoingPlayerDamage(class UQtnDamageReceptorComponent* PDamageRecipient, const struct FQtnDamageInfo& DamageInfo);
	void MulticastFX(TSubclassOf<class AQtnFXActor> FxClass);
	void MulticastDamageNonReplicatedActor(class UQtnDamageReceptorComponent* PDamageReceptor, const struct FQtnDamageInfo& DamageInfo);
	void MarkForCleanup_ServerOnly();
	void ManuallyTickVerbInstance(class UQtnVerb* PVerbInstance, float DeltaSeconds);
	void LocalSetRootMotionSmoothMoveToDynamicLocation(const struct FVector& TargetLocation, class FName InstanceName);
	void LocalSetRootMotionInstantMoveToDynamicLocation(const struct FVector& TargetLocation, class FName InstanceName);
	void LocalSetDefaultCharacterMovementMode();
	void LocalSetCharacterMovementMode(enum class EMovementMode MovementMode);
	void LocalGenerateAINoise(class AActor* EmittingActor, enum class EQtnNoiseEnum NoiseType, float NoiseStrength);
	void LocalEndRootMotion(class FName InstanceName);
	void LocalDropOtherActor(class AActor* OtherActor, bool DestroyAfterDrop);
	void LocalBeginRootMotionSmoothMoveToDynamic(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName, bool FromVerb);
	void LocalBeginRootMotionSmoothMoveTo(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName, bool FromVerb);
	void LocalBeginRootMotionInstantMoveToDynamic(const struct FVector& TargetLocation, float Duration, bool OverrideVelocity, bool ZeroVelocityWhenFinished, class FName InstanceName, bool FromVerb);
	void LocalBeginRootMotionImpulse(const struct FVector& Impulse, bool OverrideVelocity, class FName InstanceName);
	void LocalBeginRootMotionConstantForce(const struct FVector& Direction, float Strength, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName, bool FromVerb);
	bool IsTouchingGround();
	bool IsReadyForGameplay();
	bool IsPawnOnNavMesh();
	bool IsNeutral(class AActor* OtherActor);
	bool IsMarkedForCleanup();
	bool IsLocallyControlledPlayer();
	bool IsInDeepSnow();
	bool IsImmuneToAITracking();
	bool IsHitReactingOrKnockedDown();
	bool IsHero();
	bool IsEnemy(class AActor* OtherActor);
	bool IsCarrying(class AActor* OtherActor);
	bool IsAnyHitStopActive();
	bool IsAlly(class AActor* OtherActor);
	bool IsAliveAndConscious();
	void IgnoreVerbInputUntilRelease(enum class EQtnUIBodyActionEnum InputAction);
	void IgnoreOverlappingPawnsAfterTeleport(class AActor* FreshlyTeleportedActor);
	void IgnoreActorUntilOverlapEnds(class AActor* FreshlyTeleportedActor);
	bool HasTeamAttitude(class AActor* OtherActor, enum class EQtnTeamAttitude TeamAttitude);
	bool HasJustTeleported();
	bool HasDamageImmunity(TSubclassOf<class UQtnDamageType> DamageTypeClass, bool* PermanentlyImmune);
	void HandleVerbEquipChange(class UQtnVerb* AffectedVerb, bool IsEquipped, bool IsServer);
	void HandleOverlapEnd(class UPrimitiveComponent* POverlappedComponent, class AActor* POtherActor, class UPrimitiveComponent* POtherComp, int32 OtherBodyIndex);
	void HandleOverlapBegin(class UPrimitiveComponent* POverlappedComponent, class AActor* POtherActor, class UPrimitiveComponent* POtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleOutgoingDamage(class AActor* DamagedActor, struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo, bool IsServer);
	void HandleKilledSomething(class AActor* KilledActor);
	void HandleDifficultyChange_ServerOnly(enum class EQtnDifficulty NewDifficulty);
	void HandleCarryStart(class UQtnCarryComponent* CarryComponent, class AActor* CarryingActor, struct FQtnCarrySettings& CarrySettings, bool IsServer);
	void HandleCarryEnd(class UQtnCarryComponent* CarryComponent, class AActor* CarryingActor, bool IsServer);
	void HandleCapsuleHit(class UPrimitiveComponent* PHitComp, class AActor* POtherActor, class UPrimitiveComponent* POtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void GracefulDespawn();
	class UQtnVerbComponent* GetVerbComponent();
	class UQtnUnlocksComponent* GetUnlocksComponent();
	TSubclassOf<class UQtnTeam> GetTeam();
	enum class EQtnTeamAttitude GetQtnTeamAttitudeTowards(class AActor* OtherActor);
	class UQtnMovementComponent* GetQtnMovementComponent();
	class UQtnCameraComponent* GetQtnCameraComponent();
	void GetPostRenderInfo(class AQtnPlayerController* OtherPlayerController, bool* SkipThisFrame, class FString* HudLabel, struct FColor* FontColor);
	float GetPawnVisibilityRatioBP(struct FLinearColor* VisibilityColor);
	float GetPawnScale();
	enum class EQtnPawnLOD GetPawnLOD();
	struct FVector GetPawnHeadLocation();
	struct FVector GetPawnGravity();
	struct FVector GetPawnForwardVectorAlongGround();
	struct FVector GetPawnFeetLocation();
	struct FVector GetPawnCapsuleTop();
	class AQtnSpawner* GetOwningSpawner();
	TArray<class AQtnPawn*> GetOverlappingPawns();
	TArray<class AActor*> GetOverlappingNonPawns();
	struct FRotator GetOriginalRelativeMeshRotation();
	struct FVector GetOriginalRelativeMeshLocation();
	class AQtnPlayerUI* GetOccupyingPlayerUI();
	class AQtnPlayerController* GetOccupyingLocalPlayerController();
	TArray<class UQtnCarryComponent*> GetManagedCarryComponents();
	class UQtnLootManagementComponent* GetLootManagementComponent();
	struct FQtnPawnIntentions GetIntentions();
	void GetIntendedEquippedWeapons(class AQtnItem** RangedWeapon, class AQtnItem** MeleeWeapon);
	class AQtnItem* GetIntendedEquippedWeapon(bool Ranged);
	void GetHealth(float* Health, float* MaxHealth);
	struct FGameplayTag GetFaction();
	class UQtnVerb* GetExistingVerb(TSubclassOf<class UQtnVerb> VerbClass);
	TArray<class UQtnHintVolumeComponent*> GetEncompassingDeepSnowVolumes();
	class FText GetDisplayName();
	class UQtnDamageReceptorComponent* GetDamageReceptor();
	class UQtnVerb* GetCurrentActiveVerb();
	class AQtnPlayerPawn* GetControllingPlayerPawn();
	class AActor* GetCarryingActor();
	class UQtnCarryComponent* GetCarryComponent();
	class AQtnBodyPawn* GetBodyToBlame();
	class UQtnAttributeComponent* GetAttributeComponent();
	float GetAttackDamageMultiplier();
	void GetAllEquippedVerbs(TArray<class UQtnVerb*>* PawnVerbs);
	void DropAllCarriedPawns_ServerOnly();
	void DoHitStop(struct FQtnHitStopRequest& HitStopRequest);
	void DoForceFeedbackCameraShakeIfLocalPlayer(class UForceFeedbackEffect* ForceFeedbackEffect, TSubclassOf<class UCameraShakeBase> CameraShake, float CameraShakeScale);
	void ClientSetAutonomousProxyIntentions(const struct FQtnPawnIntentions& Intentions);
	void ClientRequestVerb(const struct FQtnVerbRequest& VerbRequest);
	class UQtnVerb* ChooseBestVerb(enum class EQtnUIBodyActionEnum bodyActionEnum, class UObject* IntendedTarget);
	class UQtnVerb* ChooseBestAttackVerb(class UObject* IntendedTarget);
	bool CanBeTargetedForCombat_ServerOnly(class AQtnPawn* OtherPawn);
	void ApplyPawnDamage(struct FQtnDamageInfo& DamageInfo);
	float ApplyKnockback(class AQtnPawn* Culprit, struct FVector& SourceLocation, float HorizontalDistance, float ApexHeight, float AimAssistDegrees);
	void AdjustLocationForGeo();
	void AddTimeDilation_ServerOnly(class UObject* TimeDilator, float TimeDilation, float DurationBeforeDecay, float DecayDuration);
	void AddDamageImmunity(TSubclassOf<class UQtnDamageType> DamageTypeClass);
	void AddCombatTargetingInhibitor_ServerOnly(class UObject* Inhibitor);
	void AddAttackDamageMultiplier_ServerOnly(class UObject* SourceObject, float Multiplier);
	void AddAggro_ServerOnly(class UObject* AggroCauser, float AggroContribution);
};

// 0x700 (0x11D0 - 0xAD0)
// Class QtnGame.QtnBodyPawn
class AQtnBodyPawn : public AQtnPawn
{
public:
	uint8                                        Pad_1A44[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnCloudOptionsSaveData*              M_pCachedCloudOptionsSaveData;                     // 0xAD8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_bIsHeroArchetype;                                // 0xAE0(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_bIsBossArchetype;                                // 0xAE1(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A45[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  FootSocketLeft;                                    // 0xAE4(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  FootSocketRight;                                   // 0xAEC(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                          M_pawnTag;                                         // 0xAF4(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         WantsSpawnAnimation;                               // 0xAFC(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A46[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnHintVolumeComponent*               M_pFloodControlHint;                               // 0xB00(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lookInterpolationRatio;                          // 0xB08(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       LODNeglectDistance;                                // 0xB0C(0x8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         M_hasBeenCheckedForRelevance;                      // 0xB14(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A48[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FDataTableRowHandle                   EntityRPGData;                                     // 0xB18(0x10)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FQtnAIDebugInfo                       R_aiDebugInfo;                                     // 0xB28(0x28)(Net, Transient, NativeAccessSpecifierPublic)
	struct FQtnAIClientInfo                      R_aiClientInfo;                                    // 0xB50(0x1)(Net, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A4A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnAICombatBegin_ServerOnly;                        // 0xB58(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AQtnBodyController*                    M_pPossessingController;                           // 0xB68(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        R_pOccupyingPlayerPawn;                            // 0xB70(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        L_pOccupyingPlayerPawn;                            // 0xB78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        M_pOccupyEventPawn;                                // 0xB80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_databagOccupyHappened;                           // 0xB88(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A4E[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            BodyPawnOccupiedEvent;                             // 0xB90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            BodyPawnUnOccupiedEvent;                           // 0xBA0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UQtnBodyAnimGraphTP*                   M_charAnimInstanceTP;                              // 0xBB0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace1D*                LeanBlendFP;                                       // 0xBB8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           SwimLocoBlendFP;                                   // 0xBC0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace1D*                SwimAimBlendFP;                                    // 0xBC8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         LeftArmEquippedPoseFP;                             // 0xBD0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace1D*                LeftArmAimBlendFP;                                 // 0xBD8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         RightArmEquippedPoseFP;                            // 0xBE0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace1D*                RightArmAimBlendFP;                                // 0xBE8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace1D*                LeanBlendTP;                                       // 0xBF0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                  UpperBodyAimBlendTP;                               // 0xBF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           HeadAimBlendTP;                                    // 0xC00(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A51[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UBlendSpace*                           LocoBlendPerBodyStance[0x5];                       // 0xC58(0x28)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           LeftArmAimBlendTP;                                 // 0xC80(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         LeftArmEquippedPoseTP;                             // 0xC88(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           RightArmAimBlendTP;                                // 0xC90(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         RightArmEquippedPoseTP;                            // 0xC98(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         JumpIntroTP;                                       // 0xCA0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         JumpLoopTP;                                        // 0xCA8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                         JumpOutroTP;                                       // 0xCB0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A54[0x90];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_bUpdateFootstepTracer;                           // 0xD48(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A55[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  SoundParam_Name_FootstepSurface;                   // 0xD4C(0x8)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  SoundParam_Float_FootstepLoudness;                 // 0xD54(0x8)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  SoundParam_Name_FootstepCharacter;                 // 0xD5C(0x8)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  FootstepCharacterSwitchValue;                      // 0xD64(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A57[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            FootstepEvent;                                     // 0xD70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAudioComponent*                       FootstepAudioComponent;                            // 0xD80(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                       SlideAudioComponent;                               // 0xD88(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                    SlideVolumeBySpeedCurve;                           // 0xD90(0x88)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                        M_timeOfLastAIFootstepNoise;                       // 0xE18(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lastFootstepNoiseLoudness;                       // 0xE1C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lastFootstepAudioLoudness;                       // 0xE20(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  SoundParam_Bool_Crouch;                            // 0xE24(0x8)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A5C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  KOedNotDiscoveredInfo;                             // 0xE30(0x18)(Edit, NativeAccessSpecifierPrivate)
	class FText                                  KOedDiscoveredInfo;                                // 0xE48(0x18)(Edit, NativeAccessSpecifierPrivate)
	enum class EQtnBodyAliveness                 R_bodyAliveness;                                   // 0xE60(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnBodyAliveness                 L_bodyAliveness;                                   // 0xE61(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A5D[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                R_pBodyAlivenessInstigator;                        // 0xE68(0x8)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnFullBodyState>> FullBodyStates;                                    // 0xE70(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnUpperBodyState>> UpperBodyStates;                                   // 0xE80(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UQtnFullBodyFSM*                       M_pFullBodyFSM;                                    // 0xE90(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyFSM*                      M_pUpperBodyFSM;                                   // 0xE98(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateLocomotion*           M_pFullLocomotionState;                            // 0xEA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateAction*               M_pFullActionState;                                // 0xEA8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateVerb*                 M_pFullVerbState;                                  // 0xEB0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateHitReaction*          M_pFullHitReactionState;                           // 0xEB8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateJumpFall*             M_pFullJumpFallState;                              // 0xEC0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateMantle*               M_pFullMantleState;                                // 0xEC8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateEngaged*              M_pFullEngagedState;                               // 0xED0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateDead*                 M_pFullDeadState;                                  // 0xED8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFullBodyStateKnockedDown*          M_pFullKnockedDownState;                           // 0xEE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateReady*               M_pUpperReadyState;                                // 0xEE8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateEquipping*           M_pUpperEquippingState;                            // 0xEF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateAction*              M_pUpperActionState;                               // 0xEF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateVerb*                M_pUpperVerbState;                                 // 0xF00(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateFrobbing*            M_pUpperFrobbingState;                             // 0xF08(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateIndisposed*          M_pUpperIndisposedState;                           // 0xF10(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnUpperBodyStateClimbing*            M_pUpperClimbingState;                             // 0xF18(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshSocket*                   M_pSkeletalVisionSocket;                           // 0xF20(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnCarryComponent*                    BodyCarryComponent;                                // 0xF28(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ForceOnscreenNPCPawnLOD;                           // 0xF30(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A63[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            BodyAliveChangeEvent;                              // 0xF38(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UQtnPerkComponent*                     CharacterPerkComponent;                            // 0xF48(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnUpgradeComponent*                  CharacterUpgradeComponent;                         // 0xF50(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQtnTagPresence>               DescriptiveTags;                                   // 0xF58(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnUpgradeSlotConfiguration>  BodyUpgradeSlots;                                  // 0xF68(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UQtnUpgradeSlot*>               R_UpgradeSlots;                                    // 0xF78(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        M_pHijackingPlayerPawn;                            // 0xF88(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_asyncLeftHandWallDetected;                       // 0xF90(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_asyncRightHandWallDetected;                      // 0xF91(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_asyncLeanWallDetected;                           // 0xF92(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A64[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_remainingJumpInputBuffer;                        // 0xF94(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A66[0x30];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_jumpInhibitors_serveronly;                       // 0xFC8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                         R_isJumpInhibited;                                 // 0xFD8(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A67[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnInventoryComponent*                M_pBodyInventory;                                  // 0xFE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              R_pActualEquippedRangedWeapon;                     // 0xFE8(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnItem*                              R_pActualEquippedMeleeWeapon;                      // 0xFF0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnItem*                              M_pHiddenRangedWeaponToRestore;                    // 0xFF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnItem*                              M_pHiddenMeleeWeaponToRestore;                     // 0x1000(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                       M_EmptyHandsRequests;                              // 0x1008(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemEquipEvent;                                  // 0x1018(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemUnEquipEvent;                                // 0x1028(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FQtnBodyRotationLockInfo              M_bodyRotationLockInfo;                            // 0x1038(0x40)(Transient, NativeAccessSpecifierPrivate)
	float                                        M_standingHeight;                                  // 0x1078(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_crouchHeight;                                    // 0x107C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lastRepulsionInput;                              // 0x1080(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnMantleConfig                      MantleConfig;                                      // 0x108C(0x18)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        LandingRecoveryMinDuration;                        // 0x10A4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RepulsionScale;                                    // 0x10A8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BaseLocomotionSpeed;                               // 0x10AC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorComponent*          M_pCurrentlyEngagedFrobAccumulator;                // 0x10B0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_remainingKnockdownTime;                          // 0x10B8(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A69[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFrobbableComponent*                R_pCurrentEngagementTarget;                        // 0x10C0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_mantleSpeedMultiplier;                           // 0x10C8(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A6A[0x14];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            BodyPawnVisibilityChangedEvent;                    // 0x10E0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UObject*>                       M_localBodyHiders;                                 // 0x10F0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FQtnAIBodyAppearance>          M_AIBodyAppearances;                               // 0x1100(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>        M_customizationMeshes;                             // 0x1110(0x10)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UQtnCharacterAppearanceComponent*      M_BodyAppearanceComponent;                         // 0x1120(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                M_pLastMantleWallActor;                            // 0x1128(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                   M_pLastMantleWallComponent;                        // 0x1130(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                M_pLastMantleCeilingActor;                         // 0x1138(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                   M_pLastMantleCeilingComponent;                     // 0x1140(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                M_pLastMantleDepthActor;                           // 0x1148(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                   M_pLastMantleDepthComponent;                       // 0x1150(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UObject*, struct FLinearColor>    M_persistentLightingColors;                        // 0x1158(0x50)(Transient, NativeAccessSpecifierPrivate)
	float                                        StealthBonusWhenCrouching;                         // 0x11A8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                          M_corpseVisibilityColor;                           // 0x11AC(0x10)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bShouldEverUpdateSlideAudio;                       // 0x11BC(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bCanEverUseHeadAim;                                // 0x11BD(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A6B[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  AggregationKey;                                    // 0x11C0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        RoundRobinBucketSize;                              // 0x11C8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bInfiniteRage;                                     // 0x11CC(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bInfiniteSprint;                                   // 0x11CD(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1A6C[0x2];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnBodyPawn* GetDefaultObj();

	void UpdateAppearance();
	void UnlockBodyYaw(class UObject* RequestingObject);
	void SetMantleSpeedMultiplier_ServerOnly(float DesiredMultiplier);
	void SetLocoBlendOverride(class UObject* OverridingObject, class UBlendSpace* LocoBlendOverride, enum class EQtnLocoOverridePriority Priority);
	void SetLockedBodyYaw(float WorldYaw);
	void SetAimPitchBlend(class UBlendSpace1D* AimPitchBlend1D);
	void ServerSetScriptedAction(const struct FQtnActionIntention& ActionIntention);
	void ServerSetBodyAliveness(enum class EQtnBodyAliveness bodyAliveness, class AActor* AlivenessInstigator);
	void ServerRequestScriptedVOForThisPlayer(class AActor* PSpeaker, const struct FGameplayTag& ScriptedId, bool PreferToPlayOnBody, int32 PrescribedVariant, int32 PriorityOverride);
	void ServerRequestMantle(const struct FVector& MantleDirection, const struct FVector& LedgePoint, const struct FVector& TargetPoint, const struct FVector& StartingLocation, bool Vault);
	void ServerRequestJump(bool CanMantle, bool IntentionalJump, float TopZ, bool AirControl);
	void ServerRequestItemUse(class AQtnItem* PItem, class AActor* PIntendedTarget, bool AltUse, enum class EQtnItemUseIntent UseIntent);
	void ServerRequestFrob(class UQtnFrobbableComponent* PFrobTarget);
	void ServerPushScriptedAction(const struct FQtnActionIntention& NonLoopingActionIntention);
	void ServerMarkDataBagOccupy();
	void ServerFinishCurrentFullBodyState();
	void ServerDisengageFrob();
	void ServerCancelScriptedAction();
	void ServerBodyUnOccupy(class AQtnPlayerPawn* POccupyingPlayer);
	void RemoveStatusEffect_ServerOnly(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	void RemoveJumpInhibitor_ServerOnly(class UObject* JumpInhibitor);
	void RemoveEmptyHandsInducer(class UObject* Culprit);
	void QtnItemEquipEvent__DelegateSignature(class AQtnItem* Item);
	void QtnBodyPawnFootstepEvent__DelegateSignature(enum class EPhysicalSurface PhysicalSurface, struct FVector& ImpactLocation, struct FVector& ImpactNormal, float FootstepLoudness);
	void QtnBodyAliveChangeEvent__DelegateSignature(class AQtnBodyPawn* bodyPawn, class AActor* AlivenessInstigator, enum class EQtnBodyAliveness OldBodyAliveness, enum class EQtnBodyAliveness bodyAliveness, bool IsServer);
	void QtnAICombatBeginEvent__DelegateSignature(class AQtnBodyPawn* AiBody);
	class UAudioComponent* PlaySound(class USoundBase* Sound, bool Spatialize);
	void OnStanceChanged();
	void OnRep_OccupyingPlayerPawn();
	void OnRep_BodyAliveness();
	void OnBodyPawnUnOccupied(class AQtnPlayerPawn* OccupyingPlayerPawn);
	void OnBodyPawnOccupied(class AQtnPlayerPawn* OccupyingPlayerPawn);
	void OnAIBodyAppearanceUpdated();
	void MulticastRequestMantle(const struct FVector& MantleDirection, const struct FVector& LedgePoint, const struct FVector& TargetPoint, const struct FVector& StartingLocation, bool Vault);
	void MulticastRequestJump(bool CanMantle, bool IntentionalJump, float TopZ, bool AirControl);
	void MulticastRequestItemUse(class AQtnItem* PItem, class AActor* PIntendedTarget, bool AltUse, enum class EQtnItemUseIntent UseIntent);
	void MulticastRequestFrob(class UQtnFrobbableComponent* PFrobTarget);
	void MulticastPushScriptedAction(const struct FQtnActionIntention& ActionIntention);
	void MulticastFinishCurrentFullBodyState();
	void MulticastDisengageFrob();
	void LockBodyYaw(class UObject* RequestingObject);
	void LocalSetScriptedAction(struct FQtnActionIntention& ActionIntention);
	void LocalSetMeleeWeaponVisible();
	void LocalSetBodyHidden(bool Hidden, class UObject* bodyHider);
	void LocalRequestDodge();
	void LocalPushScriptedAction(struct FQtnActionIntention& NonLoopingActionIntention);
	void LocalCancelScriptedAction();
	bool IsTryingToJump();
	bool IsOccupiedByPlayer();
	bool IsKnockedDown();
	bool IsJumpInhibited();
	bool IsHitReacting();
	bool IsDoingScriptedAction(bool* FullBody);
	bool IsDoingQueuedAction();
	bool IsDead(bool* CanBeRevived);
	bool IsBoss();
	bool IsBodyIdle(bool RequireStandingStill);
	bool IsAirborne(bool IncludeVerbs);
	void InduceEmptyHands(bool WantEmptyHands);
	bool HasUpgrade(TSubclassOf<class UQtnUpgrade> UpgradeClass, bool UseInheritance);
	bool HasStatusEffect(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	void HandleLandFootstep(class AQtnPawn* TargetPawn, struct FHitResult& HitResult);
	void HandleInventoryItemRemoved(class AQtnItem* PRemovedItem);
	TArray<class UQtnUpgradeSlot*> GetUpgradeSlots();
	class UQtnStatusEffect* GetStatusEffect(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	class AActor* GetStartActor_ServerOnly();
	class AQtnPlayerState* GetOccupyingPlayerState();
	class AQtnPlayerPawn* GetOccupyingPlayerPawn();
	TArray<class AQtnBodyPawn*> GetNearbyFriendBodies();
	void GetLocoThrottleAndDirection(float* LocoThrottle, float* LocoDirectionDegrees);
	class AQtnPlayerPawn* GetHijackingPlayerPawn();
	class AQtnBodyPawn* GetHijackingBodyPawn();
	class UQtnUpperBodyState* GetExistingUpperBodyState(TSubclassOf<class UQtnUpperBodyState> UpperBodyStateClass);
	class UQtnFullBodyState* GetExistingFullBodyState(TSubclassOf<class UQtnFullBodyState> FullBodyStateClass);
	struct FQtnEntityTuningDataRow GetEntityTuningData();
	class UQtnUpperBodyState* GetCurrentUpperBodyState();
	TArray<class UQtnUpgrade*> GetCurrentUpgradesArray();
	int32 GetCurrentUpgrades(TArray<class UQtnUpgrade*>& CurrentUpgrades);
	class AActor* GetCurrentlyTargetedActor(bool IncludePerceptionResults);
	class UQtnFrobbableComponent* GetCurrentlyFrobbedObject();
	class UQtnFullBodyState* GetCurrentFullBodyState();
	class UQtnInventoryComponent* GetBodyInventory();
	struct FVector GetBodyIntentionWorldMovement();
	struct FVector GetBodyIntentionLocalMovement();
	class AQtnBodyController* GetBodyController();
	class UQtnCharacterAppearanceComponent* GetBodyAppearanceComponent();
	class AActor* GetBodyAlivenessInstigator();
	enum class EQtnBodyAliveness GetBodyAliveness();
	TArray<class UQtnStatusEffect*> GetAllStatusEffects();
	TArray<struct FQtnTagPresence> GetAllBodyTagDescriptions(TArray<struct FQtnTagPresence>& TagDescriptions);
	void GetAllBodyPawns(class UObject* SelfReference, TArray<class AQtnBodyPawn*>* FoundBodyPawns, class FName ActorTagFilter, class FName SpawnerRegionFilter);
	class AQtnItem* GetActualEquippedItem(bool Ranged);
	class UQtnUpgradeSlot* FindUpgrade(TSubclassOf<class UQtnUpgrade> UpgradeClass, bool UseInheritance);
	void DisengageFrob();
	void ClientRequestJump(bool CanMantle, bool IntentionalJump, float TopZ, bool AirControl);
	bool CanSeeThisActor(class AActor* ActorToCheck, float VisionConeDistance, float VisionConeYawDegrees, float VisionConePitchDegrees);
	bool CanBeRevived(class AQtnPawn* OtherPawn);
	bool AreHandsEmpty();
	class UQtnStatusEffect* AddStatusEffect_ServerOnly(TSubclassOf<class UQtnStatusEffect> StatusEffectClass, class AQtnPawn* StatusInstigator);
	void AddJumpInhibitor_ServerOnly(class UObject* JumpInhibitor);
	void AddEmptyHandsInducer(class UObject* Culprit);
};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnFSMState
class UQtnFSMState : public UObject
{
public:
	bool                                         M_isStateActive;                                   // 0x28(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1A83[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFSMState* GetDefaultObj();

	bool IsStateActive();
};

// 0x80 (0xB0 - 0x30)
// Class QtnGame.QtnBodyState
class UQtnBodyState : public UQtnFSMState
{
public:
	class AQtnBodyPawn*                          M_pOwningPawn;                                     // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQtnAnimWindow*>                M_pendingAnimWindows;                              // 0x38(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                         M_hasTickedAtLeastOnceSinceEntering;               // 0x48(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1AA9[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            EnterBodyStateEvent;                               // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            TickBodyStateEvent;                                // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ExitBodyStateEvent;                                // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            AnimWindowBeginEvent;                              // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            AnimWindowEndEvent;                                // 0x90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            AnimNotifyEvent;                                   // 0xA0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnBodyState* GetDefaultObj();

	void QtnTickBodyStateEvent__DelegateSignature(class UQtnBodyState* SelfBodyState, float DeltaSeconds);
	void QtnExitBodyStateEvent__DelegateSignature(class UQtnBodyState* SelfBodyState, TSubclassOf<class UQtnBodyState> NextBodyStateClass);
	void QtnEnterBodyStateEvent__DelegateSignature(class UQtnBodyState* SelfBodyState, class UQtnBodyState* PreviousBodyState);
	void QtnBodyStateAnimNotifyEvent__DelegateSignature(class UQtnAnimNotify* AnimNotify);
	void QtnAnimWindowEndEvent__DelegateSignature(class UQtnAnimWindow* AnimWindow, bool Interrupted);
	void QtnAnimWindowBeginEvent__DelegateSignature(class UQtnAnimWindow* AnimWindow, float TotalDuration);
	void OnTickBodyState(float DeltaSeconds);
	void OnInitBodyState();
	void OnExitBodyState(TSubclassOf<class UQtnBodyState> NextBodyStateClass);
	void OnEnterBodyState(class UQtnBodyState* PreviousBodyState);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnAnimWindowEnd(class UQtnAnimWindow* AnimWindow, bool Interrupted);
	void OnAnimWindowBegin(class UQtnAnimWindow* AnimWindow, float TotalDuration);
	void OnAnimNotify(class UQtnAnimNotify* AnimNotify);
	class AQtnBodyPawn* GetOwningPawn();
};

// 0x10 (0x260 - 0x250)
// Class QtnGame.QtnBPActor
class AQtnBPActor : public AActor
{
public:
	TArray<TSoftObjectPtr<class AActor>>         LinkedActors;                                      // 0x250(0x10)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnBPActor* GetDefaultObj();

	void OnEditorSelected(bool IsSelected);
	void OnEditorPropertyChange(class FName PropertyName);
	void OnEditorLinkedActorDeleted(class AActor* LinkedActor);
	void OnEditorCheckForErrors();
	void OnEditorActorMoved(bool Finished);
};

// 0x0 (0xE0 - 0xE0)
// Class QtnGame.QtnBPActorProxyComponent
class UQtnBPActorProxyComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnBPActorProxyComponent* GetDefaultObj();

};

// 0x1A8 (0x288 - 0xE0)
// Class QtnGame.QtnBreadCrumbComponent
class UQtnBreadCrumbComponent : public UActorComponent
{
public:
	float                                        MaxCornerDistance;                                 // 0xE0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_maxCornerDistSq;                                 // 0xE4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        HeightOffset;                                      // 0xE8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1ACC[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnGameState*                         M_pCachedGameState;                                // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pOwningActor;                                    // 0xF8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_implementsNavHelperInterface;                    // 0x100(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1ACD[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          M_pTrackedLocalPlayerBody;                         // 0x108(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_currentPlayerLocation;                           // 0x110(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_currentDestination;                              // 0x11C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_projectionBounds;                                // 0x128(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_suggestedWaypoint;                               // 0x134(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isAtDestination;                                 // 0x140(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needsRefresh;                                    // 0x141(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_repathSuggested;                                 // 0x142(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isCurrentResultReliable;                         // 0x143(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AD0[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnNavigationSystem*                  M_pNavSys;                                         // 0x148(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavigationPath*                       M_pLastGoodPathResult;                             // 0x150(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AD2[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	uint32                                       M_asyncQueryID;                                    // 0x168(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_trackIsPending;                                  // 0x16C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AD3[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnPathBuilt;                                       // 0x170(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        MaxSearchNodes;                                    // 0x180(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         LockToDestination;                                 // 0x184(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1AD6[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnOnScreen_Texture                  OnScreen_Indicator;                                // 0x188(0x28)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnOffScreen_Texture                 OffScreen_Indicator;                               // 0x1B0(0x20)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnIndicatorType                     IndicatorType;                                     // 0x1D0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnEffects                           Indicator_Effects;                                 // 0x1D8(0xB0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnBreadCrumbComponent* GetDefaultObj();

	void StopLocalPlayerTracking();
	bool StartLocalPlayerTracking();
	void QtnOnPathBuiltEvent__DelegateSignature(bool IsCurrentResultReliable);
	bool IsAtDestination();
	void HandleLocalPlayerTeleport(const struct FVector& OldLocation, const struct FRotator& OldRotation, const struct FVector& NewLocation, const struct FRotator& NewRotation);
	struct FVector GetSuggestedWaypoint(bool* IsCurrentResultReliable, bool* IsAtDestination);
	void GetPathResult(class UNavigationPath** LastGoodResult, bool* IsCurrentResultReliable);
};

// 0x0 (0x68 - 0x68)
// Class QtnGame.QtnBTDecorator
class UQtnBTDecorator : public UBTDecorator
{
public:

	static class UClass* StaticClass();
	static class UQtnBTDecorator* GetDefaultObj();

};

// 0x30 (0x98 - 0x68)
// Class QtnGame.QtnBTDecoratorCompareBool
class UQtnBTDecoratorCompareBool : public UQtnBTDecorator
{
public:
	struct FBlackboardKeySelector                BoolKey;                                           // 0x68(0x28)(Edit, NativeAccessSpecifierPrivate)
	bool                                         ContinueIf;                                        // 0x90(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AE0[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTDecoratorCompareBool* GetDefaultObj();

};

// 0x8 (0x70 - 0x68)
// Class QtnGame.QtnBTDecoratorEnemyPerceived
class UQtnBTDecoratorEnemyPerceived : public UQtnBTDecorator
{
public:
	float                                        AcceptableAbsenceDuration;                         // 0x68(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         VisualPerceptionOnly;                              // 0x6C(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AE2[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTDecoratorEnemyPerceived* GetDefaultObj();

};

// 0x0 (0x68 - 0x68)
// Class QtnGame.QtnBTDecoratorInterestedInHiding
class UQtnBTDecoratorInterestedInHiding : public UQtnBTDecorator
{
public:

	static class UClass* StaticClass();
	static class UQtnBTDecoratorInterestedInHiding* GetDefaultObj();

};

// 0x0 (0x68 - 0x68)
// Class QtnGame.QtnBTDecoratorInterestedInSniping
class UQtnBTDecoratorInterestedInSniping : public UQtnBTDecorator
{
public:

	static class UClass* StaticClass();
	static class UQtnBTDecoratorInterestedInSniping* GetDefaultObj();

};

// 0x10 (0x80 - 0x70)
// Class QtnGame.QtnBTTask
class UQtnBTTask : public UBTTaskNode
{
public:
	uint8                                        Pad_1AE4[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTTask* GetDefaultObj();

};

// 0x0 (0x80 - 0x80)
// Class QtnGame.QtnBTTaskBP
class UQtnBTTaskBP : public UQtnBTTask
{
public:

	static class UClass* StaticClass();
	static class UQtnBTTaskBP* GetDefaultObj();

	void TickBPTask(class AQtnBodyController* bodyController, class UBlackboardComponent* BlackboardComponent, float DeltaSeconds, float ElapsedTime);
	void StartBPTask(class AQtnBodyController* bodyController, class UBlackboardComponent* BlackboardComponent);
	bool IsBPTaskFinished(class AQtnBodyController* bodyController, class UBlackboardComponent* BlackboardComponent, float ElapsedTime, bool* Success);
	class FString GetDescription();
	void EndBPTask(class AQtnBodyController* bodyController, class UBlackboardComponent* BlackboardComponent, bool Success);
};

// 0x8 (0x88 - 0x80)
// Class QtnGame.QtnBTTaskEnableAttacks
class UQtnBTTaskEnableAttacks : public UQtnBTTask
{
public:
	bool                                         WantAttacksEnabled;                                // 0x80(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AF9[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTTaskEnableAttacks* GetDefaultObj();

};

// 0x38 (0xB8 - 0x80)
// Class QtnGame.QtnBTTaskFrob
class UQtnBTTaskFrob : public UQtnBTTask
{
public:
	struct FBlackboardKeySelector                FrobTargetKey;                                     // 0x80(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomDuration;                                    // 0xA8(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SecondsBeforeGivingUp;                             // 0xB0(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnBTTaskFrob* GetDefaultObj();

};

// 0x8 (0x88 - 0x80)
// Class QtnGame.QtnBTTaskInduceEmptyHands
class UQtnBTTaskInduceEmptyHands : public UQtnBTTask
{
public:
	bool                                         WantEmptyHands;                                    // 0x80(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AFC[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTTaskInduceEmptyHands* GetDefaultObj();

};

// 0x40 (0xC0 - 0x80)
// Class QtnGame.QtnBTTaskMoveTo
class UQtnBTTaskMoveTo : public UQtnBTTask
{
public:
	struct FBlackboardKeySelector                DestinationKey;                                    // 0x80(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomDuration;                                    // 0xA8(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         MoveWithinAttackRange;                             // 0xB0(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AFD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector2D                             Leeway;                                            // 0xB4(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1AFE[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTTaskMoveTo* GetDefaultObj();

};

// 0x80 (0x100 - 0x80)
// Class QtnGame.QtnBTTaskPawnAction
class UQtnBTTaskPawnAction : public UQtnBTTask
{
public:
	struct FQtnPawnMontage                       PawnAction;                                        // 0x80(0x10)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                TargetActorKey;                                    // 0x90(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                LookFocusActorKey;                                 // 0xB8(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomStartTime;                                   // 0xE0(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomPlayRate;                                    // 0xE8(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomDuration;                                    // 0xF0(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SecondsBeforeGivingUp;                             // 0xF8(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnBTTaskPawnAction* GetDefaultObj();

};

// 0x0 (0x80 - 0x80)
// Class QtnGame.QtnBTTaskQuitJob
class UQtnBTTaskQuitJob : public UQtnBTTask
{
public:

	static class UClass* StaticClass();
	static class UQtnBTTaskQuitJob* GetDefaultObj();

};

// 0x60 (0xE0 - 0x80)
// Class QtnGame.QtnBTTaskRequestVerb
class UQtnBTTaskRequestVerb : public UQtnBTTask
{
public:
	TSubclassOf<class UQtnVerb>                  VerbClass;                                         // 0x80(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                VerbArchetypeKey;                                  // 0x88(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                VerbTargetKey;                                     // 0xB0(0x28)(Edit, NativeAccessSpecifierPrivate)
	bool                                         AddVerbOnDemand;                                   // 0xD8(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         RemoveOtherAddedVerbs;                             // 0xD9(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B0B[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SecondsBeforeGivingUp;                             // 0xDC(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnBTTaskRequestVerb* GetDefaultObj();

};

// 0x98 (0x118 - 0x80)
// Class QtnGame.QtnBTTaskSetTether
class UQtnBTTaskSetTether : public UQtnBTTask
{
public:
	TArray<struct FBlackboardKeySelector>        TetherKeys;                                        // 0x80(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                InnerRadiusKey;                                    // 0x90(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                OuterRadiusKey;                                    // 0xB8(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       TetherRadii;                                       // 0xE0(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                VerticalRatioKey;                                  // 0xE8(0x28)(Edit, NativeAccessSpecifierPrivate)
	float                                        TetherVerticalRatio;                               // 0x110(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B10[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnBTTaskSetTether* GetDefaultObj();

};

// 0x38 (0xB8 - 0x80)
// Class QtnGame.QtnBTTaskWaitForVerb
class UQtnBTTaskWaitForVerb : public UQtnBTTask
{
public:
	TSubclassOf<class UQtnVerb>                  VerbClass;                                         // 0x80(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                VerbArchetypeKey;                                  // 0x88(0x28)(Edit, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SecondsBeforeGivingUp;                             // 0xB0(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnBTTaskWaitForVerb* GetDefaultObj();

};

// 0x80 (0xA8 - 0x28)
// Class QtnGame.QtnBullshit
class UQtnBullshit : public UObject
{
public:
	uint8                                        Pad_1B22[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnBullshitManagerComponent*          R_pOwningBullshitManager;                          // 0x38(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnBullshitManagerComponent*          L_pOwningBullshitManager;                          // 0x40(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              R_pCulprit;                                        // 0x48(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x50(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                  FriendlyName;                                      // 0x78(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0x90(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnBullshit* GetDefaultObj();

	void OnRep_OwningBullshitManager();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnBullshitTick(float DeltaSeconds);
	void OnBullshitStop();
	void OnBullshitStart();
	void OnBullshitLocalInit(class UQtnBullshitManagerComponent* OwningBullshitManager);
	bool IsServer();
	class UWorld* GetWorld();
	class UQtnBullshitManagerComponent* GetOwningBullshitManager();
	class UTexture2D* GetIconForUI();
	class AQtnPawn* GetCulprit();
	class UQtnBullshit* GetBullshitArchetype(TSubclassOf<class UQtnBullshit> bullshitClass);
	void FinishBullshit_ServerOnly();
};

// 0x70 (0x150 - 0xE0)
// Class QtnGame.QtnBullshitManagerComponent
class UQtnBullshitManagerComponent : public UActorComponent
{
public:
	uint8                                        Pad_1B34[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnBullshit*>                  R_bullshitInstances;                               // 0xE8(0x10)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnBullshit*>                  L_bullshitInstances;                               // 0xF8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_checkForBullshitDeltasPending;                   // 0x108(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B36[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnBullshit*>                  M_lastStartedBullshit;                             // 0x110(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnBullshit*>                  M_lastStoppedBullshit;                             // 0x120(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            BullshitStartEvent;                                // 0x130(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            BullshitStopEvent;                                 // 0x140(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnBullshitManagerComponent* GetDefaultObj();

	void RemoveBullshit_ServerOnly(TSubclassOf<class UQtnBullshit> bullshitClass, class AQtnPawn* Culprit);
	void QtnBullshitEvent__DelegateSignature(TArray<class UQtnBullshit*>& bullshitArray);
	void OnRep_BullshitInstances();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsBullshitActive(TSubclassOf<class UQtnBullshit> bullshitClass, class AQtnPawn* Culprit);
	class UQtnBullshitManagerComponent* GetBullshitManager(class UObject* WorldContextObject);
	TArray<class UQtnBullshit*> GetAllActiveBullshits();
	class UQtnBullshit* GetActiveBullshit(TSubclassOf<class UQtnBullshit> bullshitClass, class AQtnPawn* Culprit);
	class UQtnBullshit* AddBullshit_ServerOnly(TSubclassOf<class UQtnBullshit> bullshitClass, class AQtnPawn* Culprit);
};

// 0xC8 (0xF0 - 0x28)
// Class QtnGame.QtnCameraBehavior
class UQtnCameraBehavior : public UObject
{
public:
	class UQtnCameraComponent*                   M_pOwningCameraComponent;                          // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPawn*                              M_pOwningPawn;                                     // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                       M_requestors;                                      // 0x38(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	enum class EQtnCameraBlendState              M_camBlendState;                                   // 0x48(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1B4C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_currentBlendTimer;                               // 0x4C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_cachedFOVScale;                                  // 0x50(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_cachedBaseFOV;                                   // 0x54(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_cachedScaledFOV;                                 // 0x58(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SweepSize;                                         // 0x5C(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ObstructionLerpSpeed;                              // 0x60(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnCameraPriority                CameraPriority;                                    // 0x64(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1B51[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        BlendInTime;                                       // 0x68(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BlendOutTime;                                      // 0x6C(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         Cut;                                               // 0x70(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseFOVScale;                                       // 0x71(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1B54[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  UILabel;                                           // 0x78(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  UIDescription;                                     // 0x90(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                  CameraSocketName;                                  // 0xA8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CameraSocketOffsetUp;                              // 0xB0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CameraSocketOffsetRight;                           // 0xB4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CameraSocketOffsetForward;                         // 0xB8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultStickLookScale;                             // 0xBC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultMouseLookScale;                             // 0xC0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ShouldUseHeadAim;                                  // 0xC4(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ControlLookIntentions;                             // 0xC5(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1B57[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       LookPitchRange;                                    // 0xC8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                               TargetLocation;                                    // 0xD0(0xC)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                              TargetRotation;                                    // 0xDC(0xC)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                        TargetFOV;                                         // 0xE8(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1B5D[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnCameraBehavior* GetDefaultObj();

	void OnCameraBehaviorTick(float DeltaSeconds);
	void OnCameraBehaviorInit();
	void OnCameraBehaviorFadeOutEnd();
	void OnCameraBehaviorFadeInStart();
	float GetStickLookScale();
	class AQtnPawn* GetOwningPawn();
	class UQtnCameraComponent* GetOwningCameraComponent();
	float GetMouseLookScale();
};

// 0x40 (0x130 - 0xF0)
// Class QtnGame.QtnCameraBehaviorAim
class UQtnCameraBehaviorAim : public UQtnCameraBehavior
{
public:
	struct FVector                               M_pivotLocation;                                   // 0xF0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_dollyLength;                                     // 0xFC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lastHitDistance;                                 // 0x100(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_obstructionLerpRatio;                            // 0x104(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerController*                  M_pLocalPlayerControllerToAimWith;                 // 0x108(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        PivotLocationInterpSpeed;                          // 0x110(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        LookInterpSpeed;                                   // 0x114(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        RearOffset;                                        // 0x118(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       VerticalOffsetRange;                               // 0x11C(0x8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        VerticalOffsetMaxDistance;                         // 0x124(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AimFOV;                                            // 0x128(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowSpinWhenIdle;                                 // 0x12C(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseAimSensitivity;                                 // 0x12D(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1B68[0x2];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnCameraBehaviorAim* GetDefaultObj();

};

// 0x30 (0x120 - 0xF0)
// Class QtnGame.QtnCameraBehaviorAnimOverride
class UQtnCameraBehaviorAnimOverride : public UQtnCameraBehavior
{
public:
	struct FVector                               M_rootLocation;                                    // 0xF0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_dollyLength;                                     // 0xFC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        RearOffset;                                        // 0x100(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             LateralOffset;                                     // 0x104(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        AnimFOV;                                           // 0x10C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        DollyLengthInterpSpeed;                            // 0x110(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        LocationInterpSpeed;                               // 0x114(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_obstructionLerpRatio;                            // 0x118(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lastHitDistance;                                 // 0x11C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnCameraBehaviorAnimOverride* GetDefaultObj();

};

// 0x18 (0x108 - 0xF0)
// Class QtnGame.QtnCameraBehaviorFirstPerson
class UQtnCameraBehaviorFirstPerson : public UQtnCameraBehavior
{
public:
	class AQtnBodyPawn*                          M_pOwningBodyPawn;                                 // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_lerpingNeck;                                     // 0xF8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B6C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_neckOffsetLength;                                // 0xFC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxNeckOffset;                                     // 0x100(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B6D[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnCameraBehaviorFirstPerson* GetDefaultObj();

};

// 0x90 (0x180 - 0xF0)
// Class QtnGame.QtnCameraBehaviorTether
class UQtnCameraBehaviorTether : public UQtnCameraBehavior
{
public:
	class AQtnBodyPawn*                          M_pOwningBodyPawn;                                 // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerUI*                          M_pCachedPlayerUI;                                 // 0xF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_tetherLength;                                    // 0x100(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_additiveFOVOffsetTarget;                         // 0x104(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_effectiveSprintTetherMultiplier;                 // 0x108(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_additiveFOVOffset;                               // 0x10C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isUsingMouseAndKeyboard;                         // 0x110(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B6F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_sprintTimer;                                     // 0x114(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_pivotLocation;                                   // 0x118(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_tetheredCamComponentLocation;                    // 0x124(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        PivotLocationInterpSpeed;                          // 0x130(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        TetherHorizontalLeeway;                            // 0x134(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxTetherLength;                                   // 0x138(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       VerticalOffsetRange;                               // 0x13C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        VerticalOffsetMaxDistance;                         // 0x144(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxAdditiveSprintFOV;                              // 0x148(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        SpeedRatioUponWhichFOVIsAffected;                  // 0x14C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SprintFOVEscalationDuration;                       // 0x150(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        MaxSprintSpeed;                                    // 0x158(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        SprintTetherMultiplier;                            // 0x15C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        LookSmoothingInterpSpeed;                          // 0x160(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        TetherLengthInterpSpeed;                           // 0x164(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FOVAccelerationSpeed;                              // 0x168(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FOVDecelerationSpeed;                              // 0x16C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_obstructionLerpRatio;                            // 0x170(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lastHitDistance;                                 // 0x174(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         AllowSpinWhenIdle;                                 // 0x178(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         StrafeMovementStick;                               // 0x179(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         StrafeMovementMouse;                               // 0x17A(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1B74[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnCameraBehaviorTether* GetDefaultObj();

};

// 0xC0 (0x8C0 - 0x800)
// Class QtnGame.QtnCameraComponent
class UQtnCameraComponent : public UCameraComponent
{
public:
	class AQtnPawn*                              M_pOwningPawn;                                     // 0x800(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQtnCameraBehavior*>            M_cameraBehaviorStack;                             // 0x808(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UQtnCameraBehavior>, class UQtnCameraBehavior*> M_managedCameraBehaviors;                          // 0x818(0x50)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnCameraContribution>        M_cameraContributions;                             // 0x868(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UQtnCameraBehavior*>            M_pendingCameraBehaviors;                          // 0x878(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UQtnCameraBehavior*                    M_pActiveCameraBehavior;                           // 0x888(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnCameraBehavior*                    M_pAmbientCameraBehavior;                          // 0x890(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               M_targetLocation;                                  // 0x898(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                              M_targetRotation;                                  // 0x8A4(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                        M_targetFOV;                                       // 0x8B0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_pendingCut;                                      // 0x8B4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1B7D[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnCameraBehavior>        AmbientCameraBehavior;                             // 0x8B8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCameraComponent* GetDefaultObj();

	void UnRequestCameraBehavior(TSubclassOf<class UQtnCameraBehavior> CamBehaviorClass, class UObject* Requestor);
	void SetAmbientCameraBehavior(TSubclassOf<class UQtnCameraBehavior> CamBehaviorClass);
	class UQtnCameraBehavior* RequestCameraBehavior(TSubclassOf<class UQtnCameraBehavior> CamBehaviorClass, class UObject* Requestor);
	struct FRotator GetTargetRotation();
	struct FVector GetTargetLocation();
	float GetTargetFOV();
	struct FVector GetRelativeNeckOffset();
	class UQtnCameraBehavior* GetActiveCameraBehavior();
};

// 0x10 (0x58 - 0x48)
// Class QtnGame.QtnCameraModifierFullBodyEngagement
class UQtnCameraModifierFullBodyEngagement : public UCameraModifier
{
public:
	class AQtnBodyPawn*                          M_pEngagingPawn;                                   // 0x48(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFrobbableComponent*                M_pFrobTarget;                                     // 0x50(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnCameraModifierFullBodyEngagement* GetDefaultObj();

};

// 0x588 (0x5D0 - 0x48)
// Class QtnGame.QtnCameraModifierThirdPersonMontage
class UQtnCameraModifierThirdPersonMontage : public UCameraModifier
{
public:
	class AQtnBodyPawn*                          M_pOccupiedPawn;                                   // 0x48(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnThirdPersonCameraParams           M_cameraParams;                                    // 0x50(0x18)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        M_FOV;                                             // 0x68(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1B88[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPostProcessSettings                  M_postProcessSettings;                             // 0x70(0x560)(Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnCameraModifierThirdPersonMontage* GetDefaultObj();

};

// 0xA8 (0x188 - 0xE0)
// Class QtnGame.QtnCarryComponent
class UQtnCarryComponent : public UActorComponent
{
public:
	uint8                                        Pad_1BAD[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                L_pCarryingActor;                                  // 0xE8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                R_pCarryingActor;                                  // 0xF0(0x8)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnCarrySettings                     R_carrySettings;                                   // 0xF8(0x40)(Net, Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                        M_lerpTimer;                                       // 0x138(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               M_startingLocation;                                // 0x13C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                              M_startingRotation;                                // 0x148(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                               M_detachedActorScale;                              // 0x154(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_doLerping;                                       // 0x160(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_carryActorRefreshPending;                        // 0x161(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_carryActorRefreshInProgress;                     // 0x162(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_hasBeenReadyForGameplay;                         // 0x163(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bShouldBeTargetedWhileCarried;                     // 0x164(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bPrecludeOtherTargetingWhileCarried;               // 0x165(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1BB6[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            CarryStartEvent;                                   // 0x168(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            CarryEndEvent;                                     // 0x178(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCarryComponent* GetDefaultObj();

	void SetCarryingActor_ServerOnly(class AActor* CarryingActor, struct FQtnCarrySettings& CarrySettings);
	void QtnCarryStartEvent__DelegateSignature(class UQtnCarryComponent* CarryComponent, class AActor* CarryingActor, struct FQtnCarrySettings& CarrySettings, bool IsServer);
	void QtnCarryEndEvent__DelegateSignature(class UQtnCarryComponent* CarryComponent, class AActor* CarryingActor, bool IsServer);
	void OnRep_CarryingActor();
	class AActor* GetCarryingActor();
	void ClearCarryingActor_ServerOnly(bool DestroyCarriedActor);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnCarryingActorInterface
class IQtnCarryingActorInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnCarryingActorInterface* GetDefaultObj();

	bool ShouldDropCarriedObjects();
	void RemoveManagedCarryComponent(class UQtnCarryComponent* CarryComponent);
	void AddManagedCarryComponent(class UQtnCarryComponent* CarryComponent, struct FQtnCarrySettings& CarrySettings);
};

// 0x1F0 (0x2D0 - 0xE0)
// Class QtnGame.QtnCharacterAppearanceComponent
class UQtnCharacterAppearanceComponent : public UActorComponent
{
public:
	uint8                                        Pad_1C0C[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnCharacterDefaultAppearance        DefaultCharacterAppearanceData;                    // 0xE8(0x60)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                        DefaultCharacterVoice;                             // 0x148(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        R_CharacterVoiceType;                              // 0x14C(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerState*                       M_pOwningPlayerState;                              // 0x150(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          M_pOwningBodyPawn;                                 // 0x158(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                OverrideEntityMesh;                                // 0x160(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         IsNonBodyPawnEntity;                               // 0x168(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_pendingAppearanceUpdate;                         // 0x169(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1C0D[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnCharacterAppearance               R_CharacterAppearanceData;                         // 0x170(0x30)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnVerb>>          R_equippedEmoteVerbs;                              // 0x1A0(0x10)(Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class FString>                        R_vaultCosmeticsData;                              // 0x1B0(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class FString>                        R_vaultEmotesData;                                 // 0x1C0(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                M_pBodyMesh;                                       // 0x1D0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                M_pHatMesh;                                        // 0x1D8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                M_pHairMesh;                                       // 0x1E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                M_pCapeMesh;                                       // 0x1E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                M_pHeadMesh;                                       // 0x1F0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                M_pHeadAccessoryMesh;                              // 0x1F8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>        M_customizationMeshes;                             // 0x200(0x10)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FString                                M_desiredBody;                                     // 0x210(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                M_desiredHat;                                      // 0x220(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                M_desiredHair;                                     // 0x230(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                M_desiredCape;                                     // 0x240(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                M_desiredHead;                                     // 0x250(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                M_desiredHeadAccessory;                            // 0x260(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                        M_desiredEmotes;                                   // 0x270(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnUpdateAppearanceEvent;                           // 0x280(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCosmeticsVaultUpdated;                           // 0x290(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEmotesVaultUpdated;                              // 0x2A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEquippedEmotesUpdated;                           // 0x2B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x2C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCharacterAppearanceComponent* GetDefaultObj();

	void UpdateAppearance();
	void SetupComponentForDefaults(class AQtnBodyPawn* POwnerBodypawn);
	void SetDesiredEmotes(TArray<class FString>& DesiredEmotes);
	void SetDesiredCosmetics(class FString& DesiredBody, class FString& DesiredHat, class FString& DesiredHair, class FString& DesiredCape, class FString& DesiredHead, class FString& DesiredHeadAccessory);
	void SetCharacterVisibility(bool bNewVisibility);
	void ServerUnsetEmote(int32 EmoteSlot);
	void ServerUnsetCosmetic(enum class EQtnAppearanceSlot AppearanceSlot);
	void ServerSetEmote(int32 EmotesIndex, int32 EmoteSlot);
	void ServerSetCosmetic(int32 CosmeticsIndex, enum class EQtnAppearanceSlot AppearanceSlot);
	void ServerAddAvailableItem(class FString& ItemId, bool IsEmote);
	void ServerAddAvailableEmotes(TArray<class FString>& Emotes);
	void ServerAddAvailableEmote(class FString& Emote);
	void ServerAddAvailableCosmetics(TArray<class FString>& Cosmetics);
	void ServerAddAvailableCosmetic(class FString& Cosmetic);
	TArray<class USkeletalMesh*> PreloadDefaultMeshesForClass(TSubclassOf<class AActor> ActorClass);
	void OnRep_VaultEmotesData();
	void OnRep_VaultCosmeticsData();
	void OnRep_EquippedEmoteVerbs();
	void OnRep_CharacterAppearanceData();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void LocalUnsetCosmetic(enum class EQtnAppearanceSlot AppearanceSlot);
	void LocalSetUnownedCosmetic(enum class EQtnAppearanceSlot AppearanceSlot, class FString& CosmeticsId);
	void LocalSetEmote(int32 EmotesIndex, int32 EmoteSlot);
	void LocalSetCosmetic(int32 CosmeticsIndex, enum class EQtnAppearanceSlot AppearanceSlot);
	int32 LocalFindCosmeticIndex(class FString& CosmeticItemToFind);
	void LocalCopyCosmeticsFromTarget(class UQtnCharacterAppearanceComponent* TargetAppearanceComponent);
	TArray<class FString> GetVaultEmotesData();
	TArray<class FString> GetVaultCosmeticsData();
	class USkeletalMeshComponent* GetHeadComponent();
	class USkeletalMeshComponent* GetHeadAccessoryComponent();
	class USkeletalMeshComponent* GetHatComponent();
	class USkeletalMeshComponent* GetHairComponent();
	TArray<TSubclassOf<class UQtnVerb>> GetEquippedEmotes();
	TArray<class FString> GetEquippedCosmetics();
	struct FQtnCharacterAppearance GetCharacterAppearanceData();
	class USkeletalMeshComponent* GetCapeComponent();
	class USkeletalMeshComponent* GetBodyComponent();
	class USkeletalMeshComponent* AddAndUpdateMeshSlot(class USkeletalMeshComponent* PParentMesh, class UQtnCharacterBodyMesh* PCharacterMesh, class FName& AttachmentSocket);
};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnCharacterAppearanceSettings
class UQtnCharacterAppearanceSettings : public UObject
{
public:
	class UDataTable*                            MasterCosmeticDataTable;                           // 0x28(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCharacterAppearanceSettings* GetDefaultObj();

	TSubclassOf<class UQtnVerb> GetEmoteVerbClass(const class FString& EmoteVerbName, bool* Success, class UObject* WorldContextObject);
	void GetCharacterAppearanceDisplayText(const class FString& CatalogId, const class FString& ItemId, class FText* OutDisplayName, class FText* OutDescription, class UObject* WorldContextObject);
	TSubclassOf<class UQtnCharacterBodyMesh> GetBodyMeshClass(const class FString& bodyMeshName, bool* Success, class UObject* WorldContextObject);
};

// 0x50 (0x78 - 0x28)
// Class QtnGame.QtnCharacterBodyMesh
class UQtnCharacterBodyMesh : public UObject
{
public:
	class FName                                  PlayFabItemId;                                     // 0x28(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  AttachToSocket;                                    // 0x30(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ApplyMorphTarget;                                  // 0x38(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         BypassClothBakeRestriction;                        // 0x39(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnAppearanceSlot                SlotType;                                          // 0x3A(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C1C[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSoftObjectPtr<class USkeletalMesh>          DefaultBodyMesh;                                   // 0x40(0x28)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQtnMaterialOverrideParameter> MeshMaterialOverrideParameters;                    // 0x68(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCharacterBodyMesh* GetDefaultObj();

	void OnBodyMeshAcquired(class USkeletalMeshComponent* ComponentAdded);
};

// 0x8 (0x90 - 0x88)
// Class QtnGame.QtnCheatManager
class UQtnCheatManager : public UCheatManager
{
public:
	class AQtnPlayerController*                  M_pOwningPlayerController;                         // 0x88(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnCheatManager* GetDefaultObj();

	void QtnSetControllerId(int32 ControllerId);
	void QtnAutomatedReports();
	bool AreCheatsLocked();
};

// 0x1A8 (0x1D0 - 0x28)
// Class QtnGame.QtnSaveData
class UQtnSaveData : public USaveGame
{
public:
	struct FQtnVersion                           M_storedSaveDataVersion;                           // 0x28(0xC)(SaveGame, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1C33[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnSaveLoadState*                     M_pDrivingSaveLoadState;                           // 0x38(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                M_slotName;                                        // 0x40(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnDataBag>, struct FQtnDataBagBytes> M_dataBagBytes;                                    // 0x50(0x50)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnDataBag>, class UQtnDataBag*> M_dataBagInstances;                                // 0xA0(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnDataBag>, class UQtnDataBag*> M_customDataBags;                                  // 0xF0(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<uint8>                                M_storedBytes;                                     // 0x140(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnDataBag>>       CustomDataBags;                                    // 0x150(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FQtnVersion                           DeprecatedSaveDataVersion;                         // 0x160(0xC)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FQtnVersion                           LatestSaveDataVersion;                             // 0x16C(0xC)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FQtnVersion                           M_currentSaveDataVersion;                          // 0x178(0xC)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_1C36[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnSaveLoadManager*                   M_pOwningSaveLoadManager;                          // 0x188(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PreSaveEvent;                                      // 0x190(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PostSaveEvent;                                     // 0x1A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PreLoadEvent;                                      // 0x1B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PostLoadEvent;                                     // 0x1C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSaveData* GetDefaultObj();

	void QtnPreSaveLoadDataEvent__DelegateSignature(class AQtnBodyPawn* LocalOriginalBody);
	void QtnPostSaveLoadDataEvent__DelegateSignature(bool Success, class AQtnBodyPawn* LocalOriginalBody);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool HasValidSaveData();
	struct FQtnVersion GetLatestSaveDataVersion();
	class UQtnDataBag* GetCustomDataBag(TSubclassOf<class UQtnDataBag> DatabagArchetype);
	struct FQtnVersion GetCurrentSaveDataVersion();
};

// 0x78 (0x248 - 0x1D0)
// Class QtnGame.QtnCloudOptionsSaveData
class UQtnCloudOptionsSaveData : public UQtnSaveData
{
public:
	class UQtnInputDataBag*                      M_pInputDataBag;                                   // 0x1D0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnInputDataBag>          InputDataBagArchetype;                             // 0x1D8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        M_pCachedLocalPlayerPawn;                          // 0x1E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         SavedInvertMouseLookY;                             // 0x1E8(0x1)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedInvertStickLookY;                             // 0x1E9(0x1)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C77[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SavedStickLookSpeed;                               // 0x1EC(0x4)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedStickAimSpeed;                                // 0x1F0(0x4)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedMouseLookSpeed;                               // 0x1F4(0x4)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedMouseAimSpeed;                                // 0x1F8(0x4)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedGyroAiming;                                   // 0x1FC(0x1)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C79[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SavedGyroSensitivity;                              // 0x200(0x4)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedForceFeedback;                                // 0x204(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C7B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SavedFOVScaleRatio;                                // 0x208(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnGamepadGlyphStyle             SavedGamepadGlyphStyle;                            // 0x20C(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C7D[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SavedAudioMasterVolume;                            // 0x210(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedAudioMusicVolume;                             // 0x214(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedAudioSFXVolume;                               // 0x218(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedAudioAmbienceVolume;                          // 0x21C(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedAudioSpeechVolume;                            // 0x220(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C7F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                SavedLanguage;                                     // 0x228(0x10)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                          SavedVOLanguage;                                   // 0x238(0x8)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedTutorialsEnabled;                             // 0x240(0x1)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedPassiveEscape;                                // 0x241(0x1)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C80[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnCloudOptionsSaveData* GetDefaultObj();

	void SetVOLanguage(const struct FGameplayTag& VoLanguage, class UObject* WorldContextObject);
	void SetStickLookSpeed(float SpeedRatio);
	void SetStickAimSpeed(float SpeedRatio);
	void SetMouseLookSpeed(float SpeedRatio);
	void SetMouseAimSpeed(float SpeedRatio);
	void SetLanguage(const class FString& Language, class UObject* WorldContextObject);
	void SetGamepadGlyphStyle(enum class EQtnGamepadGlyphStyle GamepadGlyphStyle, class UObject* WorldContextObject);
	void SetFOVScaleRatio(float FOVScaleRatio, class UObject* WorldContextObject);
	void SetForceFeedback(bool ForceFeedback, class UObject* WorldContextObject);
	void SetAudioSpeechVolume(float Volume, class UObject* WorldContextObject);
	void SetAudioSFXVolume(float Volume, class UObject* WorldContextObject);
	void SetAudioMusicVolume(float Volume, class UObject* WorldContextObject);
	void SetAudioMasterVolume(float Volume, class UObject* WorldContextObject);
	void SetAudioAmbienceVolume(float Volume, class UObject* WorldContextObject);
	struct FGameplayTag GetVOLanguage(class UObject* WorldContextObject);
	float GetStickLookSpeedRatio();
	float GetStickAimSpeedRatio();
	float GetMouseLookSpeedRatio();
	float GetMouseAimSpeedRatio();
	class FString GetLanguage(class UObject* WorldContextObject);
	class UQtnInputDataBag* GetInputDataBag();
	enum class EQtnGamepadGlyphStyle GetGamepadGlyphStyle(class UObject* WorldContextObject);
	float GetFOVScaleRatio(class UObject* WorldContextObject);
	bool GetForceFeedback(class UObject* WorldContextObject);
	struct FGameplayTag GetDefaultVOLanguage();
	float GetDefaultStickLookSpeedRatio();
	float GetDefaultStickLookSpeed();
	float GetDefaultStickAimSpeedRatio();
	float GetDefaultStickAimSpeed();
	float GetDefaultMouseLookSpeedRatio();
	float GetDefaultMouseLookSpeed();
	float GetDefaultMouseAimSpeedRatio();
	float GetDefaultMouseAimSpeed();
	class FString GetDefaultLanguage();
	bool GetDefaultInvertCameraY();
	float GetDefaultGyroSensitivity();
	bool GetDefaultGyroAiming();
	enum class EQtnGamepadGlyphStyle GetDefaultGamepadGlyphStyle();
	float GetDefaultFOVScaleRatio();
	bool GetDefaultForceFeedback();
	float GetDefaultAudioSpeechVolume();
	float GetDefaultAudioSFXVolume();
	float GetDefaultAudioMusicVolume();
	float GetDefaultAudioMasterVolume();
	float GetDefaultAudioAmbienceVolume();
	float GetAudioSpeechVolume(class UObject* WorldContextObject);
	float GetAudioSFXVolume(class UObject* WorldContextObject);
	float GetAudioMusicVolume(class UObject* WorldContextObject);
	float GetAudioMasterVolume(class UObject* WorldContextObject);
	float GetAudioAmbienceVolume(class UObject* WorldContextObject);
};

// 0x1A0 (0x1C8 - 0x28)
// Class QtnGame.QtnCombatSettings
class UQtnCombatSettings : public UObject
{
public:
	TMap<struct FGameplayTag, struct FQtnLootItemVisualConfiguration> GameplayTagToCurrencyLootConfigurationMap;         // 0x28(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnLootItemVisualConfiguration> MediaLootFromRarityGameplayTagConfigurationMap;    // 0x78(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class AQtnFXActor>> RarityGameplayTagFXConfigurationMap;               // 0xC8(0x50)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnWeaponConfiguration> WeaponTypesMap;                                    // 0x118(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnConsumableConfiguration> ConsumableTypesMap;                                // 0x168(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FQtnItemData>                  PlayerDefaultItemData;                             // 0x1B8(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCombatSettings* GetDefaultObj();

	struct FQtnWeaponConfiguration GetWeaponConfigurationFromWeaponTypeGameplayType(class UObject* WorldContextObject, struct FQtnItemData& ItemData, bool* FoundConfiguration);
	struct FQtnLootItemVisualConfiguration GetCurrencyConfigurationFromCurrencyTag(class UObject* WorldContextObject, struct FGameplayTag& CurrencyTag, bool* FoundConfiguration);
	TArray<struct FGameplayTag> GetAllWeaponGameplayTags(class UObject* WorldContextObject);
};

// 0x10 (0x40 - 0x30)
// Class QtnGame.QtnContactData
class UQtnContactData : public UDataAsset
{
public:
	class UQtnContactSubsystemSurfaceSelector*   SurfaceSelector;                                   // 0x30(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnContactSubsystemTargetFilter*      ContextTargetFilter;                               // 0x38(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactData* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class QtnGame.QtnContactSubsystem
class UQtnContactSubsystem : public UGameInstanceSubsystem
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystem* GetDefaultObj();

	struct FQtnContactSystemResult HandleContactSystemResults(class UObject* WorldContextObject, class UQtnContactData* ContactData, struct FQtnContactEventInfo& ContactInfo, struct FQtnContactSystemResult& ContactSystemResults);
	class UQtnContactSubsystem* GetQtnContactSubsystem(class UObject* WorldContextObject);
	struct FQtnContactSystemResult GenerateContactEvent(class UObject* WorldContextObject, class UQtnContactData* ContactData, struct FQtnContactEventInfo& ContactInfo, bool SpawnContactEffect);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector
class UQtnContactSubsystemSurfaceSelector : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector* GetDefaultObj();

	struct FQtnSurfaceData SelectSurfaceResult(class UQtnContactData* ContactData, struct FQtnContactEventInfo& ContactInfo);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_Null
class UQtnContactSubsystemSurfaceSelector_Null : public UQtnContactSubsystemSurfaceSelector
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_Null* GetDefaultObj();

};

// 0x30 (0x58 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_Single
class UQtnContactSubsystemSurfaceSelector_Single : public UQtnContactSubsystemSurfaceSelector
{
public:
	struct FQtnSurfaceData                       SurfaceData;                                       // 0x28(0x30)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_Single* GetDefaultObj();

};

// 0x58 (0x80 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_FromMap
class UQtnContactSubsystemSurfaceSelector_FromMap : public UQtnContactSubsystemSurfaceSelector
{
public:
	TMap<enum class EPhysicalSurface, struct FQtnSurfaceData> SurfaceDataMap;                                    // 0x28(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         FallbackToDefaultValue;                            // 0x78(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1CB1[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_FromMap* GetDefaultObj();

};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_FromAsset
class UQtnContactSubsystemSurfaceSelector_FromAsset : public UQtnContactSubsystemSurfaceSelector
{
public:
	class UQtnContactData*                       ContactDataAsset;                                  // 0x28(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_FromAsset* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_Sequence
class UQtnContactSubsystemSurfaceSelector_Sequence : public UQtnContactSubsystemSurfaceSelector
{
public:
	TArray<class UQtnContactSubsystemSurfaceSelector*> SelectorArray;                                     // 0x28(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_Sequence* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_Concurrent
class UQtnContactSubsystemSurfaceSelector_Concurrent : public UQtnContactSubsystemSurfaceSelector
{
public:
	TArray<class UQtnContactSubsystemSurfaceSelector*> SelectorArray;                                     // 0x28(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_Concurrent* GetDefaultObj();

};

// 0x60 (0x88 - 0x28)
// Class QtnGame.QtnContactSubsystemSurfaceSelector_FromDamageType
class UQtnContactSubsystemSurfaceSelector_FromDamageType : public UQtnContactSubsystemSurfaceSelector
{
public:
	TMap<TSubclassOf<class UQtnDamageType>, struct FQtnSurfaceData> SurfaceDataMap;                                    // 0x28(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         FallbackToDefaultValue;                            // 0x78(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1CB2[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnDamageType>            DefaultDamageType;                                 // 0x80(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSurfaceSelector_FromDamageType* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemResultSelector
class UQtnContactSubsystemSystemResultSelector : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemResultSelector* GetDefaultObj();

	struct FQtnContactSystemResult SelectSystemResult(class UQtnContactData* ContactData, struct FQtnContactEventInfo& ContactInfo, struct FQtnSurfaceData& SurfaceData);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemResultSelector_Null
class UQtnContactSubsystemSystemResultSelector_Null : public UQtnContactSubsystemSystemResultSelector
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemResultSelector_Null* GetDefaultObj();

};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemResultSelector_Single
class UQtnContactSubsystemSystemResultSelector_Single : public UQtnContactSubsystemSystemResultSelector
{
public:
	TSubclassOf<class AQtnFXActor>               FXActor;                                           // 0x28(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemResultSelector_Single* GetDefaultObj();

};

// 0x60 (0x88 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemResultSelector_FromMap
class UQtnContactSubsystemSystemResultSelector_FromMap : public UQtnContactSubsystemSystemResultSelector
{
public:
	TMap<class FName, TSubclassOf<class AQtnFXActor>> FXActorMap;                                        // 0x28(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                         FallbackToDefaultValue;                            // 0x78(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1CB8[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  FallbackMapKey;                                    // 0x7C(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1CB9[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemResultSelector_FromMap* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemResultSelector_Random
class UQtnContactSubsystemSystemResultSelector_Random : public UQtnContactSubsystemSystemResultSelector
{
public:
	TArray<TSubclassOf<class AQtnFXActor>>       FXActorArray;                                      // 0x28(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemResultSelector_Random* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemResultSelector_All
class UQtnContactSubsystemSystemResultSelector_All : public UQtnContactSubsystemSystemResultSelector
{
public:
	TArray<TSubclassOf<class AQtnFXActor>>       FXActorArray;                                      // 0x28(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemResultSelector_All* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemSpawnModifier
class UQtnContactSubsystemSystemSpawnModifier : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemSpawnModifier* GetDefaultObj();

	void ModifySpawnedContactFX(class AQtnFXActor* ActorFX, class UQtnContactData* ContactData, struct FQtnContactEventInfo& ContactInfo, struct FQtnSurfaceData& SurfaceData);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemSpawnModifier_Null
class UQtnContactSubsystemSystemSpawnModifier_Null : public UQtnContactSubsystemSystemSpawnModifier
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemSpawnModifier_Null* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnContactSubsystemSystemSpawnModifier_AttachToTargetActor
class UQtnContactSubsystemSystemSpawnModifier_AttachToTargetActor : public UQtnContactSubsystemSystemSpawnModifier
{
public:
	class FName                                  TargetActorSocket;                                 // 0x28(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         UseHighPrecisionAttachment;                        // 0x30(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1CC0[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnContactSubsystemSystemSpawnModifier_AttachToTargetActor* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnContactSubsystemTargetFilter
class UQtnContactSubsystemTargetFilter : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnContactSubsystemTargetFilter* GetDefaultObj();

	bool FilterIncomingContactRequest(class UQtnContactData* ContactData, struct FQtnContactEventInfo& ContactInfo);
};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnContactSubsystemTargetFilter_Always
class UQtnContactSubsystemTargetFilter_Always : public UQtnContactSubsystemTargetFilter
{
public:
	bool                                         AlwaysAllow;                                       // 0x28(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1CC3[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnContactSubsystemTargetFilter_Always* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnContactSubsystemTargetFilter_Sequence
class UQtnContactSubsystemTargetFilter_Sequence : public UQtnContactSubsystemTargetFilter
{
public:
	TArray<class UQtnContactSubsystemTargetFilter*> FilterArray;                                       // 0x28(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnContactSubsystemTargetFilter_Sequence* GetDefaultObj();

};

// 0x90 (0xB8 - 0x28)
// Class QtnGame.QtnCosmeticCache
class UQtnCosmeticCache : public UObject
{
public:
	class AQtnBodyPawn*                          BoundBodyPawn;                                     // 0x28(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FQtnCosmeticCatalogueEntry>    AllLoadedEntriesArray;                             // 0x30(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnCosmeticCatalogueEntry>    FilteredEntriesArray;                              // 0x40(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                 CurrentFilterTags;                                 // 0x50(0x20)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FQtnCosmeticFilterSettings            CurrentFilterSettings;                             // 0x70(0x28)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnFilteredEntriesChangedEvent;                     // 0x98(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_1CD7[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnCosmeticCache* GetDefaultObj();

	void SetFilterSettings(const struct FQtnCosmeticFilterSettings& FilterSettings, bool RefreshEntries);
	void RefreshPlayerItemOwnership();
	void RefreshFilteredCosmetics();
	void QtnFilteredCosmeticsChangedEvent__DelegateSignature();
	void LoadCosmeticsFromDataTable(class UDataTable* DataTable, bool LoadAdditively);
	void InitializeCosmeticCache(class AQtnBodyPawn* OwningBodyPawn);
	void ApplyAdditiveFilter(const struct FGameplayTagContainer& FilterTags, bool RefreshEntries);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnCreditSectionWidgetInterface
class IQtnCreditSectionWidgetInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnCreditSectionWidgetInterface* GetDefaultObj();

	void OnGenerateSection(class UObject* GeneratorSource, class UUserWidget* WidgetBaseSource);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnCreditsSectionBase
class UQtnCreditsSectionBase : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnCreditsSectionBase* GetDefaultObj();

	void GenerateSection(class UQtnCreditsWidget* SourceCreditsWidget);
	void ExecuteSection(class UQtnCreditsWidget* SourceCreditsWidget);
};

// 0x20 (0x48 - 0x28)
// Class QtnGame.QtnCreditsSection_Organization
class UQtnCreditsSection_Organization : public UQtnCreditsSectionBase
{
public:
	struct FDataTableRowHandle                   OrganizationRowHandle;                             // 0x28(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnCreditsSectionWidget>  WidgetClass;                                       // 0x38(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnCreditsSectionWidget*              WidgetInstance;                                    // 0x40(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCreditsSection_Organization* GetDefaultObj();

};

// 0x18 (0x40 - 0x28)
// Class QtnGame.QtnCreditsSection_ContributorList
class UQtnCreditsSection_ContributorList : public UQtnCreditsSectionBase
{
public:
	class UDataTable*                            ContributorDataTable;                              // 0x28(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnCreditsSectionWidget>  WidgetClass;                                       // 0x30(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnCreditsSectionWidget*              WidgetInstance;                                    // 0x38(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCreditsSection_ContributorList* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnCreditsSection_CustomWidget
class UQtnCreditsSection_CustomWidget : public UQtnCreditsSectionBase
{
public:
	TSubclassOf<class UUserWidget>               WidgetClass;                                       // 0x28(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                           WidgetInstance;                                    // 0x30(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCreditsSection_CustomWidget* GetDefaultObj();

};

// 0x10 (0x270 - 0x260)
// Class QtnGame.QtnCreditsSectionWidget
class UQtnCreditsSectionWidget : public UUserWidget
{
public:
	class UQtnCreditsWidget*                     OwningCreditsWidget;                               // 0x260(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnCreditsSectionBase*                OwningSection;                                     // 0x268(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCreditsSectionWidget* GetDefaultObj();

	void OnGenerateFromSectionEvent(class UQtnCreditsWidget* SourceCreditsWidget, class UQtnCreditsSectionBase* OwningCreditsSection);
};

// 0x38 (0x298 - 0x260)
// Class QtnGame.QtnUserWidget
class UQtnUserWidget : public UUserWidget
{
public:
	class UQtnScreen*                            M_pOwningScreen;                                   // 0x260(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isInWorldSpace;                                  // 0x268(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         ManualHideShow;                                    // 0x269(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1D82[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_userIndex;                                       // 0x26C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1D83[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UWidget*                               M_pCurrentFocusedWidget;                           // 0x280(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needsCultureUpdate;                              // 0x288(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1D84[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        ZOrder;                                            // 0x28C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  InitialWidgetToFocus;                              // 0x290(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUserWidget* GetDefaultObj();

	void UnregisterAndHideWorldScreen();
	void SetWidgetVisibility(class UWidget* Widget, bool WantVisible);
	void SetWidgetSlateVisibility(class UWidget* Widget, enum class ESlateVisibility SlateVisibility);
	void SetCurrentFocusedWidget(class UWidget* IntendedWidget);
	void RegisterAndShowWorldScreen(TSubclassOf<class UQtnScreen> ScreenClassToPush, enum class EQtnScreenStackEnum ScreenStackIndex);
	void OnUIScroll(float ScrollDelta, bool FromStick);
	void OnUIScreenActionRepeat(enum class EQtnUIScreenActionEnum ScreenAction);
	void OnUIScreenActionReleased(enum class EQtnUIScreenActionEnum ScreenAction);
	void OnUIScreenActionPressed(enum class EQtnUIScreenActionEnum ScreenAction);
	void OnUINumPad(int32 Number);
	void OnUIHotKey(enum class EQtnUIHotKeyEnum HotKey);
	void OnUIBodyActionRepeat(enum class EQtnUIBodyActionEnum BodyAction);
	void OnUIBodyActionReleased(enum class EQtnUIBodyActionEnum BodyAction);
	void OnUIBodyActionPressed(enum class EQtnUIBodyActionEnum BodyAction);
	void OnQtnWidgetUnOccupied(class AQtnBodyPawn* OccupiedBodyPawn);
	void OnQtnWidgetUnInitialized();
	void OnQtnWidgetUnHijack(class AQtnPawn* HijackedPawn);
	void OnQtnWidgetTicked(float DeltaSeconds);
	void OnQtnWidgetStopped();
	void OnQtnWidgetStarted();
	void OnQtnWidgetShown();
	void OnQtnWidgetResumed(class UQtnScreen* PreviousScreen);
	void OnQtnWidgetReadyForGameplay();
	void OnQtnWidgetPaused();
	void OnQtnWidgetOccupied(class AQtnBodyPawn* OccupiedBodyPawn, bool FirstTime);
	void OnQtnWidgetInitialized();
	void OnQtnWidgetHijack(class AQtnPawn* HijackedPawn);
	void OnQtnWidgetHidden();
	void OnQtnWidgetFocusChanged(class UWidget* PreviousFocusedWidget, class UWidget* CurrentFocusedWidget);
	void OnMouseRightClick(bool Pressed, class UWidget* HoveredWidget);
	void OnMouseLeftClick(bool Pressed, class UWidget* HoveredWidget);
	void OnInputUsageChange(bool IsUsingMouseAndKeyboard);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnCursorDelta(float DeltaSeconds, const struct FVector2D& CursorDelta);
	bool IsUsingMouseAndKeyboard();
	bool IsScreenActionPressed(enum class EQtnUIScreenActionEnum ScreenAction);
	bool IsReadyForGameplay();
	float GetZOrder();
	class UWidget* GetWidgetChildByLabel(class UWidget* ParentWidget, class FText& ChildLabel);
	class UWidget* GetWidgetChildByClass(class UWidget* ParentWidget, TSubclassOf<class UWidget> WidgetClass, int32 RecursiveDepth);
	struct FVector2D GetWidgetCenterAbsolute(class UWidget* Widget);
	struct FVector2D GetRightStickInput();
	class UQtnScreen* GetOwningScreen();
	class AQtnPlayerState* GetOwningQtnPlayerState();
	class AQtnPlayerPawn* GetOwningQtnPlayerPawn();
	class AQtnPlayerUI* GetOwningPlayerUI();
	void GetOwningPlayerInfo(class AQtnBodyPawn** OccupiedBodyPawn, class AQtnPlayerPawn** PlayerPawn, class AQtnPlayerController** PlayerController, class AQtnPlayerUI** PlayerUI, class AQtnPlayerState** QtnPlayerState, bool* IsHosting);
	class AQtnPlayerController* GetOwningPlayerController();
	class AQtnBodyPawn* GetOccupiedBodyPawn();
	struct FVector2D GetMousePosition();
	struct FVector2D GetMouseDelta();
	struct FVector2D GetLeftStickInput();
	struct FVector2D GetCursorPosition();
	struct FVector2D GetCursorDelta();
	class UWidget* GetCurrentlyHoveredWidget();
	class AQtnPawn* GetCurrentlyControlledPawn();
	class UWidget* GetCurrentFocusedWidget();
	class UCanvasPanelSlot* GetCanvasPanelSlot(class UWidget* Widget);
};

// 0x30 (0x2C8 - 0x298)
// Class QtnGame.QtnCreditsWidget
class UQtnCreditsWidget : public UQtnUserWidget
{
public:
	bool                                         M_bHasBoundToRequiredWidgets;                      // 0x298(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1DDF[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UVerticalBox*                          M_pTimelineContentBox;                             // 0x2A0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                            M_pTimelineScrollBox;                              // 0x2A8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bHasGeneratedTimeline;                           // 0x2B0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1DE0[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnCreditsSectionBase*>        SectionsTimeline;                                  // 0x2B8(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnCreditsWidget* GetDefaultObj();

	void StartCredits();
	void GenerateCredits(bool RegenerateCredits);
	void BindToRequiredWidgets(struct FQtnCreditsWidgetInitializationParameters& InitParams);
	class UUserWidget* AddTimelineWidget(TSubclassOf<class UUserWidget> WidgetClass);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnCuckooActorInterface
class IQtnCuckooActorInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnCuckooActorInterface* GetDefaultObj();

	void SetTrackedPosition(const struct FVector& Position);
	void SetHeadTrackingRanges(const struct FQtnRangedFloat& PitchRange, const struct FQtnRangedFloat& YawRange);
	void SetHeadTracking(bool ShouldTrack);
	void PlaySyncedAnim(class UAnimSequence* AnimSequence, class UAnimMontage* Montage);
	void AnimNotifyCuckoo(bool On, int32 Index);
};

// 0x28 (0x278 - 0x250)
// Class QtnGame.QtnCullingVolume
class AQtnCullingVolume : public AActor
{
public:
	struct FVector                               VolumeOrigin;                                      // 0x250(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               VolumeExtend;                                      // 0x25C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                        HideKeywordListMap;                                // 0x268(0x10)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class AQtnCullingVolume* GetDefaultObj();

	bool IsActorInVolume(class AActor* Actor);
	void CullingFarActors(const class FString& LevelKeyword);
};

// 0x48 (0x88 - 0x40)
// Class QtnGame.QtnDamageNumbersSubsystem
class UQtnDamageNumbersSubsystem : public UTickableWorldSubsystem
{
public:
	TSubclassOf<class UWidgetComponent>          WidgetComponentClass;                              // 0x40(0x8)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnDamageNumberWidget>    WidgetClass;                                       // 0x48(0x8)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                M_pWorldActor;                                     // 0x50(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FQtnDamageWidget>              M_FreeWidgetPoolArray;                             // 0x58(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnDamageWidget>              M_ActiveWidgetPoolArray;                           // 0x68(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         M_bHasValidSetup;                                  // 0x78(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bUseOldDamageNumberSystem;                       // 0x79(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1DFA[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnGameInstance*                      M_pCachedGameInstance;                             // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnDamageNumbersSubsystem* GetDefaultObj();

	void SpawnCombatTextFromText(class AActor* TargetToParent, class FText& TextToDisplay, struct FVector& Location, struct FQtnDamageNumberOptionalInfo& OptionalData);
	void SpawnCombatTextFromMaterial(class AActor* TargetToParent, class UMaterialInterface* Material, struct FVector& Location, struct FQtnDamageNumberOptionalInfo& OptionalData);
	void SpawnCombatTextFromDamage(class AActor* TargetToParent, struct FQtnDamageInfo& DamageInfo, struct FVector& Location, struct FQtnDamageNumberOptionalInfo& OptionalData);
	bool IsOldDamageNumberSystem();
	class UQtnDamageNumbersSubsystem* GetQtnDamageNumbersSubsystem(class UObject* WorldContextObject);
	void EditorHelper_SetWidgetComponentClass(TSubclassOf<class UWidgetComponent> ClassToSet);
	void EditorHelper_SetWidgetClass(TSubclassOf<class UUserWidget> ClassToSet);
};

// 0x20 (0x280 - 0x260)
// Class QtnGame.QtnDamageNumberWidget
class UQtnDamageNumberWidget : public UUserWidget
{
public:
	class UWidgetComponent*                      WidgetComponentOwner;                              // 0x260(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                TargetParent;                                      // 0x268(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               OffsetFromParent;                                  // 0x270(0xC)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        M_TransformTime;                                   // 0x27C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnDamageNumberWidget* GetDefaultObj();

	void UpdateTransform_Cpp(float InDeltaTime, class UCanvasPanel* Canvas, class UWidgetAnimation* Animation, class UCurveFloat* HorizontalCurve, class UCurveFloat* VerticalCurve, float HorizontalTravel, float VerticalTravel, float DamageDifference, struct FVector& TargetLocation, float MaxDistanceToCamera);
	void ReturnToPool();
	void OnStartFromTextEvent(class AActor* Target, class FText& TextToDisplay, struct FQtnDamageNumberOptionalInfo& OptionalData, struct FVector& WorldLocation);
	void OnStartFromMaterialEvent(class AActor* Target, class UMaterialInterface* Material, struct FQtnDamageNumberOptionalInfo& OptionalData, struct FVector& WorldLocation);
	void OnStartFromDamageInfoEvent(class AActor* Target, struct FQtnDamageInfo& DamageInfo, struct FQtnDamageNumberOptionalInfo& OptionalData, struct FVector& WorldLocation);
};

// 0x128 (0x150 - 0x28)
// Class QtnGame.QtnDamageReaction
class UQtnDamageReaction : public UObject
{
public:
	class UQtnFullBodyStateHitReaction*          M_pOwningHitReaction;                              // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pVictimPawn;                                     // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pVictimBody;                                     // 0x38(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnDamageInfo                        M_damageInfo;                                      // 0x40(0x88)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnHitReactionInfo                   M_hitReactInfo;                                    // 0xC8(0x50)(Transient, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomPlayRateRange;                               // 0x118(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       RandomStartTimeRange;                              // 0x120(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         FinishLoopRequested;                               // 0x128(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         SupportAirborneReactions;                          // 0x129(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowFallingOffLedges;                             // 0x12A(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnUIBodyActionEnum              M_lastMashedButton;                                // 0x12B(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_buttonMashTime;                                  // 0x12C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_howLongHasButtonMashBeenFull;                    // 0x130(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_passiveEscapeAccumulator;                        // 0x134(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        ButtonMashFillSeconds;                             // 0x138(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        FillDurationMultiplier;                            // 0x13C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SecondsPerButtonMash;                              // 0x140(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ButtonMashDrainMultiplier;                         // 0x144(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AutoFillButtonMashForAIs;                          // 0x148(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1E4D[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnDamageReaction* GetDefaultObj();

	void OnTickReaction(float DeltaSeconds);
	void OnReactionMontageDone(class UAnimMontage* Montage, bool Interrupted);
	void OnMovementBlocked(struct FHitResult& Impact);
	void OnInitReaction(class UQtnFullBodyStateHitReaction* HitReactionBodyState);
	void OnExitReaction(bool IsServer);
	void OnEnterReaction(bool IsServer);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnAnimWindowEnd(class UQtnAnimWindow* AnimWindow, bool Interrupted);
	void OnAnimWindowBegin(class UQtnAnimWindow* AnimWindow, float TotalDuration);
	void OnAnimNotify(class UQtnAnimNotify* AnimNotify);
	bool IsReactionFinished();
	void HandleOtherDamage(struct FQtnDamageInfo& OtherDamageInfo, struct FQtnHitReactionInfo& OtherReactInfo, bool* AllowNewReaction);
	class AQtnPawn* GetVictimPawn();
	class AQtnBodyPawn* GetVictimBody();
	class UQtnFullBodyStateHitReaction* GetOwningHitReaction();
	struct FQtnHitReactionInfo GetHitReactInfo();
	class UQtnVerb* GetDamagingVerb();
	class AQtnPawn* GetDamagingCulprit();
	struct FQtnDamageInfo GetDamageInfo();
	float GetButtonMashRatio(bool* IsFull);
	void AlterLocomotion(struct FVector& OriginalMovementIntention, struct FVector* AlteredMovementIntention, float* SpeedScale, class UBlendSpace** LocoBlendOverride);
};

// 0x200 (0x2E0 - 0xE0)
// Class QtnGame.QtnDamageReceptorComponent
class UQtnDamageReceptorComponent : public UActorComponent
{
public:
	uint8                                        Pad_1E62[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pOwningActor;                                    // 0xE8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnGameState*                         M_pCachedGameState;                                // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPawn*                              M_pOwningPawn;                                     // 0xF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_damageDeliveryInProgress;                        // 0x100(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1E63[0x1F];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       M_parryCosineRange;                                // 0x120(0x8)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                        M_parryScaleDistance;                              // 0x128(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1E64[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pParryingVerb;                                   // 0x130(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnRangedFloat                       M_blockCosineRange;                                // 0x138(0x8)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                        M_blockScaleDistance;                              // 0x140(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1E65[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pBlockingVerb;                                   // 0x148(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnDamageInfo                        M_lastDamageInfo;                                  // 0x150(0x88)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         R_canBeDamaged;                                    // 0x1D8(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_canDie;                                          // 0x1D9(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_canHitReact;                                     // 0x1DA(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1E66[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_damageInhibitors_ServerOnly;                     // 0x1E0(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                       M_localDamageInhibitors;                           // 0x1F0(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                         R_isDamageInhibited;                               // 0x200(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1E67[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnDamageType>>    DamageImmunities;                                  // 0x208(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UQtnDamageType>>    M_transientDamageImmunities;                       // 0x218(0x10)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnIncomingDamage;                                  // 0x228(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnParryIncomingDamage;                             // 0x238(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnBlockIncomingDamage;                             // 0x248(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnIncomingTootFart;                                // 0x258(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UQtnStatusEffect*>              R_statusEffectInstances;                           // 0x268(0x10)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnStatusEffect*>              L_statusEffectInstances;                           // 0x278(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_statusEffectInstancesNeedsRefresh;               // 0x288(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1E68[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnStatusEffectAddedEvent;                          // 0x290(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnStatusEffectRemovedEvent;                        // 0x2A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UQtnStatusEffect>>  StatusEffectImmunities;                            // 0x2B0(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x2C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        DifficultyDamageMultiplier[0x4];                   // 0x2D0(0x10)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnDamageReceptorComponent* GetDefaultObj();

	void TickGrabCooldown(class AQtnPawn* OwningPawn, float CooldownDuration, float DeltaTime, float& InOutCooldownTimer);
	void StaticApplyQtnDamage(class AActor* ActorToDamage, const struct FQtnDamageInfo& DamageInfo);
	bool ShouldAttractAimAssist(class AQtnPawn* AttackingPawn, bool FromCollateralDamage);
	void SetCanHitReact_ServerOnly(bool CanHitReact);
	void SetCanDie_ServerOnly(bool CanDie);
	void SetCanBeDamaged_ServerOnly(bool CanBeDamaged);
	void ServerIncomingPlayerDamage(const struct FQtnDamageInfo& DamageInfo);
	void RemoveStatusEffect_ServerOnly(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	void RemoveLocalDamageInhibitor(class UObject* DamageInhibitor);
	void RemoveDamageInhibitor_ServerOnly(class UObject* DamageInhibitor);
	void RemoveDamageImmunity(TSubclassOf<class UQtnDamageType> DamageTypeClass);
	void RemoveAllStatusEffects_ServerOnly();
	void QtnParryIncomingDamageEvent__DelegateSignature(class AActor* ParryingActor, struct FQtnDamageInfo& DamageInfo);
	void QtnOnStatusEffectEvent__DelegateSignature(class UQtnStatusEffect* StatusEffect);
	void QtnIncomingTootFartEvent__DelegateSignature(struct FQtnDamageInfo& DamageInfo, bool IsServer);
	void QtnIncomingDamageEvent__DelegateSignature(class UQtnDamageReceptorComponent* DamagedReceptor, struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo, bool IsServer);
	void QtnBlockIncomingDamageEvent__DelegateSignature(class AActor* blockingActor, struct FQtnDamageInfo& DamageInfo);
	void PreProcessIncomingDamage(struct FQtnDamageInfo& IncomingDamageInfo, struct FQtnHitReactionInfo& DamageSuggestedHitReact, struct FQtnDamageInfo* OutgoingDamageInfo, struct FQtnHitReactionInfo* ActualHitReact);
	void ParryWindowStart(struct FQtnRangedFloat& ScaledAngle, float ScaleDistance, class UQtnVerb* ParryingVerb);
	void ParryWindowEnd();
	void OnRep_StatusEffectInstances();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void MulticastIncomingPlayerDamage(const struct FQtnDamageInfo& DamageInfo);
	void MulticastIncomingDamage(const struct FQtnDamageInfo& DamageInfo);
	bool IsDamageInhibited();
	bool HasStatusEffect(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	bool HasDamageImmunity(TSubclassOf<class UQtnDamageType> DamageTypeClass, bool* PermanentlyImmune);
	class UQtnStatusEffect* GetStatusEffect(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	void GetParryInfo(class AActor* PotentialDamageSource, class UQtnVerb** ParryingVerb, bool* WouldParrySucceed);
	class UQtnDamageType* GetLastDamagingDamageType();
	class AQtnPawn* GetLastDamagingCulprit();
	struct FQtnDamageInfo GetLastDamageInfo();
	void GetBlockInfo(class AActor* PotentialDamageSource, class UQtnVerb** blockingVerb, bool* WouldBlockSucceed);
	TArray<class UQtnStatusEffect*> GetAllStatusEffects();
	bool CanHitReact();
	bool CanDie();
	bool CanBeDamaged();
	void BlockWindowStart(struct FQtnRangedFloat& ScaledAngle, float ScaleDistance, class UQtnVerb* blockingVerb);
	void BlockWindowEnd();
	void ApplyQtnDamage(const struct FQtnDamageInfo& DamageInfo);
	class UQtnStatusEffect* AddStatusEffect_ServerOnly(TSubclassOf<class UQtnStatusEffect> StatusEffectClass, class AQtnPawn* StatusInstigator);
	void AddLocalDamageInhibitor(class UObject* DamageInhibitor);
	void AddDamageInhibitor_ServerOnly(class UObject* DamageInhibitor);
	void AddDamageImmunity(TSubclassOf<class UQtnDamageType> DamageTypeClass);
};

// 0x40 (0x120 - 0xE0)
// Class QtnGame.QtnDamageReceptorManager
class UQtnDamageReceptorManager : public UActorComponent
{
public:
	TArray<class AActor*>                        ActorsWithDamageReceptor;                          // 0xE0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<float>                                ActorsWithDamageReceptorBoundingRadius;            // 0xF0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UQtnDamageReceptorComponent*>   DamageReceptorComponents;                          // 0x100(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AQtnPawn*>                      QtnPawns;                                          // 0x110(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnDamageReceptorManager* GetDefaultObj();

	class UQtnDamageReceptorManager* GetDamageReceptorManager(class UObject* WorldContextObject);
	TArray<class UQtnDamageReceptorComponent*> GetDamageReceptorComponents();
	TArray<class AQtnPawn*> GetAllQtnPawns();
	TArray<class AActor*> GetAllActorsWithDamageReceptors();
};

// 0x150 (0x190 - 0x40)
// Class QtnGame.QtnDamageType
class UQtnDamageType : public UDamageType
{
public:
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x40(0x28)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AQtnFXActor>               VictimFX;                                          // 0x68(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnFXActor>               VictimFXWhenIgnored;                               // 0x70(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SkipDamageNumbers;                                 // 0x78(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SkipDamageNumbersForCulpritSelf;                   // 0x79(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1E6C[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        DefaultReactionDuration;                           // 0x7C(0x4)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       RandomRotation;                                    // 0x80(0x8)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         IsATootFart;                                       // 0x88(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DoKnockdownWhenFinished;                           // 0x89(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         KnockdownHasIntro;                                 // 0x8A(0x1)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1E6D[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnStatusEffect>>  StatusEffects;                                     // 0x90(0x10)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                         IgnoreSelfDamage;                                  // 0xA0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IgnoreFriendlyFireDamage;                          // 0xA1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsDamageOverTime;                                  // 0xA2(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1E6F[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<TSubclassOf<class AActor>, TSubclassOf<class UQtnDamageReaction>> DamageReactions;                                   // 0xA8(0x50)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AActor>, struct FQtnPawnMontage> DefaultHitReactions;                               // 0xF8(0x50)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnTutorial>              AssociatedTutorial;                                // 0x148(0x8)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                          DamageTypeTag;                                     // 0x150(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                DamageColor;                                       // 0x158(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1E70[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  FriendlyName;                                      // 0x160(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0x178(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDamageType* GetDefaultObj();

	bool ShouldIgnoreBadEffects(class AQtnPawn* Culprit, class AActor* Victim, struct FQtnDamageInfo& IncomingDamageInfo);
	class UTexture2D* GetIconForUI();
	void GetDefaultHitReaction(class AActor* ActorToDamage, struct FQtnDamageInfo& IncomingDamageInfo, struct FQtnHitReactionInfo* SuggestedHitReact);
	class UQtnDamageType* GetDamageArchetype(TSubclassOf<class UQtnDamageType> DamageClass);
	void ApplyIncomingDamage(class AActor* ActorToDamage, struct FQtnDamageInfo& IncomingDamageInfo, struct FQtnDamageInfo* OutgoingDamageInfo, struct FQtnHitReactionInfo* SuggestedHitReact);
	void ApplyIncomingAttributeEffects(class AActor* ActorToDamage, struct FQtnDamageInfo& IncomingDamageInfo, struct FQtnDamageInfo* OutgoingDamageInfo);
};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnDangerManager
class UQtnDangerManager : public UObject
{
public:
	TArray<class AQtnDangerVolume*>              M_registeredDangerVolumes;                         // 0x28(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnDangerManager* GetDefaultObj();

	class AQtnDangerVolume* SpawnDangerSphere_ServerOnly(class AQtnPawn* Culprit, struct FVector& Origin, struct FQtnRangedFloat& Radii, float LifeSpan, const struct FQtnDangerParameters& DangerParameters);
	class AQtnDangerVolume* SpawnDangerCapsule_ServerOnly(class AQtnPawn* Culprit, struct FVector& Start, struct FVector& End, struct FQtnRangedFloat& Radii, float LifeSpan, const struct FQtnDangerParameters& DangerParameters);
};

// 0x18 (0x268 - 0x250)
// Class QtnGame.QtnDangerVolume
class AQtnDangerVolume : public AActor
{
public:
	class AQtnPawn*                              M_pCulprit;                                        // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       M_radii;                                           // 0x258(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnDangerParameters                  M_dangerParameters;                                // 0x260(0x3)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_1E78[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnDangerVolume* GetDefaultObj();

	void UpdateSphere_ServerOnly(struct FVector& Origin, struct FQtnRangedFloat& Radii);
	void UpdateCapsule_ServerOnly(struct FVector& Start, struct FVector& End, struct FQtnRangedFloat& Radii);
	void SetDangerParameters_ServerOnly(const struct FQtnDangerParameters& DangerParameters);
};

// 0x18 (0xF8 - 0xE0)
// Class QtnGame.QtnDebugDisplayComponent
class UQtnDebugDisplayComponent : public UActorComponent
{
public:
	uint8                                        Pad_1E79[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0xE8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDebugDisplayComponent* GetDefaultObj();

	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnDebugInterface
class IQtnDebugInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnDebugInterface* GetDefaultObj();

};

// 0x108 (0x130 - 0x28)
// Class QtnGame.QtnScreen
class UQtnScreen : public UObject
{
public:
	uint8                                        Pad_1E8C[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_isFinished;                                      // 0x29(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needsToBeUnregistered;                           // 0x2A(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1E8D[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnScreen*                            M_pParentScreen;                                   // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerController*                  M_pOwningPlayerController;                         // 0x38(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPlayerUI*                          M_pOwningPlayerUI;                                 // 0x40(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnScreenStackEnum               M_screenStackIndex;                                // 0x48(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1E8E[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<TSubclassOf<class UUserWidget>, class UUserWidget*> M_userWidgets;                                     // 0x50(0x50)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UUserWidget*                           M_pMainWidget;                                     // 0xA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UQtnScreen>, class UQtnScreen*> M_subScreens;                                      // 0xA8(0x50)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	enum class EQtnScreenPriority                ScreenPriority;                                    // 0xF8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         UnregisterUponStop;                                // 0xF9(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         ShowMouseCursor;                                   // 0xFA(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         UseVirtualCursorOnGamepad;                         // 0xFB(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         BlockBodyActions;                                  // 0xFC(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         BlockMovementControls;                             // 0xFD(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         BlockLookControls;                                 // 0xFE(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         BlockForceFeedback;                                // 0xFF(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         FreezeSimulation;                                  // 0x100(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         HideHUDUI;                                         // 0x101(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         InhibitScreenMessages;                             // 0x102(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         ConsumeGamepadSimulatedClicks;                     // 0x103(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1E8F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftClassPtr<class UUserWidget>>     UserWidgetClasses;                                 // 0x108(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                         AutoManageWidgetVisibility;                        // 0x118(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1E90[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftClassPtr<class UQtnScreen>>      SubScreenClasses;                                  // 0x120(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnScreen* GetDefaultObj();

	void UpdateVirtualCursorForScreen();
	void UnRegisterUserWidget(TSubclassOf<class UUserWidget> UserWidgetClass);
	void UnRegisterSubScreen(TSubclassOf<class UQtnScreen> ScreenClass);
	class UUserWidget* ToggleUserWidget(TSubclassOf<class UUserWidget> UserWidgetClass);
	void ToggleScreen();
	void ToggleAllUserWidgets(bool SubScreensToo);
	class UUserWidget* ShowUserWidget(TSubclassOf<class UUserWidget> UserWidgetClass);
	void ShowScreen();
	void ShowAllUserWidgets(bool SubScreensToo);
	class UUserWidget* RegisterUserWidget(TSubclassOf<class UUserWidget> UserWidgetClass);
	class UQtnScreen* RegisterSubScreen(TSubclassOf<class UQtnScreen> ScreenClass);
	void OnUIScroll(float ScrollDelta, bool FromStick);
	void OnUIScreenActionRepeat(enum class EQtnUIScreenActionEnum ScreenAction);
	void OnUIScreenActionReleased(enum class EQtnUIScreenActionEnum ScreenAction);
	void OnUIScreenActionPressed(enum class EQtnUIScreenActionEnum ScreenAction);
	void OnUINumPad(int32 Number);
	void OnUIHotKey(enum class EQtnUIHotKeyEnum HotKey);
	void OnUIBodyActionRepeat(enum class EQtnUIBodyActionEnum BodyAction);
	void OnUIBodyActionReleased(enum class EQtnUIBodyActionEnum BodyAction);
	void OnUIBodyActionPressed(enum class EQtnUIBodyActionEnum BodyAction);
	void OnScreenUnOccupied(class AQtnBodyPawn* OccupiedBodyPawn);
	void OnScreenUnInitialized();
	void OnScreenUnHijack(class AQtnPawn* HijackedPawn);
	void OnScreenTicked(float DeltaSeconds);
	void OnScreenStopped();
	void OnScreenStarted();
	void OnScreenResumed(class UQtnScreen* PreviousScreen);
	void OnScreenReadyForGameplay();
	void OnScreenPaused();
	void OnScreenOccupied(class AQtnBodyPawn* OccupiedBodyPawn, bool FirstTime);
	void OnScreenInitialized();
	void OnScreenHijack(class AQtnPawn* HijackedPawn);
	void OnInputUsageChange(bool IsUsingMouseAndKeyboard);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsUsingVisibleMouseCursor();
	bool IsUsingMouseAndKeyboard();
	bool IsScreenActive();
	bool IsScreenActionPressed(enum class EQtnUIScreenActionEnum ScreenAction);
	bool IsReadyForGameplay();
	class UUserWidget* HideUserWidget(TSubclassOf<class UUserWidget> UserWidgetClass);
	void HideScreen(bool UnRegister);
	void HideAllUserWidgets(bool SubScreensToo);
	bool GetUseVirtualCursorOnGamepad();
	class UUserWidget* GetUserWidget(TSubclassOf<class UUserWidget> UserWidgetClass);
	class UWidget* GetSubWidgetByName(TSubclassOf<class UUserWidget> ParentUserWidgetClass, class FName& WidgetName);
	class UQtnScreen* GetSubScreen(TSubclassOf<class UQtnScreen> ScreenClass, bool CheckForInheritedClasses);
	class UQtnScreen* GetScreenThatOwnsThisWidget(class UUserWidget* UserWidget, enum class EQtnScreenStackEnum ScreenStackIndex, bool CheckSubScreens);
	enum class EQtnScreenState GetScreenState();
	enum class EQtnScreenStackEnum GetScreenStackIndex();
	struct FVector2D GetRightStickInput();
	class UQtnScreen* GetParentScreen();
	class AQtnPlayerUI* GetOwningPlayerUI();
	class AQtnPlayerState* GetOwningPlayerState();
	class AQtnPlayerPawn* GetOwningPlayerPawn();
	void GetOwningPlayerInfo(class AQtnBodyPawn** OccupiedBodyPawn, class AQtnPlayerPawn** PlayerPawn, class AQtnPlayerController** PlayerController, class AQtnPlayerUI** PlayerUI, class AQtnPlayerState** QtnPlayerState, bool* IsHosting);
	class AQtnPlayerController* GetOwningPlayerController();
	class AQtnBodyPawn* GetOccupiedBodyPawn();
	struct FVector2D GetMousePosition();
	struct FVector2D GetMouseDelta();
	class UUserWidget* GetMainWidget();
	struct FVector2D GetLeftStickInput();
	struct FVector2D GetCursorPosition();
	struct FVector2D GetCursorDelta();
	class AQtnPawn* GetCurrentlyControlledPawn();
	class AQtnBodyPawn* GetCurrentlyControlledBody();
};

// 0x10 (0x140 - 0x130)
// Class QtnGame.QtnDebugScreen
class UQtnDebugScreen : public UQtnScreen
{
public:
	TArray<class UObject*>                       DebugTargetArray;                                  // 0x130(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDebugScreen* GetDefaultObj();

	void RemoveDebugElement(class UObject* TargetObject);
	void ClearDebugElements();
	void AddDebugElement(class UObject* TargetObject);
};

// 0x68 (0x90 - 0x28)
// Class QtnGame.QtnDebugWrapper
class UQtnDebugWrapper : public UObject
{
public:
	float                                        M_indentAmount;                                    // 0x28(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1EA3[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FColor>                        M_colorStack;                                      // 0x30(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFont*                                 M_pFont;                                           // 0x40(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFontRenderInfo                       M_fontRenderInfo;                                  // 0x48(0x28)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class FString                                M_prefixToNextWriteLine;                           // 0x70(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvas*                               M_pCanvas;                                         // 0x80(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1EA4[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnDebugWrapper* GetDefaultObj();

	void WriteLineWithColor(const class FString& DebugLine, const struct FLinearColor& DebugColor);
	void WriteLine(const class FString& DebugLine);
	void UnIndent();
	void PushColor(const struct FColor& DrawColor);
	void PopColor();
	bool IsDisplayOn(class FName DisplayName);
	void Indent();
	void GetTextSize(const class FString& Label, struct FVector2D* TextSize, const struct FVector2D& TextScale);
	void ForceNewColumn();
	void DrawVerticalGauge(const class FString& Label, struct FVector& WorldOrigin, const struct FVector2D& GaugeSize, float FillRatio, TArray<float>& Notches, const struct FLinearColor& GaugeColor);
	void DrawTextInWorld(struct FVector& WorldLocation, const class FString& Label);
	void DrawTextAtScreenLocation(const struct FVector2D& ScreenLocation, const class FString& Label, const struct FVector2D& TextScale);
	void DrawSphereInWorld(struct FVector& Center, float Radius, float LifeTime);
	void DrawPointInWorld(struct FVector& Position, float Size, float LifeTime);
	void DrawMeshSocketsInWorld(class UMeshComponent* PMeshComponent, float Size, float LifeTime);
	void DrawLineInWorld(struct FVector& Start, struct FVector& End, float LifeTime);
	void DrawCylinderInWorld(struct FVector& StartLocation, struct FVector& EndLocation, float Radius, float LifeTime);
	void DrawCapsuleInWorld(struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, float LifeTime);
	void DrawBoxInWorld(struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, bool Solid, float LifeTime);
	void DrawArrowInWorld(struct FVector& WorldOrigin, struct FVector& WorldDestination, float LifeTime);
	void ConvertWorldToScreen(struct FVector& WorldLocation, struct FVector2D* ScreenPosition, bool* IsBehind);
	void ConvertScreenToWorld(struct FVector2D& ScreenPosition, struct FVector* WorldLocation, struct FVector* WorldDirection);
	void AppendPrefixToNextWriteLine(const class FString& PrefixToAppend);
};

// 0x18 (0x280 - 0x268)
// Class QtnGame.QtnDecalComponent
class UQtnDecalComponent : public UDecalComponent
{
public:
	FMulticastInlineDelegateProperty_            OnDecalFinished;                                   // 0x268(0x10)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_1EA5[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnDecalComponent* GetDefaultObj();

};

// 0x0 (0x78 - 0x78)
// Class QtnGame.QtnDestroyPartySessionCallbackProxy
class UQtnDestroyPartySessionCallbackProxy : public UDestroySessionCallbackProxy
{
public:

	static class UClass* StaticClass();
	static class UQtnDestroyPartySessionCallbackProxy* GetDefaultObj();

	class UQtnDestroyPartySessionCallbackProxy* QtnDestroyPartySession(class UObject* WorldContextObject, class APlayerController* PlayerController);
};

// 0x180 (0x260 - 0xE0)
// Class QtnGame.QtnDevCheatsComponent
class UQtnDevCheatsComponent : public UActorComponent
{
public:
	class AQtnPlayerPawn*                        M_pOwningPlayerPawn;                               // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inputBinded;                                     // 0xE8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_plantNPCs;                                       // 0xE9(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_godNPCs;                                         // 0xEA(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_godPlayers;                                      // 0xEB(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_buddhaPlayers;                                   // 0xEC(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_buddhaNPCs;                                      // 0xED(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_aiPacifist;                                      // 0xEE(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_aiNinjaMode;                                     // 0xEF(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_aiBlind;                                         // 0xF0(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_aiDeaf;                                          // 0xF1(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_aiNumb;                                          // 0xF2(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_botsDisabledByCheat;                             // 0xF3(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_telemetryCheatProtection;                        // 0xF4(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_aiJobsDisabled;                                  // 0xF5(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1EC8[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        R_aiTimeDilation;                                  // 0xF8(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_isDebuggingAI;                                   // 0xFC(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1EC9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnServerDiagnosticsInfo             R_serverDiagnosticsInfo;                           // 0x100(0x20)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                          M_statsTimer;                                      // 0x120(0x8)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_notifiedGameStateOfDevCheats;                    // 0x128(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1ECA[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnCameraBehavior>        FlyCam;                                            // 0x130(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isDoingCinematicFlyThrough;                      // 0x138(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1ECB[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnDamageType>            NukeDamage;                                        // 0x140(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_bIsFootageCaptureMode;                           // 0x148(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_bWasRoboVoiceEnabled;                            // 0x149(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1ECC[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_cachedMusicVolume;                               // 0x14C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnDamageType>            SlapDamage;                                        // 0x150(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnDamageType>            FartDamage;                                        // 0x158(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                            FartSound;                                         // 0x160(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnStatusEffect>          FireStatus;                                        // 0x168(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnPawnMontage                       DanceAction;                                       // 0x170(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class USoundBase*                            NoiseSoundAsset;                                   // 0x180(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UQtnVerb>                LaserSwordCheat;                                   // 0x188(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UQtnVerb>                VampireBatCheat;                                   // 0x1B0(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                    DebugFlagClass;                                    // 0x1D8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        DebugFlagInstances_ServerOnly;                     // 0x1E0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TSet<class AActor*>                          M_HiddenActors;                                    // 0x1F0(0x50)(Transient, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class AQtnBodyPawn>>    NPCsToSpawn;                                       // 0x240(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDataTable*                            EnemyUpgradeMasterDataTable;                       // 0x250(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnTeam>                  MonsterTeam;                                       // 0x258(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDevCheatsComponent* GetDefaultObj();

	void ServerUploadTelemetryLog();
	void ServerUpdateDebuggingAI(bool IsDebuggingAI);
	void ServerToggleTelemetryCheatProtection();
	void ServerStopTelemetry();
	void ServerStartTelemetry();
	void ServerSetEnemyCheat(class AQtnBodyPawn* PTargetBodyPawn, TSubclassOf<class UQtnVerb> VerbClass);
	void ServerSendCheatMsg(class FString& CheatMsg);
	void ServerResurrect(class AQtnPawn* PTargetPawn);
	void ServerQtnUnsetSpeakerTypeOverride(class AActor* PSpeaker);
	void ServerQtnToggleSuppression(class AQtnPawn* PTargetedPawn);
	void ServerQtnToggleCombatInhibitor();
	void ServerQtnToggleBossThreat();
	void ServerQtnToggleAllyBots();
	void ServerQtnToggleAIJobs();
	void ServerQtnToggleAICognition();
	void ServerQtnTimeScaleHalf();
	void ServerQtnTimeScaleDouble();
	void ServerQtnTimeResume();
	void ServerQtnSwitchTeams(class AQtnPawn* PTargetedPawn);
	void ServerQtnSummonTarget(class AActor* PTargetedActor);
	void ServerQtnSummonAllPlayers();
	void ServerQtnSubtractFitcoin(class AQtnBodyPawn* TargetPawn, int32 QuantityToSubtract);
	void ServerQtnSubtractDarkMatter(class AQtnBodyPawn* TargetPawn, int32 QuantityToSubtract);
	void ServerQtnStepMode();
	void ServerQtnSpawnNPCCommon(TSubclassOf<class AQtnBodyPawn> BodyClassToSpawn, int32 NumToSpawn);
	void ServerQtnSpawnDangerSphere(float Radius);
	void ServerQtnSpawnDangerCapsule(float Length, float Radius);
	void ServerQtnSlapTarget(class AActor* PSlapVictim, int32 DamageAmount);
	void ServerQtnSetWalkSpeed(class AQtnPawn* PTargetedPawn, float WalkSpeed);
	void ServerQtnSetTimeScale(float TimeScale);
	void ServerQtnSetTargetScale(class AActor* PTargetedActor, float TargetScale);
	void ServerQtnSetSpeakerTypeOverride(class AActor* PSpeaker, const struct FGameplayTag& SpeakerType);
	void ServerQtnSetOnFire(class AActor* PVictim);
	void ServerQtnSetHoverHeight(class AQtnPawn* PTargetedPawn, float HoverHeight);
	void ServerQtnSeamlessTravel(class FName MapName);
	void ServerQtnRunProgress_Reset();
	void ServerQtnRunProgress_ReadyForGameplay();
	void ServerQtnRunProgress_EnterWorld();
	void ServerQtnRunProgress_Checkpoint();
	void ServerQtnRequestVerb(class AQtnPawn* PTargetedPawn, int32 VerbIndex);
	void ServerQtnPlaySound(class USoundBase* SoundAsset);
	void ServerQtnPlayScriptedVOWithCallout(const struct FGameplayTag& ScriptedIdGameplayTag, class AActor* PScriptedVOSpeaker, bool PreferToPlayOnBody, int32 PrescribedVariant);
	void ServerQtnPlayScriptedVO(const struct FGameplayTag& ScriptedIdGameplayTag, class AActor* PScriptedVOSpeaker, bool PreferToPlayOnBody, int32 PrescribedVariant);
	void ServerQtnPlayersOnly();
	void ServerQtnPlantNPCs();
	void ServerQtnNukeNPCs();
	void ServerQtnMarkAllNPCsForCleanup();
	void ServerQtnLaunch(class AQtnPawn* Victim, const struct FVector& LaunchForce);
	void ServerQtnKnockback(class AQtnPawn* Victim, float HorizontalDistance, float ApexHeight);
	void ServerQtnGodPlayers();
	void ServerQtnGodNPCs();
	void ServerQtnGetOverHere(class AQtnBodyPawn* PTargetBody);
	void ServerQtnFart(int32 DamageAmount);
	void ServerQtnDestroyNPCs(TArray<class AQtnBodyPawn*>& OffScreenNPCs);
	void ServerQtnDestroyAllPawnsMarkedForCleanup();
	void ServerQtnDestroyAllNPCs();
	void ServerQtnDestroyAllDeadPawns();
	void ServerQtnDestroyActor(class AActor* PActor);
	void ServerQtnDance(class AQtnBodyPawn* PVictim, float Duration);
	void ServerQtnBuddhaPlayers();
	void ServerQtnBuddhaNPCs();
	void ServerQtnBoo();
	void ServerQtnAITimeDilation(float TimeDilation);
	void ServerQtnAIPacifist();
	void ServerQtnAINumb();
	void ServerQtnAINinjaMode();
	void ServerQtnAIDeaf();
	void ServerQtnAIBlind();
	void ServerQtnAddToiletPaper(class AQtnBodyPawn* TargetPawn, int32 QuantityToAdd);
	void ServerQtnAddFitcoin(class AQtnBodyPawn* TargetPawn, int32 QuantityToAdd);
	void ServerQtnAddEnemyUpgrade(class FName UpgradeIdentity);
	void ServerQtnAddDarkMatter(class AQtnBodyPawn* TargetPawn, int32 QuantityToAdd);
	void ServerPlaceFlag(struct FVector& Location, class FString& Message);
	void ServerKillPawn(class AQtnPawn* PVictim);
	void ServerClearAllFlags();
	void QtnUnsetSpeakerTypeOverride();
	void QtnUnlocks_UnlockAll();
	void QtnUnlocks_Unlock(class FName UnlocksDataTableRowName);
	void QtnUnlocks_Reset();
	void QtnToggleSuppression();
	void QtnToggleRobovoice();
	void QtnToggleOutline();
	void QtnToggleNameplates();
	void QtnToggleMotionBlur();
	void QtnToggleLocalActiveCutscene(bool DoWorldCleanup);
	void QtnToggleHijack();
	void QtnToggleGhost();
	void QtnToggleFootageCaptureMode();
	void QtnToggleFly();
	void QtnToggleDamageNumberSystem();
	void QtnToggleCombatInhibitor();
	void QtnToggleBossThreat();
	void QtnToggleBodyVisibility();
	void QtnToggleAllyBots();
	void QtnToggleAIJobs();
	void QtnToggleAICognition();
	void QtnTelemetry_ToggleCheatProtection();
	void QtnTelemetry_TakeLevelScreenshot(int32 ImageSize, float XMid, float YMid, float Range);
	void QtnTelemetry_ServerUploadLog();
	void QtnTelemetry_ServerStop();
	void QtnTelemetry_ServerStart();
	void QtnSwitchTeams();
	void QtnSwitchMatchmakingMode();
	void QtnSummonTarget();
	void QtnSummonAllPlayers();
	void QtnSubtractFitcoin(int32 QuantityToSubtract);
	void QtnSubtractDarkMatter(int32 QuantityToSubtract);
	void QtnStopVO();
	void QtnSpawnNPC(int32 NumToSpawn);
	void QtnSpawnDangerSphere(float Radius);
	void QtnSpawnDangerCapsule(float Length, float Radius);
	void QtnSlapTarget(int32 DamageAmount);
	void QtnShowInviteUI();
	void QtnSetWalkSpeed(float WalkSpeed);
	void QtnSetTimeScale(float TimeScale);
	void QtnSetTextureQuality(int32 Index);
	void QtnSetTargetScale(float TargetScale);
	void QtnSetSpeakerTypeOverride(const class FString& SpeakerType);
	void QtnSetShadowQuality(int32 Index);
	void QtnSetOnFire();
	void QtnSetLocalizedAudioLanguage(const struct FGameplayTag& Language);
	void QtnSetHoverHeight(float HoverHeight);
	void QtnSetFogQuality(int32 Index);
	void QtnSetAntialiasingQuality(int32 Index);
	void QtnSetAnimFramerate(int32 FramesPerSecond);
	void QtnSeamlessTravel(class FName MapName);
	void QtnSaveProgressData();
	void QtnSaveOptionsData();
	void QtnRunUpgradeRarityTest(int32 NumberOfRollsInTest);
	void QtnRunProgress_Reset();
	void QtnRunProgress_ReadyForGameplay();
	void QtnRunProgress_EnterWorld();
	void QtnRunProgress_Checkpoint();
	void QtnRunLootStatsTestOnDebugTarget(int32 NumTimesToRoll);
	void QtnRunEnemyUpgradeRollTest(int32 NumberOfRollsInTest);
	void QtnResurrect();
	void QtnResetProgressData();
	void QtnResetOptionsData();
	void QtnResetNarrativeThreads();
	void QtnResetAllTutorials();
	void QtnResetAchievements();
	void QtnRequestVerb(int32 VerbIndex);
	void QtnRemoveAllInputContexts();
	void QtnPlayScriptedVOWithCallout(const class FString& ScriptedId, bool PreferToPlayOnBody, int32 PrescribedVariant);
	void QtnPlayScriptedVO(const class FString& ScriptedId, bool PreferToPlayOnBody, int32 PrescribedVariant);
	void QtnPlayersOnly();
	void QtnPlantNPCs();
	void QtnOpenAllLootContainers();
	void QtnNukeNPCs();
	void QtnMarkAllNPCsForCleanup();
	void QtnLoadProgressData();
	void QtnLoadOptionsData();
	void QtnListEnemyUpgrades();
	void QtnLaunch(float X, float Y, float Z);
	void QtnKnockback(float HorizontalDistance, float ApexHeight);
	void QtnKillPawn();
	void QtnGrantAchievement(class FName AchievementID);
	void QtnGodPlayers();
	void QtnGodNPCs();
	void QtnGetOverHere();
	void QtnGenerateAINoise();
	void QtnFlagNote(class FString& Message);
	void QtnFlag();
	void QtnFart(int32 DamageAmount);
	void QtnEquipRandomCosmetic();
	void QtnEnemyCheatVampireBat();
	void QtnEnemyCheatLaserSword();
	void QtnDumpFXPoolingStats();
	void QtnDumpCharacterStats();
	void QtnDumpActorPoolingStats();
	void QtnDestroyDebugTarget();
	void QtnDestroyAllPawnsMarkedForCleanup();
	void QtnDestroyAllOffscreenNPCs();
	void QtnDestroyAllNPCs();
	void QtnDestroyAllNontargetedNPCs();
	void QtnDestroyAllDeadPawns();
	void QtnDance(float Duration);
	void QtnClearFlags();
	void QtnCleanUpLootItems();
	void QtnBuddhaPlayers();
	void QtnBuddhaNPCs();
	void QtnBoo();
	void QtnAITimeDilation(float TimeDilation);
	void QtnAIPacifist();
	void QtnAINumb();
	void QtnAINinjaMode();
	void QtnAIDeaf();
	void QtnAIBlind();
	void QtnAddToiletPaper(int32 QuantityToAdd);
	void QtnAddFitcoin(int32 QuantityToAdd);
	void QtnAddEnemyUpgrade(class FName UpgradeIdentity);
	void QtnAddDarkMatter(int32 QuantityToAdd);
	void QtnActorVisibility(const class FString& Params);
	void OnSpawnNPC_ServerOnly(class AQtnBodyPawn* SpawnedNPC);
	void OnQtnToggleFootageCaptureModeEvent(bool IsInFootageCaptureMode);
	void NinjaMode();
	void MulticastSendCheatMsg(class FString& CheatMsg);
	void MulticastQtnSetWalkSpeed(class AQtnPawn* PTargetedPawn, float WalkSpeed);
	void MulticastQtnSetTargetScale(class AActor* PTargetedActor, float TargetScale);
	void MulticastQtnPlaySound(class USoundBase* SoundAsset);
	void MulticastQtnKnockback(class AQtnPawn* Victim, float HorizontalDistance, float ApexHeight);
	void God();
	void DoCheatNotify(const class FString& Msg);
	void Buddha();
};

// 0x38 (0x288 - 0x250)
// Class QtnGame.QtnDevNote
class AQtnDevNote : public AActor
{
public:
	uint8                                        Pad_1ED8[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnTextRenderComponent*               M_pTextRenderComponent;                            // 0x258(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                DevText;                                           // 0x260(0x10)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                DevComment;                                        // 0x270(0x10)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ShowInPIE;                                         // 0x280(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1ED9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        RelevantDistance;                                  // 0x284(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnDevNote* GetDefaultObj();

};

// 0x18 (0x40 - 0x28)
// Class QtnGame.QtnDisplayDebugPage
class UQtnDisplayDebugPage : public UObject
{
public:
	class FString                                M_title;                                           // 0x28(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                M_pageHelpTextColor;                               // 0x38(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_isTargeted;                                      // 0x3C(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1EDC[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPage* GetDefaultObj();

	class FString GetPageHelpText(class AQtnPlayerPawn* POwningPlayerPawn, class AActor* PDebugTargetActor);
};

// 0x8 (0x48 - 0x40)
// Class QtnGame.QtnDisplayDebugPageActorBase
class UQtnDisplayDebugPageActorBase : public UQtnDisplayDebugPage
{
public:
	bool                                         M_alreadyHasWorldText;                             // 0x40(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1EDE[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageActorBase* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageActors
class UQtnDisplayDebugPageActors : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageActors* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageAI
class UQtnDisplayDebugPageAI : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAI* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageAICombat
class UQtnDisplayDebugPageAICombat : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAICombat* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageAINoise
class UQtnDisplayDebugPageAINoise : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAINoise* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageAIOverview
class UQtnDisplayDebugPageAIOverview : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAIOverview* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageAIPatrols
class UQtnDisplayDebugPageAIPatrols : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAIPatrols* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageAISense
class UQtnDisplayDebugPageAISense : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAISense* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageAISystems
class UQtnDisplayDebugPageAISystems : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAISystems* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageAITickets
class UQtnDisplayDebugPageAITickets : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageAITickets* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageBodyState
class UQtnDisplayDebugPageBodyState : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageBodyState* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageCamera
class UQtnDisplayDebugPageCamera : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageCamera* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageCosmetics
class UQtnDisplayDebugPageCosmetics : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageCosmetics* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageGameInstance
class UQtnDisplayDebugPageGameInstance : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageGameInstance* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageGlobal
class UQtnDisplayDebugPageGlobal : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageGlobal* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageInventory
class UQtnDisplayDebugPageInventory : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageInventory* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageMissionProgress
class UQtnDisplayDebugPageMissionProgress : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageMissionProgress* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageNavMovement
class UQtnDisplayDebugPageNavMovement : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageNavMovement* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPagePlayer
class UQtnDisplayDebugPagePlayer : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPagePlayer* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageRPGQuest
class UQtnDisplayDebugPageRPGQuest : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageRPGQuest* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnDisplayDebugPageRPGStats
class UQtnDisplayDebugPageRPGStats : public UQtnDisplayDebugPageActorBase
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageRPGStats* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageSaveLoad
class UQtnDisplayDebugPageSaveLoad : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageSaveLoad* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageSkirmishes
class UQtnDisplayDebugPageSkirmishes : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageSkirmishes* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageSpokes
class UQtnDisplayDebugPageSpokes : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageSpokes* GetDefaultObj();

};

// 0x0 (0x40 - 0x40)
// Class QtnGame.QtnDisplayDebugPageUI
class UQtnDisplayDebugPageUI : public UQtnDisplayDebugPage
{
public:

	static class UClass* StaticClass();
	static class UQtnDisplayDebugPageUI* GetDefaultObj();

};

// 0xA8 (0xD0 - 0x28)
// Class QtnGame.QtnDLCInfo
class UQtnDLCInfo : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>             UIImage;                                           // 0x28(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                  UIDisplayName;                                     // 0x50(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  UIDescription;                                     // 0x68(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint32                                       DLCSteamAppID;                                     // 0x80(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1EEB[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                DLCXSXContentID;                                   // 0x88(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                DLCPS5EntitlementID;                               // 0x98(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                       DLCSwitchContentID;                                // 0xA8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1EEC[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftClassPtr<class UQtnWorldCustomization>> WorldCustomizationDLC;                             // 0xB0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                  M_localizedAudioLanguages;                         // 0xC0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDLCInfo* GetDefaultObj();

	class UTexture2D* GetImageForUI();
	class UQtnDLCInfo* GetDLCInfoArchetype(TSubclassOf<class UQtnDLCInfo> DlcInfoClass);
};

// 0x88 (0xB0 - 0x28)
// Class QtnGame.QtnDLCManager
class UQtnDLCManager : public UObject
{
public:
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnDLCInfo>, class UQtnDLCInfo*> M_confirmedDLCPurchases;                           // 0x30(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnDLCInfo>>       M_simulatedDLCPurchases_DevOnly;                   // 0x80(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1EF0[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftClassPtr<class UQtnDLCInfo>>     SupportedDLC;                                      // 0xA0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnDLCManager* GetDefaultObj();

	bool ShouldShowDLCStoreLink(int32* AvailableDLC, int32* PurchasedDLC);
	void RemoveSimulatedDLCPurchase_DEVONLY(TSubclassOf<class UQtnDLCInfo> DlcInfo);
	void RefreshPurchasedDLC();
	void OpenDLCStorePage(TSubclassOf<class UQtnDLCInfo> DlcInfo);
	bool HasPurchasedDLC(TSubclassOf<class UQtnDLCInfo> DlcInfo);
	void AddSimulatedDLCPurchase_DEVONLY(TSubclassOf<class UQtnDLCInfo> DlcInfo);
};

// 0x0 (0x250 - 0x250)
// Class QtnGame.QtnReplicatedActor
class AQtnReplicatedActor : public AActor
{
public:

	static class UClass* StaticClass();
	static class AQtnReplicatedActor* GetDefaultObj();

	void OnQtnReadyForGameplay();
	void HandleSimPause(bool Paused);
	void HandleGameStateReadyForGameplay(class AQtnPlayerController* LocalPlayerController, class AQtnPlayerUI* LocalPlayerUI, class AQtnBodyPawn* LocalOccupiedBodyPawn);
};

// 0x90 (0x2E0 - 0x250)
// Class QtnGame.QtnDoor
class AQtnDoor : public AQtnReplicatedActor
{
public:
	uint8                                        Pad_1EFF[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UStaticMeshComponent*>          M_pStaticMeshComponents;                           // 0x258(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                  DoorFrame;                                         // 0x268(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                DoorPanel;                                         // 0x270(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                         FrontHandle;                                       // 0x278(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                         BackHandle;                                        // 0x280(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnFrobbableComponent*                FrontFrobbable;                                    // 0x288(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnFrobbableComponent*                BackFrobbable;                                     // 0x290(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnNavLinkDoorComponent*              DoorNavLink;                                       // 0x298(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavModifierComponent*                 NavModifier;                                       // 0x2A0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnDoorState                     InitialDoorState;                                  // 0x2A8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnDoorState                     R_logicalDoorState;                                // 0x2A9(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnDoorState                     L_logicalDoorState;                                // 0x2AA(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1F01[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPawn*                              R_pLastUsingPawn;                                  // 0x2B0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               M_boundsCenter;                                    // 0x2B8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        FrobDistance;                                      // 0x2C4(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         LockedForAIs;                                      // 0x2C8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         LockedForPlayers;                                  // 0x2C9(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsTrapDoor;                                        // 0x2CA(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F03[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            LogicalDoorStateChangedEvent;                      // 0x2D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnDoor* GetDefaultObj();

	void SetLogicalDoorState_ServerOnly(enum class EQtnDoorState LogicalDoorState, class AQtnPawn* UsingPawn);
	void OnRep_LogicalDoorState();
	void OnLogicalDoorStateChange(enum class EQtnDoorState PreviousLogicalState, enum class EQtnDoorState NewLogicalState, class AQtnPawn* UsingPawn);
	bool IsDoorClosed();
	void HandleFrontFrob(class UQtnFrobbableComponent* ThisFrobbable, class AQtnBodyPawn* FrobbingPawn, bool IsServer);
	void HandleBackFrob(class UQtnFrobbableComponent* ThisFrobbable, class AQtnBodyPawn* FrobbingPawn, bool IsServer);
	enum class EQtnDoorState DetermineDirectionOfOpening(class AQtnPawn* UsingPawn);
};

// 0x180 (0xCB0 - 0xB30)
// Class QtnGame.QtnMovementComponent
class UQtnMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                        Pad_1F0F[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnAttributeComponent*                M_pAttributeComponent;                             // 0xB38(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pOwningPawn;                                     // 0xB40(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_maxSpeedCausers_Local;                           // 0xB48(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_maxSpeedCausersServerOnly;                       // 0xB98(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_fallSpeedCausersServerOnly;                      // 0xBE8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_ledgeInhibitors;                                 // 0xC38(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                        M_originalGroundFriction;                          // 0xC48(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F10[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_slipperyCausers;                                 // 0xC50(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                        M_maxSpeedMultiplier_Local;                        // 0xC60(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_maxSpeedMultiplier;                              // 0xC64(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_fallSpeedMultiplier;                             // 0xC68(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_cachedMaxSpeed;                                  // 0xC6C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_hoverHeight;                                     // 0xC70(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isOnIce;                                         // 0xC74(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isInMud;                                         // 0xC75(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F11[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_elapsedTimeOnGround;                             // 0xC78(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         ImmuneToIceSliding;                                // 0xC7C(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F12[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        IceSpeedMultiplier;                                // 0xC80(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F13[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            BlockedByLedgeEvent;                               // 0xC88(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                  AggregationKey;                                    // 0xC98(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        RoundRobinBucketSize;                              // 0xCA0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F14[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMovementComponent* GetDefaultObj();

	void SetReplicatedMaxSpeedMultiplier_ServerOnly(class UObject* MaxSpeedCauser, float MaxSpeedMultiplier);
	void SetLocalMaxSpeedMultiplier(class UObject* MaxSpeedCauser, float MaxSpeedMultiplier);
	void SetHoverHeight_ServerOnly(float HoverHeight);
	void SetFallSpeedMultiplier_ServerOnly(class UObject* FallSpeedCauser, float FallSpeedMultiplier);
	void RemoveSlipperyCauser(class UObject* SlipperyCauser);
	void RemoveReplicatedMaxSpeedMultiplier_ServerOnly(class UObject* MaxSpeedCauser);
	void RemoveLocalMaxSpeedMultiplier(class UObject* MaxSpeedCauser);
	void RemoveLedgeInhibitor(class UObject* LedgeInhibitor);
	void RemoveFallSpeedMultiplier_ServerOnly(class UObject* FallSpeedCauser);
	void QtnOnBlockedByLedge__DelegateSignature(class AQtnPawn* blockedPawn);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsOnIce();
	bool IsBeingSlowedDownByTerrain();
	float GetMaxSpeedMultiplier();
	float GetHoverHeight();
	float GetElapsedTimeOnGround();
	void EnableNavWalkingMovement();
	void DisableNavWalkingMovement();
	void AddSlipperyCauser(class UObject* SlipperyCauser);
	void AddLedgeInhibitor(class UObject* LedgeInhibitor);
};

// 0x0 (0xCB0 - 0xCB0)
// Class QtnGame.QtnDroneMovementComponent
class UQtnDroneMovementComponent : public UQtnMovementComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnDroneMovementComponent* GetDefaultObj();

};

// 0x0 (0xAD0 - 0xAD0)
// Class QtnGame.QtnDronePawn
class AQtnDronePawn : public AQtnPawn
{
public:

	static class UClass* StaticClass();
	static class AQtnDronePawn* GetDefaultObj();

};

// 0x0 (0xE0 - 0xE0)
// Class QtnGame.QtnEditorHelperComponent
class UQtnEditorHelperComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnEditorHelperComponent* GetDefaultObj();

	struct FLinearColor GetVisualizationColor(class AActor* RelevantActor, bool ForLines);
	void GatherRelevantActors(TArray<class AActor*>* RelevantActors);
	void GatherErrors(TArray<class FString>* ErrorMsgs);
	class FString BuildTextForLabel();
};

// 0x88 (0xB0 - 0x28)
// Class QtnGame.QtnEditorUtilities
class UQtnEditorUtilities : public UObject
{
public:
	class FString                                VOToolAPIKey;                                      // 0x28(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolGetLinesURL;                                 // 0x38(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolAccessKey;                                   // 0x48(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolSecretKey;                                   // 0x58(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolSyncTimeFile;                                // 0x68(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolTempDownloadDir;                             // 0x78(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolRawAudioDir;                                 // 0x88(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                VOToolRawLipsyncDir;                               // 0x98(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        EditorToastDuration;                               // 0xA8(0x4)(BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F1B[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnEditorUtilities* GetDefaultObj();

	int32 StaticGetPIEArc();
	class UTexture2D* SaveRenderTargetAsTexture2DEditorOnly(class UTextureRenderTarget2D* RenderTarget, const class FString& InName, enum class ETextureCompressionSettings CompressionSettings, enum class ETextureMipGenSettings MipSettings, enum class ETextureGroup InTextureGroup, bool bSRGB);
	void DoEditorToastPassFail(const class FString& Message, bool Success);
	void DoEditorToast(const class FString& Message);
};

// 0x58 (0x88 - 0x30)
// Class QtnGame.QtnEnemyUpgradeHandlerSubsystem
class UQtnEnemyUpgradeHandlerSubsystem : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnEnemyUpgradeAddedEvent;                          // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEnemyUpgradesResetEvent;                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEnemyUpgradesLevelChangeEvent;                   // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UQtnUpgrade>>       CurrentEnemyUpgrades;                              // 0x60(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FQtnRolledUpgradeData>         EnemyUpgradeValues;                                // 0x70(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                        MaximumEnemyUpgradesAllowed;                       // 0x80(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F22[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnEnemyUpgradeHandlerSubsystem* GetDefaultObj();

	void SelectMapEnemyUpgrades(class UDataTable* UpgradeTable, int32 Count, bool ResetPrevious);
	TSubclassOf<class UQtnUpgrade> RollNewEnemyUpgradeDoNotApply(class UDataTable* UpgradeTable);
	void RollNewEnemyUpgrade(class UDataTable* UpgradeTable, bool AnnounceUpgrade);
	struct FQtnRolledUpgradeData RollEnemyUpgradeLevelData(TSubclassOf<class UQtnUpgrade> SelectedUpgrade);
	void ResetEnemyUpgradeProgress();
	void RemoveEnemyUpgrade(TSubclassOf<class UQtnUpgrade> EnemyUpgradeToRemove);
	void ProcessSpawnedEnemy(class AQtnBodyPawn* TargetEnemy);
	class UQtnEnemyUpgradeHandlerSubsystem* GetEnemyUpgradeHandlerSubsystem(class UObject* WorldContextObject);
	bool EnemyUpgradeIsInList(TSubclassOf<class UQtnUpgrade> UpgradeClass);
	void AddEnemyUpgrade(TSubclassOf<class UQtnUpgrade> EnemyUpgradeToAdd, bool AddEnemyUpgradeValues);
};

// 0x10 (0xD80 - 0xD70)
// Class QtnGame.QtnEngine
class UQtnEngine : public UGameEngine
{
public:
	TArray<struct FQtnLogRedirect>               LogRedirects;                                      // 0xD70(0x10)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnEngine* GetDefaultObj();

};

// 0x8 (0x200 - 0x1F8)
// Class QtnGame.QtnEnvQueryTestFormationSpread
class UQtnEnvQueryTestFormationSpread : public UEnvQueryTest
{
public:
	bool                                         BasedOnAngle;                                      // 0x1F8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F23[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnEnvQueryTestFormationSpread* GetDefaultObj();

};

// 0x8 (0xE8 - 0xE0)
// Class QtnGame.QtnItemComponent
class UQtnItemComponent : public UActorComponent
{
public:
	class AQtnItem*                              M_pOwningItem;                                     // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnItemComponent* GetDefaultObj();

};

// 0xE0 (0x1C8 - 0xE8)
// Class QtnGame.QtnEquippableComponent
class UQtnEquippableComponent : public UQtnItemComponent
{
public:
	bool                                         M_wasEquipped;                                     // 0xE8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_isEquipped;                                      // 0xE9(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F25[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerbComponent*                     M_pVerbComponent;                                  // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnCameraBehavior>        CameraBehaviorWhileEquipped;                       // 0xF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnEquipSlot                     EquipSlot;                                         // 0x100(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F26[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  EquippedSocket;                                    // 0x104(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  UnEquippedSocket;                                  // 0x10C(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F27[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USoundBase*                            EquipSoundAsset;                                   // 0x118(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                            UnEquipSoundAsset;                                 // 0x120(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                            UsePressSoundAsset;                                // 0x128(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                            UseReleaseSoundAsset;                              // 0x130(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                            UseCancelSoundAsset;                               // 0x138(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEquipEvent;                                      // 0x140(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnUnEquipEvent;                                    // 0x150(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FQtnPawnMontage                       EquipAction;                                       // 0x160(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpace*                           LocoBlendPerBodyStance[0x5];                       // 0x170(0x28)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnPawnMontage                       ActionWhileEquipped;                               // 0x198(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnPawnMontage                       UnEquipAction;                                     // 0x1A8(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                            EquippedReticleTexture;                            // 0x1B8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                            UseAffordanceReticleTexture;                       // 0x1C0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnEquippableComponent* GetDefaultObj();

	void ServerSetEquipped(bool IsEquipped);
	void OnUnEquip(class AQtnBodyPawn* bodyPawn);
	void OnRep_isEquipped();
	void OnEquip(class AQtnBodyPawn* bodyPawn);
	bool IsRanged();
	bool IsEquipped();
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnEventContextProviderInterface
class IQtnEventContextProviderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnEventContextProviderInterface* GetDefaultObj();

	void AddEventContext(struct FQtnEventMessage& EventMessage);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnEventHandlerLog
class UQtnEventHandlerLog : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnEventHandlerLog* GetDefaultObj();

};

// 0x18 (0x40 - 0x28)
// Class QtnGame.QtnEventHandlerMissionStats
class UQtnEventHandlerMissionStats : public UObject
{
public:
	uint8                                        Pad_1F2C[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnMissionStats>              R_perPlayerMissionStats;                           // 0x30(0x10)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnEventHandlerMissionStats* GetDefaultObj();

	void SetMissionStats(struct FQtnMissionStats& NewMissionStats);
	float GetStatForPlayer(struct FUniqueNetIdRepl& PlayerId, enum class EQtnMissionStatsType StatType);
	struct FQtnMissionStats GetMissionStatsForPlayer(struct FUniqueNetIdRepl& PlayerId);
	void GetFillStatTypesForPlayer(struct FUniqueNetIdRepl& PlayerId, TArray<enum class EQtnMissionStatsType>& InBestStats, TArray<enum class EQtnMissionStatsType>* OutFillStats);
	class UQtnEventHandlerMissionStats* GetEventHandlerMissionStatsInstance(class UObject* WorldContextObject);
	void GetBestStatTypesForPlayer(struct FUniqueNetIdRepl& PlayerId, int32 NumMaxStats, TArray<enum class EQtnMissionStatsType>* OutBestStats);
};

// 0x90 (0xB8 - 0x28)
// Class QtnGame.QtnEventHandlerTelemetry
class UQtnEventHandlerTelemetry : public UObject
{
public:
	uint8                                        Pad_1F2D[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 TelemetryStandardContexts;                         // 0x30(0x20)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> TelemetryContextsMap;                              // 0x50(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F2E[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnEventHandlerTelemetry* GetDefaultObj();

};

// 0x68 (0x90 - 0x28)
// Class QtnGame.QtnEventManager
class UQtnEventManager : public UObject
{
public:
	uint8                                        Pad_1F48[0x68];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnEventManager* GetDefaultObj();

	void StaticSetEventContextVector(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, struct FVector& ContextValue);
	void StaticSetEventContextObject(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, class UObject* ContextValue);
	void StaticSetEventContextName(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, class FName& ContextValue);
	void StaticSetEventContextInt(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, int32 ContextValue);
	void StaticSetEventContextGameplayTag(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, struct FGameplayTag& ContextValue);
	void StaticSetEventContextFloat(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, float ContextValue);
	void StaticSetEventContextClass(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, class UClass* ContextValue);
	void StaticSetEventContextBool(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, bool ContextValue);
	struct FQtnEventMessage StaticMakeEventMessage(const struct FGameplayTag& EventType, class UObject* EventWriter);
	class UObject* StaticGetEventWriter(struct FQtnEventMessage& EventMessage);
	struct FGameplayTag StaticGetEventType(struct FQtnEventMessage& EventMessage);
	struct FVector StaticGetEventContextVector(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, struct FVector& DefaultValue);
	class UObject* StaticGetEventContextObject(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, class UObject* DefaultValue);
	class FName StaticGetEventContextName(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, class FName& DefaultValue);
	int32 StaticGetEventContextInt(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, int32 DefaultValue);
	struct FGameplayTag StaticGetEventContextGameplayTag(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, struct FGameplayTag& DefaultValue);
	float StaticGetEventContextFloat(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, float DefaultValue);
	class UClass* StaticGetEventContextClass(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, class UClass* DefaultValue);
	bool StaticGetEventContextBool(struct FQtnEventMessage& EventMessage, const struct FGameplayTag& ContextKey, bool DefaultValue);
	void StaticDispatchEventMessage(class UObject* WorldContextObject, struct FQtnEventMessage& EventMessage);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnEventMatching
class UQtnEventMatching : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnEventMatching* GetDefaultObj();

};

// 0x0 (0x250 - 0x250)
// Class QtnGame.QtnExponentialHeightFog
class AQtnExponentialHeightFog : public AActor
{
public:

	static class UClass* StaticClass();
	static class AQtnExponentialHeightFog* GetDefaultObj();

};

// 0x58 (0x138 - 0xE0)
// Class QtnGame.QtnFaceBlindnessFX
class UQtnFaceBlindnessFX : public UActorComponent
{
public:
	class AQtnGameState*                         M_pCachedGameState;                                // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FadeDuration;                                      // 0xE8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_fadeTimer;                                       // 0xEC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnCameraComponent*                   M_pPlayerCamera;                                   // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                             PPPlayerOutlineMaterial;                           // 0xF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                             BlankMaterial;                                     // 0x100(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_outlineOn;                                       // 0x108(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F4D[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class APawn*                                 M_pOwningPawn;                                     // 0x110(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_onFrameOne;                                      // 0x118(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F4E[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInstanceDynamic*              M_pBlankMaterial;                                  // 0x120(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*              M_pPlayerOutline;                                  // 0x128(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                 M_pAttachedPawn;                                   // 0x130(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnFaceBlindnessFX* GetDefaultObj();

};

// 0x1E0 (0x2C0 - 0xE0)
// Class QtnGame.QtnFacialAnimComponent
class UQtnFacialAnimComponent : public UActorComponent
{
public:
	class USkeletalMeshComponent*                Mesh;                                              // 0xE0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                             CurBlinkRange;                                     // 0xE8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MouthMatInt;                                       // 0xF0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ClosedMouthShape;                                  // 0xF4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        EyeMatInt;                                         // 0xF8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F58[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInstanceDynamic*              DeadSquintMat;                                     // 0x100(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        BrowMat;                                           // 0x108(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F59[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInterface*                    BrowVis;                                           // 0x110(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                AnimMesh;                                          // 0x118(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bVoiceMouthOverride;                               // 0x120(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bOverridingIdleFace;                               // 0x121(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsBlinking;                                       // 0x122(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bAllowBlinking;                                    // 0x123(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        EyeTimer;                                          // 0x124(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                       CurrentSound;                                      // 0x128(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnTeam>                  BSWaveTeam;                                        // 0x130(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CurBlinkTime;                                      // 0x138(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1F5A[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UCurveFloat*                           FloatCurve;                                        // 0x140(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        SyncedMouthShape;                                  // 0x148(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1F5B[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInterface*                    MouthMat;                                          // 0x150(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        M_closedMouthOverride;                             // 0x158(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        LookTimer;                                         // 0x15C(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bOverrideRandomPupils;                             // 0x160(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bChangeView;                                       // 0x161(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1F5C[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        LookDirInt;                                        // 0x164(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          MyBody;                                            // 0x168(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnCharacterAppearanceComponent*      AppearanceComp;                                    // 0x170(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              TonedBlinkMat;                                     // 0x178(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              PeekBlinkMat;                                      // 0x180(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              CurrentEyeMat;                                     // 0x188(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bPendingFacialNotify;                              // 0x190(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1F5D[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                EyeMatEyeMoveParameterName;                        // 0x198(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                PeekBlinkMatEyeMoveParameterName;                  // 0x1A8(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              OpenEyeMat;                                        // 0x1B8(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                    PeekBlinkMatParent;                                // 0x1C0(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                    DeadSquintMatParent;                               // 0x1C8(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                    BrowHidden;                                        // 0x1D0(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                    DefaultMouth;                                      // 0x1D8(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        TickFaceEnabledDistance;                           // 0x1E0(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_1F5E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<int32, class UMaterialInterface*>       M_mouthMap;                                        // 0x1E8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FEyePosition>                  M_eyePositions;                                    // 0x238(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                    M_eyeMat;                                          // 0x248(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnVOComponent*                       M_cachedVOComponent;                               // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isLipSyncing;                                    // 0x258(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F5F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_lipSyncTime;                                     // 0x25C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasCachedVOComponent;                            // 0x260(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F60[0xF];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FEyePosition                          M_pendingStruct;                                   // 0x270(0x40)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                        M_faceStackLength;                                 // 0x2B0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isCinematic;                                     // 0x2B4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F61[0xB];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFacialAnimComponent* GetDefaultObj();

	void UpdateEyeTone(float NonBodySkinTone);
	void StartLipSync();
	void SetUpFace();
	void SetPupilPosition(const struct FEyePosition& EyePos);
	void SetMouthMap(TMap<int32, class UMaterialInterface*> MouthMap);
	void SetIsCinematic(bool IsCinematic);
	void SetFacialExpression(bool bStarting, class UMaterialInterface* InEyeMat, class UMaterialInterface* InMouthMat, const struct FEyePosition& InEyePos, bool bPersistBrows);
	void SetClosedMouthOverride(int32 ClosedMouthOverride);
	void ResetMesh();
	void PostBlinkFacialUpdate();
	class FText GetSpeakerName();
	class UQtnVOComponent* GetAndCacheVOComponent();
	void ForceBlink();
	void FinishLipSync();
	void CloseMouth();
	void CheckMouthAnim();
	void BlinkToggle(bool bBlink);
	void AdjustLook(float DeltaTime);
	void AddEyePosition(const struct FEyePosition& EyePosition);
	void ActiveWhenGetNear();
};

// 0x38 (0x60 - 0x28)
// Class QtnGame.QtnFileTransferManager
class UQtnFileTransferManager : public UObject
{
public:
	uint8                                        Pad_1F62[0x38];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFileTransferManager* GetDefaultObj();

};

// 0x0 (0xE0 - 0xE0)
// Class QtnGame.QtnFootstepFXComponentNative
class UQtnFootstepFXComponentNative : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnFootstepFXComponentNative* GetDefaultObj();

	void SpawnFootstep(class AActor* POwner, struct FVector& InImpactLocation, struct FVector& InImpactNormal, enum class EPhysicalSurface InSurface, struct FVector& OutImpactLocation, struct FVector& OutImpactNormal, enum class EPhysicalSurface& OutSurface, bool& OutOnSnow, class UNiagaraComponent* PTrailEmitter, bool IsDisabled, class UMaterialInterface* PSnowDecal, class UMaterialInterface* PMudDecal);
	void FirstTimeOnMud();
};

// 0x28 (0x108 - 0xE0)
// Class QtnGame.QtnFriendshipComponent
class UQtnFriendshipComponent : public UActorComponent
{
public:
	class AQtnPlayerPawn*                        M_pOwningPlayerPawn;                               // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyPawn*>                  M_nearbyFriendBodies;                              // 0xE8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnStatusAllyProximity>   AllyProximityStatus;                               // 0xF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       FriendshipRadius;                                  // 0x100(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnFriendshipComponent* GetDefaultObj();

};

// 0x1C0 (0x2A0 - 0xE0)
// Class QtnGame.QtnFrobAccumulatorComponent
class UQtnFrobAccumulatorComponent : public UActorComponent
{
public:
	uint8                                        Pad_1F6B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_fillRatio;                                       // 0xE8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_fillDrainThrottle;                               // 0xEC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_totalFrobStrength;                               // 0xF0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_fillInhibitorCeiling;                            // 0xF4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_drainInhibitorFloor;                             // 0xF8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_isLocked;                                        // 0xFC(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F6C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_fillRatioBump;                                   // 0x100(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F6D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFrobbableComponent*                M_pEngagedFrobbable;                               // 0x108(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_fillInhibitors;                                  // 0x110(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_drainInhibitors;                                 // 0x160(0x50)(Transient, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pLastFrobbingPawn;                               // 0x1B0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnAccumulatorFillStart;                            // 0x1B8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorFillStop;                             // 0x1C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorSuccess;                              // 0x1D8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorLock;                                 // 0x1E8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorDrainStart;                           // 0x1F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorDrainStop;                            // 0x208(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorReset;                                // 0x218(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccumulatorFillDrainChange;                      // 0x228(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorFSM*                M_pFrobAccumulatorFSM;                             // 0x238(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorStateEmpty*         M_pEmptyState;                                     // 0x240(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorStateFilling*       M_pFillingState;                                   // 0x248(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorStateSuspended*     M_pSuspendedState;                                 // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorStateDraining*      M_pDrainingState;                                  // 0x258(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorStateFull*          M_pFullState;                                      // 0x260(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         LockUponSuccess;                                   // 0x268(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F6E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FillRatioBumpPerTap;                               // 0x26C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        FillDuration;                                      // 0x270(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DrainDuration;                                     // 0x274(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        FillRateMultiplier;                                // 0x278(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DrainRateMultiplier;                               // 0x27C(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       RequiredFrobStrength;                              // 0x280(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                        FillAccelerationDuration;                          // 0x288(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DrainAccelerationDuration;                         // 0x28C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x290(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorComponent* GetDefaultObj();

	void RemoveFillInhibitor(class UObject* Inhibitor);
	void RemoveDrainInhibitor(class UObject* Inhibitor);
	void OnRep_IsLocked();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsFilledByTaps();
	bool IsAccumulatorLocked();
	void InhibitFillNow(class UObject* Inhibitor);
	void InhibitDrainNow(class UObject* Inhibitor);
	float GetTotalFrobStrength();
	class AQtnPawn* GetLastFrobbingPawn();
	float GetFillRatio();
	void BumpFillRatio(float FillRatioBump);
	void AddFillInhibitor(class UObject* Inhibitor, float MaxAllowedFill);
	void AddDrainInhibitor(class UObject* Inhibitor, float MinAllowedFill);
};

// 0x80 (0xA8 - 0x28)
// Class QtnGame.QtnFSM
class UQtnFSM : public UObject
{
public:
	TMap<TSubclassOf<class UQtnFSMState>, class UQtnFSMState*> M_stateMap;                                        // 0x28(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F6F[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_activeStateRequestQueueIndex;                    // 0x98(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F70[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFSMState*                          M_pCurrentState;                                   // 0xA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnFSM* GetDefaultObj();

};

// 0x0 (0xA8 - 0xA8)
// Class QtnGame.QtnFrobAccumulatorFSM
class UQtnFrobAccumulatorFSM : public UQtnFSM
{
public:

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorFSM* GetDefaultObj();

};

// 0x8 (0x38 - 0x30)
// Class QtnGame.QtnFrobAccumulatorState
class UQtnFrobAccumulatorState : public UQtnFSMState
{
public:
	class UQtnFrobAccumulatorComponent*          M_pOwningFrobAccumulator;                          // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorState* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnFrobAccumulatorStateDraining
class UQtnFrobAccumulatorStateDraining : public UQtnFrobAccumulatorState
{
public:
	uint8                                        Pad_1F71[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorStateDraining* GetDefaultObj();

};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnFrobAccumulatorStateEmpty
class UQtnFrobAccumulatorStateEmpty : public UQtnFrobAccumulatorState
{
public:

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorStateEmpty* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnFrobAccumulatorStateFilling
class UQtnFrobAccumulatorStateFilling : public UQtnFrobAccumulatorState
{
public:
	uint8                                        Pad_1F72[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorStateFilling* GetDefaultObj();

};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnFrobAccumulatorStateFull
class UQtnFrobAccumulatorStateFull : public UQtnFrobAccumulatorState
{
public:

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorStateFull* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnFrobAccumulatorStateSuspended
class UQtnFrobAccumulatorStateSuspended : public UQtnFrobAccumulatorState
{
public:
	uint8                                        Pad_1F73[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFrobAccumulatorStateSuspended* GetDefaultObj();

};

// 0xF8 (0x320 - 0x228)
// Class QtnGame.QtnFrobbableComponent
class UQtnFrobbableComponent : public USceneComponent
{
public:
	uint8                                        Pad_1F76[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          M_pCurrentFrobbingPawn;                            // 0x238(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          R_pFrobbingPawn;                                   // 0x240(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFrobAccumulatorComponent*          M_pFrobAccumulatorCompToFeed;                      // 0x248(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnSynchComponent*                    M_pAssociatedSynchComponent;                       // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                       M_pTargetingFocalPointComponent;                   // 0x258(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_frobInhibitors;                                  // 0x260(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         R_hasBeenUsed;                                     // 0x270(0x1)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F77[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnFrobGate*>                  M_frobGates;                                       // 0x278(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                  TargetingTag;                                      // 0x288(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        FrobDistance;                                      // 0x290(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowAnyFrobbing;                                  // 0x294(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowFrobWhenHidden;                               // 0x295(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         OneTimeUse;                                        // 0x296(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F79[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnFrobGate>>      DefaultFrobGates;                                  // 0x298(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                  FrobPrompt;                                        // 0x2A8(0x18)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FQtnPawnMontage                       FrobBodyAction;                                    // 0x2C0(0x10)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFrobBegin;                                       // 0x2D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFrobEnd;                                         // 0x2E0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                FrobAccumulatorToFeed;                             // 0x2F0(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        FrobAccumulatorMultiplier;                         // 0x2F8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F7A[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USoundBase*                            FrobSound;                                         // 0x300(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x308(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F7B[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFrobbableComponent* GetDefaultObj();

	void RemoveFrobInhibitor(class UObject* PInhibitor);
	void RemoveFrobGate(TSubclassOf<class UQtnFrobGate> FrobGateClass);
	void OnRep_FrobbingPawn();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void MulticastRefreshFrobbingPawn(class AQtnBodyPawn* PFrobbingPawn);
	class AQtnBodyPawn* GetCurrentFrobbingPawn();
	bool CanBeTargetedBP(class AQtnPawn* PTargetingPawn);
	void AddFrobInhibitor(class UObject* PInhibitor);
	void AddFrobGate(TSubclassOf<class UQtnFrobGate> FrobGateClass);
};

// 0x28 (0x50 - 0x28)
// Class QtnGame.QtnFrobGate
class UQtnFrobGate : public UObject
{
public:
	uint8                                        Pad_1F7C[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  DefaultRejectionMessage;                           // 0x30(0x18)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                         GrantKeyToAIs;                                     // 0x48(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F7D[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFrobGate* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnFrobGateInterface
class IQtnFrobGateInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnFrobGateInterface* GetDefaultObj();

	bool IsFrobAllowed(class AQtnBodyPawn* bodyPawn, class UQtnFrobbableComponent* FrobbableComponent);
	class FText GetRejectionMessage(class AQtnBodyPawn* bodyPawn, class UQtnFrobbableComponent* FrobbableComponent);
};

// 0x0 (0xA8 - 0xA8)
// Class QtnGame.QtnFullBodyFSM
class UQtnFullBodyFSM : public UQtnFSM
{
public:

	static class UClass* StaticClass();
	static class UQtnFullBodyFSM* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class QtnGame.QtnFullBodyState
class UQtnFullBodyState : public UQtnBodyState
{
public:

	static class UClass* StaticClass();
	static class UQtnFullBodyState* GetDefaultObj();

	void RequestHitReactionState(struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactInfo);
	void OnMovementBlocked(struct FHitResult& Impact);
	void HandleDamageReceived(struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactInfo);
	void CheckForVerbInput();
};

// 0xB0 (0x160 - 0xB0)
// Class QtnGame.QtnFullBodyStateAction
class UQtnFullBodyStateAction : public UQtnFullBodyState
{
public:
	bool                                         M_isMonitoringScriptedAction;                      // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_teleportHappenedDuringExit;                      // 0xB1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isDoingQueuedAction;                             // 0xB2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F80[0xD];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQuat                                 M_startingLerpRotation;                            // 0xC0(0x10)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                               M_startingLerpLocation;                            // 0xD0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F81[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnActionIntention                   M_actionIntention;                                 // 0xE0(0x28)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_montageIsDone;                                   // 0x108(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0x109(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F82[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_synchStrength;                                   // 0x10C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_elapsedActionTime;                               // 0x110(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_actionDuration;                                  // 0x114(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_knownSafePosition;                               // 0x118(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F83[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pTargetActor;                                    // 0x128(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnSynchComponent*                    M_pSynchTarget;                                    // 0x130(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F84[0x28];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFullBodyStateAction* GetDefaultObj();

};

// 0x90 (0x140 - 0xB0)
// Class QtnGame.QtnFullBodyStateDead
class UQtnFullBodyStateDead : public UQtnFullBodyState
{
public:
	uint8                                        Pad_1F89[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnAISystem*                          M_pCachedAISystem_ServerOnly;                      // 0xD0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0xD8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F8A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_currentDeathAction;                              // 0xE0(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_montageFinishPending;                            // 0xF0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F8B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_slipperyTimer;                                   // 0xF4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_deadIdleVOTimer;                                 // 0xF8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_navMeshReady;                                    // 0xFC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_canBeRevived;                                    // 0xFD(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_doCrawlLoco;                                     // 0xFE(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F8C[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_pendingDeathAction;                              // 0x100(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           CrawlLocoBlend;                                    // 0x110(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        CrawlSpeedScale;                                   // 0x118(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        CrawlTurnSpeed;                                    // 0x11C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       FallbackDeadMontage;                               // 0x120(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       DeadIdleVOTime;                                    // 0x130(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnFXActor>               DespawnFX;                                         // 0x138(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnFullBodyStateDead* GetDefaultObj();

	void SetCanBeRevived(bool CanBeRevived);
	float PlayDeathMontage(struct FQtnPawnMontage& DeathMontage, bool OverrideCrawl);
	void OnDeathMontageDone(class UAnimMontage* Montage, bool Interrupted);
	bool IsPlayingDeathMontage();
	bool GetCanBeRevived(bool* CanCrawl);
};

// 0x60 (0x110 - 0xB0)
// Class QtnGame.QtnFullBodyStateEngaged
class UQtnFullBodyStateEngaged : public UQtnFullBodyState
{
public:
	class UQtnFrobbableComponent*                M_pFrobTarget;                                     // 0xB0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnSynchComponent*                    M_pSynchTarget;                                    // 0xB8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_interpSpeed;                                     // 0xC0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_knownSafePosition;                               // 0xC4(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_montageIsDone;                                   // 0xD0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0xD1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F8D[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_engagementBodyAction;                            // 0xD8(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F8E[0x28];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFullBodyStateEngaged* GetDefaultObj();

};

// 0x198 (0x248 - 0xB0)
// Class QtnGame.QtnFullBodyStateHitReaction
class UQtnFullBodyStateHitReaction : public UQtnFullBodyState
{
public:
	float                                        M_remainingReactionTime;                           // 0xB0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_expectedReactionDuration;                        // 0xB4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_elapsedReactionTime;                             // 0xB8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_elapsedDeadIdleTime;                             // 0xBC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_allowLocomotion;                                 // 0xC0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F90[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnFXActor*                           M_pFXInstance;                                     // 0xC8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnDamageReaction>, class UQtnDamageReaction*> M_instantiatedReactions;                           // 0xD0(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pPerpetratorBody;                                // 0x120(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnDamageInfo                        M_reactedDamageInfo;                               // 0x128(0x88)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnHitReactionInfo                   M_hitReactInfo;                                    // 0x1B0(0x50)(Transient, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       M_currentPawnMontage;                              // 0x200(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_montageFinishPending;                            // 0x210(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0x211(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F91[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnDamageReaction*                    M_pDamageReaction;                                 // 0x218(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           M_pLocoBlendOverride;                              // 0x220(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F92[0x20];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFullBodyStateHitReaction* GetDefaultObj();

	void TransitionToKnockdown(float KnockdownSeconds);
	float PlayReactionMontage(struct FQtnPawnMontage& ReactionMontage, float PlayRate, float StartTime);
	bool IsMontageFinishPending();
	float GetRemainingReactionTime();
	void GetReactionInfo(struct FQtnDamageInfo* ReactedDamageInfo, struct FQtnHitReactionInfo* HitReactInfo);
	float GetElapsedReactionTime();
	struct FQtnPawnMontage GetCurrentReactionMontage();
	class UQtnDamageReaction* GetCurrentDamageReaction();
	void FinishCurrentMontage(bool JumpToOutro);
};

// 0xC8 (0x178 - 0xB0)
// Class QtnGame.QtnFullBodyStateJumpFall
class UQtnFullBodyStateJumpFall : public UQtnFullBodyState
{
public:
	bool                                         M_shouldFinishState;                               // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_canMantle;                                       // 0xB1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_intentionalJump;                                 // 0xB2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F93[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_airControlSpeedScale;                            // 0xB4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_jumpEndDelay;                                    // 0xB8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_stasisTimer;                                     // 0xBC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_topZ;                                            // 0xC0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lastZ;                                           // 0xC4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_wasHoldingJump;                                  // 0xC8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        StaminaCost;                                       // 0xCC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        NoiseEvaluationMaxFallDistance;                    // 0xD0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        NoiseEvaluationFallDistanceSubtractedByCrouch;     // 0xD4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         ShowFirstPersonLegs;                               // 0xD8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F94[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        JumpInputBufferDuration;                           // 0xDC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F95[0x90];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MantleBodyHeightRatio;                             // 0x170(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F96[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFullBodyStateJumpFall* GetDefaultObj();

};

// 0x50 (0x100 - 0xB0)
// Class QtnGame.QtnFullBodyStateKnockedDown
class UQtnFullBodyStateKnockedDown : public UQtnFullBodyState
{
public:
	float                                        M_defaultKnockdownDuration;                        // 0xB0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_minKnockdownTime;                                // 0xB4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_elapsedKnockdownTime;                            // 0xB8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_failsafeElapsedKnockdownTime;                    // 0xBC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0xC0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_montageFinishPending;                            // 0xC1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F99[0x26];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_currentKnockdownAction;                          // 0xE8(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class AQtnFXActor>               KnockdownFX;                                       // 0xF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnFullBodyStateKnockedDown* GetDefaultObj();

	float PlayDownedMontage(struct FQtnPawnMontage& DownedMontage, float KnockdownDuration);
	void OnDownedMontageDone(class UAnimMontage* Montage, bool Interrupted);
	float GetRemainingKnockdownTime();
	float GetFailsafeElapsedKnockdownTime();
	float GetElapsedKnockdownTime();
	float GetDefaultKnockdownDuration();
	void FinishKnockdown(bool SkipOutro);
};

// 0x20 (0xD0 - 0xB0)
// Class QtnGame.QtnFullBodyStateLocomotion
class UQtnFullBodyStateLocomotion : public UQtnFullBodyState
{
public:
	bool                                         M_jumpReleasedWhileOnGround;                       // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F9A[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_elapsedTimeOnGround;                             // 0xB4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_speedScale;                                      // 0xB8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_elapsedTimeFalling;                              // 0xBC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_wasJumpInputBuffered;                            // 0xC0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F9B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        JumpLeewayDuration;                                // 0xC4(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        IdleTurnSpeed;                                     // 0xC8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1F9C[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFullBodyStateLocomotion* GetDefaultObj();

};

// 0xB0 (0x160 - 0xB0)
// Class QtnGame.QtnFullBodyStateMantle
class UQtnFullBodyStateMantle : public UQtnFullBodyState
{
public:
	enum class EMantleStateEnum                  M_mantleState;                                     // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F9D[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USkeletalMeshComponent*                M_pRelevantMesh;                                   // 0xB8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_mantleDirection;                                 // 0xC0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_ledgePoint;                                      // 0xCC(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_targetPoint;                                     // 0xD8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_mantleTimer;                                     // 0xE4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_effectiveSpeedMultiplier;                        // 0xE8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_ledgeLerpSpeed;                                  // 0xEC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isVaulting;                                      // 0xF0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasGoneBackwards;                                // 0xF1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_allowCancelDuringAnim;                           // 0xF2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F9E[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_lastMantleGameTime;                              // 0xF4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1F9F[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_currentAction;                                   // 0x118(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        MantleSpeedMultiplier;                             // 0x128(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FA0[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       MantleAnim;                                        // 0x130(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       VaultAnim;                                         // 0x140(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        HorizontalLerpSpeed;                               // 0x150(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        LedgeLerpDurationMantle;                           // 0x154(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        LedgeLerpDurationVault;                            // 0x158(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_effectiveLedgeLerpDuration;                      // 0x15C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnFullBodyStateMantle* GetDefaultObj();

};

// 0xE0 (0x190 - 0xB0)
// Class QtnGame.QtnFullBodyStateVerb
class UQtnFullBodyStateVerb : public UQtnFullBodyState
{
public:
	uint8                                        Pad_1FA1[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_verbAction;                                      // 0xB8(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0xC8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FA2[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pVerb;                                           // 0xD0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_allowedFrobInterruption;                         // 0xD8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_canMantle;                                       // 0xD9(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FA3[0xB6];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFullBodyStateVerb* GetDefaultObj();

};

// 0x18 (0x268 - 0x250)
// Class QtnGame.QtnFullyStreamedInAssets
class AQtnFullyStreamedInAssets : public AInfo
{
public:
	TArray<class UStreamableRenderAsset*>        AlwaysLoadedAssets;                                // 0x250(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FPerPlatformBool                      IsEnabledPerPlatform;                              // 0x260(0x1)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FA4[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnFullyStreamedInAssets* GetDefaultObj();

	bool AreAllAssetsFullyStreamedIn();
};

// 0x170 (0x3C0 - 0x250)
// Class QtnGame.QtnFXActor
class AQtnFXActor : public AActor
{
public:
	bool                                         M_bUseLowCostVFX;                                  // 0x250(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FBD[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pTargetActor;                                    // 0x258(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnGameState*                         M_pCachedGameState;                                // 0x260(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsLooping;                                        // 0x268(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bMultiLooping;                                     // 0x269(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRetriggerLooping;                                 // 0x26A(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIgnoreTargetActorVisibility;                      // 0x26B(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FBF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnNiagaraDef>                NiagaraDefs;                                       // 0x270(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnParticlesDef>              ParticlesDefs;                                     // 0x280(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnDecalDef>                  DecalDefs;                                         // 0x290(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnPostProcessDef>            PostProcessDefs;                                   // 0x2A0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnOutlineDef>                OutlineDefs;                                       // 0x2B0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnOverlayDef>                OverlayDefs;                                       // 0x2C0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnAINoiseDef>                AINoiseDefs;                                       // 0x2D0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnAudioDef>                  AudioDefs;                                         // 0x2E0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnForceFeedbackDef>          ForceFeedbackDefs;                                 // 0x2F0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnCameraShakeDef>            CameraShakeDefs;                                   // 0x300(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         bIsLoopingActive;                                  // 0x310(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FC1[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UNiagaraComponent*>             M_NiagaraComponents;                               // 0x318(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>      M_ParticlesComponents;                             // 0x328(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UQtnDecalComponent*>            M_DecalComponents;                                 // 0x338(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UQtnPostProcessFX*>             M_PostProcessFXs;                                  // 0x348(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UQtnOutlineFX*>                 M_OutlineFXs;                                      // 0x358(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UQtnOverlayFX*>                 M_OverlayFXs;                                      // 0x368(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UQtnAINoiseFX*>                 M_AINoiseFXs;                                      // 0x378(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UAudioComponent*>               M_AudioComponents;                                 // 0x388(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UForceFeedbackComponent*>       M_ForceFeedbackComponents;                         // 0x398(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCameraShakeSourceComponent*>   M_CameraShakeComponents;                           // 0x3A8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         bCanUseAttachParentBound;                          // 0x3B8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FC3[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnFXActor* GetDefaultObj();

	void PostBeginEffectWithContactEventData(struct FQtnContactEventData& ContactEventData);
	void OverwriteNiagaraDefSys(int32 Index, bool LowCost, class UNiagaraSystem* NiagaraSystem);
	void OnPostProcessFXFinished(class UQtnPostProcessFX* PFinishedPPFX);
	void OnParticleSystemFinished(class UParticleSystemComponent* PFinishedPSC);
	void OnOwnerVisibilityStateChanged(bool IsHidden);
	void OnOverlayFXFinished(class UQtnOverlayFX* PFinishedOFX);
	void OnNiagaraFinished(class UNiagaraComponent* PFinishedNC);
	void OnLoopingTargetActorEndPlay(class AActor* PActor, enum class EEndPlayReason EndPlayReason);
	void OnFXElementFinished(class UObject* PFinishedElement);
	void OnForceFeedbackFinished(class UForceFeedbackComponent* PFinishedFFC);
	void OnEffectStarted(class AActor* TargetActor);
	void OnEffectEnded();
	void OnDecalFinished(class UQtnDecalComponent* PFinishedDecal);
	void OnCameraShakeFinished(class UCameraShakeSourceComponent* PFinishedCSC);
	void OnAudioFinished(class UAudioComponent* PFinishedAC);
	void HandleSimPause(bool Paused);
	class AActor* GetTargetActor();
	class UQtnPostProcessFX* GetPostProcessObject(int32 Index);
	TArray<class UMaterialInstanceDynamic*> GetPostProcessMaterialInstances(int32 Index);
	class UParticleSystemComponent* GetParticleSystemComponent(int32 Index);
	TArray<class UMaterialInstanceDynamic*> GetOverlayMaterialInstances(int32 Index);
	class UNiagaraComponent* GetNiagaraComponent(int32 Index);
	class UMaterialInstanceDynamic* GetDecalMaterialInstance(int32 Index);
	class UDecalComponent* GetDecalComponent(int32 Index);
	class UAudioComponent* GetAudioComponent(int32 Index);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnFXInterceptionInterface
class IQtnFXInterceptionInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnFXInterceptionInterface* GetDefaultObj();

	bool CheckIsFXIntercepted(TSubclassOf<class AQtnFXActor> FxClass);
};

// 0x180 (0x1A8 - 0x28)
// Class QtnGame.QtnFXManager
class UQtnFXManager : public UObject
{
public:
	TMap<TSubclassOf<class AQtnFXActor>, struct FQtnFXActorPool> M_FXActorPool;                                     // 0x28(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FQtnFXPoolingWarmUpItem>       FXPoolingWarmUpItems;                              // 0x78(0x10)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FCE[0x120];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnFXManager* GetDefaultObj();

	void BP_SetEffectsHidden(class AActor* TargetActor, bool Hidden);
	void BP_EndEffectByReference(class AQtnFXActor* FXActor);
	void BP_EndEffect(TSubclassOf<class AQtnFXActor> FxClass, class AActor* TargetActor);
	class AQtnFXActor* BP_BeginEffect(TSubclassOf<class AQtnFXActor> FxClass, class AActor* TargetActor, const struct FVector& LocationOverride, const struct FRotator& RotationOverride, class FName SocketOverride, enum class EAttachmentRule LocationRule, enum class EAttachmentRule RotationRule, class AActor* BeamTargetActor, enum class EAttachmentRule ScaleRule, bool DoAttach, class AQtnPawn* NoiseCulpritPawn);
};

// 0x2D0 (0x478 - 0x1A8)
// Class QtnGame.QtnGameInstance
class UQtnGameInstance : public UGameInstance
{
public:
	uint8                                        Pad_1FE3[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnCombatSettings>        CombatSettingsClass;                               // 0x1B0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnCharacterAppearanceSettings> CharacterAppearanceSettingsClass;                  // 0x1B8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnDebugWrapper*                      M_DebugWrapper;                                    // 0x1C0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnGameState*                         M_pActiveGameState;                                // 0x1C8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnSaveLoadManager>       SaveLoadManagerClass;                              // 0x1D0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnSaveLoadManager*                   M_pSaveLoadManager;                                // 0x1D8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnGlobalRunProgress>     GlobalRunProgressArchetype;                        // 0x1E0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnGlobalRunProgress*                 M_pGlobalRunProgress;                              // 0x1E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnAISystemSettings>      AISystemSettingsClass;                             // 0x1F0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnServerDiagnostics*                 M_pServerDiagnostics;                              // 0x1F8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnEventHandlerTelemetry> TelemetryEventHandlerClass;                        // 0x200(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnEventHandlerTelemetry*             M_pEventHandlerTelemetry;                          // 0x208(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnOnlineIdentityProxy*               M_pOnlineIdentityProxy;                            // 0x210(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnScreenLoading*                     M_pTravelingLoadingScreen;                         // 0x218(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UQtnOutcomeCalculator*>         OutcomeCalculatorInstanceArray;                    // 0x220(0x10)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USoundClass*                           SoundClass_Master;                                 // 0x230(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                           SoundClass_Music;                                  // 0x238(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                           SoundClass_SFX;                                    // 0x240(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                           SoundClass_Ambience;                               // 0x248(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                           SoundClass_Speech;                                 // 0x250(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                 LoadingScreenHintFont;                             // 0x258(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnInputContext>          NullInputContext;                                  // 0x260(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FText>             NetworkErrorTexts;                                 // 0x268(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                          M_VOLanguage;                                      // 0x2B8(0x8)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_bForceFeedback;                                  // 0x2C0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FE6[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_FOVScale;                                        // 0x2C4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnGamepadGlyphStyle             M_gamepadGlyphStyle;                               // 0x2C8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_muteRobovoice;                                   // 0x2C9(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FE7[0x2E];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FUniqueNetIdRepl>              M_bannedPlayerIDs;                                 // 0x2F8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                         M_bDisplayUserTags;                                // 0x308(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1FE8[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnTermLocalization>      TermLocalizationClass;                             // 0x310(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnItemGeoDatabase>       ItemGeoDatabaseClass;                              // 0x318(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnTermLocalization*                  TermLocalizationInstance;                          // 0x320(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnItemGeoDatabase*                   ItemGeoDatabaseInstance;                           // 0x328(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQtnArcInfo>                   ActivityMapArcs;                                   // 0x330(0x10)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnAchievementsManager>   AchievementsManagerClass;                          // 0x340(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnAchievementsManager*               M_pAchievementsManager;                            // 0x348(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnRichPresenceManager>   RichPresenceManagerClass;                          // 0x350(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnRichPresenceManager*               M_pRichPresenceManager;                            // 0x358(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnDLCManager>            DLCManagerClass;                                   // 0x360(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnDLCManager*                        M_pDLCManager;                                     // 0x368(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFileTransferManager*               M_pFileTransferManager;                            // 0x370(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FE9[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_pendingViewportFadeup;                           // 0x390(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FEA[0x1B];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_isWaitingForAccountPicker;                       // 0x3AC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_pendingLocalLogout;                              // 0x3AD(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isChangingUserProfile;                           // 0x3AE(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FEB[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  TitleMapName;                                      // 0x3B0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  HubMapName;                                        // 0x3B8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHasVisitedTitle;                                  // 0x3C0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_automatedReportsActive;                          // 0x3C1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_automatedReportStatFileActive;                   // 0x3C2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FED[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class FString>                        M_reportedMaps;                                    // 0x3C8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FQtnNameIntPair>               AutomatedReportMapArcs;                            // 0x3D8(0x10)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	float                                        M_automatedReportIdleCountdown;                    // 0x3E8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        AutomatedReportStartDelayPerMap;                   // 0x3EC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FEF[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_inviteJoinDeferrers;                             // 0x3F8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         M_hasNotifiedInviteJoinListeners;                  // 0x408(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FF0[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnJoinPendingInviteReady;                          // 0x410(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FUniqueNetIdRepl, int32>         M_desiredPlayerNumbers_ServerOnly;                 // 0x420(0x50)(Transient, NativeAccessSpecifierPrivate)
	float                                        M_remainingDemoSeconds;                            // 0x470(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FF2[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnGameInstance* GetDefaultObj();

	class FName UpdateQtnEntryDestination();
	void StopTelemetry();
	void StartTelemetry();
	void ShowGamerCard(class AQtnPlayerState* PPlayerState);
	bool ShowAccountPicker();
	void SetRemainingDemoSeconds(float RemainingTradeshowSeconds);
	void SetCurrentArc(int32 CurrentArc);
	void ResetLocalLoggedInUser();
	void RemoveInviteJoinDeferrer(class UObject* InviteJoinDeferrer);
	void OnPreLoadMap(const class FString& MapName);
	void OnPostLoadMap(class UWorld* LoadedWorld);
	bool IsWaitingForAccountPicker();
	bool IsRunningAutomatedReports();
	bool IsLoggedInOnCurrentPlatform();
	bool IsFullyLoggedIn();
	bool IsChangingUserProfile();
	void HandleReturningFromConstrainedMode();
	void HandleEnteringConstrainedMode();
	float GetRemainingDemoSeconds(float* TotalTradeshowSeconds);
	class UQtnGameInstance* GetQtnGameInstance(class UObject* WorldContextObject);
	class FString GetLocalPlayerDisplayName();
	int32 GetLocalLoggedInUserIndex();
	class UQtnDLCManager* GetDLCManager();
	class UQtnCombatSettings* GetCombatSettings();
	class UQtnCharacterAppearanceSettings* GetCharacterAppearanceSettings();
	class FString GetCanUseUGCError(class UObject* WorldContextObject);
	bool GetCanUseUGC(class UObject* WorldContextObject);
	class FString GetCanPlayError(class UObject* WorldContextObject);
	bool GetCanPlay(class UObject* WorldContextObject);
	class AQtnGameState* GetActiveGameState();
	class UQtnAchievementsManager* GetAchievementsManager();
	bool CanPlayHordeMode();
	void AddInviteJoinDeferrer(class UObject* InviteJoinDeferrer);
};

// 0x68 (0x358 - 0x2F0)
// Class QtnGame.QtnGameModeBase
class AQtnGameModeBase : public AGameModeBase
{
public:
	class FString                                M_pendingTravelURL;                                // 0x2F0(0x10)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FUniqueNetIdRepl, struct FQtnPersistentPlayerState> M_persistentPlayerStates;                          // 0x300(0x50)(NativeAccessSpecifierPublic)
	enum class EQtnGameModeType                  GameModeType;                                      // 0x350(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_missionEnded;                                    // 0x351(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FF6[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnGameModeBase* GetDefaultObj();

	void QueueSeamlessTravel_ServerOnly(class UObject* WorldContextObject, class FName LevelName);
	void EndGame();
	void CleanUpMediaSounds(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	class AActor* ChoosePlayerStartForArc(class AController* Player, int32 Arc);
};

// 0x0 (0x358 - 0x358)
// Class QtnGame.QtnGameModeMission
class AQtnGameModeMission : public AQtnGameModeBase
{
public:

	static class UClass* StaticClass();
	static class AQtnGameModeMission* GetDefaultObj();

};

// 0x0 (0x358 - 0x358)
// Class QtnGame.QtnGameModeSocialHub
class AQtnGameModeSocialHub : public AQtnGameModeBase
{
public:

	static class UClass* StaticClass();
	static class AQtnGameModeSocialHub* GetDefaultObj();

};

// 0x118 (0x380 - 0x268)
// Class QtnGame.QtnGameSession
class AQtnGameSession : public AGameSession
{
public:
	TMap<class APlayerController*, struct FQtnPendingKickInfo> M_pendingPlayerControllersToKick;                  // 0x268(0x50)(Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1FFD[0xC8];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnGameSession* GetDefaultObj();

	void StaticSetPartySessionPrivacy(class UObject* WorldContextObject, enum class EQtnSessionPrivacy SessionPrivacy);
	void StaticKickPlayer_AuthorityOnly(class APlayerState* PlayerState, class FText KickReason, bool banFromReentering, float Delay);
	bool DoesPartySessionExist(class UObject* WorldContextObject);
};

// 0x858 (0xAF8 - 0x2A0)
// Class QtnGame.QtnGameState
class AQtnGameState : public AGameStateBase
{
public:
	uint8                                        Pad_202F[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPlayerController*                  M_pLocalPlayerController;                          // 0x2B0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        M_pLocalPlayerPawn;                                // 0x2B8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerState*                       M_pLocalPlayerState;                               // 0x2C0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerUI*                          M_pLocalPlayerUI;                                  // 0x2C8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_simPausers_ServerOnly;                           // 0x2D0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         M_seamlessTravelPending_ServerOnly;                // 0x2E0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2030[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_lastRealTimeSeconds;                             // 0x2E4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_realDeltaSeconds;                                // 0x2E8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_combatInhibitableSeconds;                        // 0x2EC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_isSimPaused;                                     // 0x2F0(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isLocalPlayerReadyForGameplay;                   // 0x2F1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_allExpectedPlayersReadyEventSent;                // 0x2F2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2031[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPlayerReadyInfo                   R_playerReadyInfo;                                 // 0x2F4(0x8)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	enum class EQtnSessionPrivacy                M_lastSessionPrivacy;                              // 0x2FC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2032[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTag                          R_scriptedVOScene;                                 // 0x300(0x8)(Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          R_enemyLeaderSpeaker;                              // 0x308(0x8)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        CombatLingerDuration;                              // 0x310(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_combatRampdownTimer;                             // 0x314(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnPlayerNameplateManagerComponent> NameplateManagerClass;                             // 0x318(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnPlayerNameplateManagerComponent*   M_pNameplateManagerComponent;                      // 0x320(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x328(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AQtnPlayerState*>               R_authoritativePlayerArray;                        // 0x330(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<int32>                                M_availablePlayerNumbers_ServerOnly;               // 0x340(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnTutorialStateChangedEvent;                       // 0x350(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnTutorialSubGoalStateChangedEvent;                // 0x360(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnLootTableGlobals>      LootTableGlobalsClass;                             // 0x370(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnLootTableGlobals*                  M_pLootTableGlobals;                               // 0x378(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnVOManager>             VoManagerClass;                                    // 0x380(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnVOManager*                         M_pVOManager;                                      // 0x388(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFXManager*                         M_pFXManager;                                      // 0x390(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnActorPoolManager*                  M_pActorPoolManager;                               // 0x398(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnUserWidgetPoolManager*             M_pWidgetPoolManager;                              // 0x3A0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnTeamManagerComponent*              M_pTeamManager;                                    // 0x3A8(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnDamageReceptorManager*             M_pDamageReceptorManager;                          // 0x3B0(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnSpokeManager>          SpokesManagerClass;                                // 0x3B8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnSpokeManager*                      M_pSpokeManager;                                   // 0x3C0(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnBullshitManagerComponent*          M_pBullshitManager;                                // 0x3C8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnGoalManager*                       R_pGoalManager;                                    // 0x3D0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnSkirmishManager>       SkirmishManagerClass;                              // 0x3D8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnSkirmishManager*                   R_pSkirmishManager;                                // 0x3E0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UQtnUpgrade>>       R_CurrentEnemyUpgrades;                            // 0x3E8(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnReplicatedEnemyUpgradeArrayChangedEvent;         // 0x3F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FQtnRolledUpgradeData>         R_EnemyUpgradeLevels;                              // 0x408(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnReplicatedEnemyUpgradeLevelsArrayChangedEvent;   // 0x418(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSessionPrivacyChanged;                           // 0x428(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UQtnEventManager*                      M_pEventManager;                                   // 0x438(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnEventHandlerMissionStats*          R_pEventHandlerMissionStats;                       // 0x440(0x8)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_playerStatesChangePending;                       // 0x448(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2033[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnPlayerStatesChangedDelegate;                     // 0x450(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerStateRemoved;                              // 0x460(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_2034[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TimeDilationInterpSpeed;                           // 0x488(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2035[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            SimPauseEvent;                                     // 0x490(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlatformLocalLoginEvent;                           // 0x4A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlatformLocalLogoutEvent;                          // 0x4B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlatformLocalControllerChangedEvent;               // 0x4C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ReadyForUIEvent;                                   // 0x4D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            EnteringConstrainedModeEvent;                      // 0x4E0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ReturningFromConstrainedModeEvent;                 // 0x4F0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerEnterWorldEvent;                             // 0x500(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerExitWorldEvent;                              // 0x510(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerOccupyBodyEvent;                             // 0x520(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerUnOccupyBodyEvent;                           // 0x530(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerDeathEvent;                                  // 0x540(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerReviveEvent;                                 // 0x550(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ActorQtnSpawnedEvent;                              // 0x560(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            QtnReadyForGameplayEvent;                          // 0x570(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAllExpectedPlayersReady;                         // 0x580(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>            CommonLocalActorsForAutoSpawnBodyMaps;             // 0x590(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                         M_combatStatusNeedsRefresh;                        // 0x5A0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2036[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnBodyPawn*>                  L_playersInCombat;                                 // 0x5A8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AQtnBodyPawn*>                  R_playersInCombat;                                 // 0x5B8(0x10)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyPawn*>                  M_playersThatHaveJoinedMostRecentCombat;           // 0x5C8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         R_allyBotsInCombat;                                // 0x5D8(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2037[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AActor*>                        L_bossThreats;                                     // 0x5E0(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                        R_bossThreats;                                     // 0x5F0(0x10)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            BossThreatEvent;                                   // 0x600(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerCombatEvent;                                 // 0x610(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            CombatEvent;                                       // 0x620(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            LocalTutorialEvent;                                // 0x630(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AQtnPlayerPawn*>                M_cheatingDevs;                                    // 0x640(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            QtnDevCheatsEnabledEvent;                          // 0x650(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UQtnBreadCrumbComponent*>       M_trackedBreadCrumbs;                              // 0x660(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AQtnBodyPawn>, int32> M_spawnedAICounts;                                 // 0x670(0x50)(Transient, NativeAccessSpecifierPublic)
	TArray<class UObject*>                       M_localActiveCutscenes;                            // 0x6C0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         M_cutsceneWantsWorldCleanup;                       // 0x6D0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_cutscenesAllowTrainingWidgets;                   // 0x6D1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2038[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            LocalCutsceneEvent;                                // 0x6D8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AQtnLootManagementVolume*>      M_lootManagementVolumes;                           // 0x6E8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	enum class EQtnDifficulty                    R_difficulty;                                      // 0x6F8(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnArcEnum                       R_effectiveArc;                                    // 0x6F9(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2039[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            DifficultyChangeEvent;                             // 0x700(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UObject*>                       M_combatInhibitors_ServerOnly;                     // 0x710(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         R_isCombatInhibited;                               // 0x720(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_203A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            CombatInhibitedEvent;                              // 0x728(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class UComponentAggregation*> ComponentAggregations_StartPhysics;                // 0x738(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UComponentAggregation*> ComponentAggregations_PrePhysics;                  // 0x788(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UComponentAggregation*> ComponentAggregations_DuringPhysics;               // 0x7D8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UComponentAggregation*> ComponentAggregations_PostPhysics;                 // 0x828(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UComponentAggregation*> ComponentAggregations_EndPhysics;                  // 0x878(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UComponentAggregation*> ComponentAggregations_Default;                     // 0x8C8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UActorAggregation*>  ActorAggregations_StartPhysics;                    // 0x918(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UActorAggregation*>  ActorAggregations_PrePhysics;                      // 0x968(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UActorAggregation*>  ActorAggregations_DuringPhysics;                   // 0x9B8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UActorAggregation*>  ActorAggregations_PostPhysics;                     // 0xA08(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UActorAggregation*>  ActorAggregations_EndPhysics;                      // 0xA58(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UActorAggregation*>  ActorAggregations_Default;                         // 0xAA8(0x50)(Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AQtnGameState* GetDefaultObj();

	void WaitForReadyForGameplay(class AQtnGameState* GameState, const struct FLatentActionInfo& LatentInfo, class AQtnGameState** ReadyGameState);
	void WaitForAllExpectedPlayersReady(class AQtnGameState* GameState, const struct FLatentActionInfo& LatentInfo, class AQtnGameState** ReadyGameState, int32* NumExpectedPlayers, int32* NumReadyPlayers);
	void SetScriptedVOScene_ServerOnly(const struct FGameplayTag& ScriptedVOScene);
	void SetEnemyLeaderSpeaker_ServerOnly(const struct FGameplayTag& EnemyLeaderSpeaker);
	void SetEffectiveArc_ServerOnly(enum class EQtnArcEnum DesiredArc);
	void SetDifficulty_ServerOnly(enum class EQtnDifficulty DesiredDifficulty);
	void SetCutscenesAllowTrainingWidgets();
	void RemoveSimPauser_ServerOnly(class UObject* TimeStopper);
	void RemoveLocalActiveCutscene(class UObject* LocalCutsceneObject);
	void RemoveCombatInhibitor_ServerOnly(class UObject* CombatInhibitor);
	void RemoveBossThreat_ServerOnly(class AActor* bossActor);
	void ReadyForGameplay(bool IsServer);
	void QtnTutorialStateChangeEvent__DelegateSignature(const struct FQtnTutorialInstanceData& TutorialInstance);
	void QtnSimPauseEvent__DelegateSignature(bool Paused);
	void QtnReadyForUIEvent__DelegateSignature(class AQtnPlayerController* LocalPlayerController, class AQtnPlayerUI* LocalPlayerUI);
	void QtnReadyForGameplayEvent__DelegateSignature(class AQtnPlayerController* LocalPlayerController, class AQtnPlayerUI* LocalPlayerUI, class AQtnBodyPawn* LocalOccupiedBodyPawn);
	void QtnPlayerOccupyBodyEvent__DelegateSignature(class AQtnPlayerPawn* PlayerPawnSoul, class AQtnBodyPawn* OccupiedBodyPawn, bool IsLocalPlayer);
	void QtnPlayerExitWorldEvent__DelegateSignature(class AQtnPlayerPawn* PlayerPawnSoul, class AQtnBodyPawn* OccupiedBodyPawn);
	void QtnPlayerEnterWorldEvent__DelegateSignature(class AQtnPlayerPawn* PlayerPawnSoul, class AQtnBodyPawn* OccupiedBodyPawn, bool IsLocalPlayer);
	void QtnPlayerCombatEvent__DelegateSignature(class AQtnBodyPawn* PlayerBody, bool CombatBeginning);
	void QtnPlayerBodyAliveChangeEvent__DelegateSignature(class AQtnPlayerPawn* PlayerPawnSoul, class AQtnBodyPawn* PlayerBodyPawn, bool IsServer);
	void QtnPlatformLocalLogoutEvent__DelegateSignature();
	void QtnPlatformLocalLoginEvent__DelegateSignature();
	void QtnPlatformLocalControllerChangedEvent__DelegateSignature(bool PluggedIn);
	void QtnOnPlayerStatesChanged__DelegateSignature();
	void QtnOnPlayerStateRemoved__DelegateSignature(class AQtnPlayerState* PPlayerState);
	void QtnLocalTutorialEvent__DelegateSignature(TSubclassOf<class UQtnTutorial> TutorialArchetype, bool IsReminder);
	void QtnLocalCutsceneEvent__DelegateSignature(bool IsCutsceneActive, bool DoWorldCleanup);
	void QtnDifficultyChangeEvent__DelegateSignature(enum class EQtnDifficulty NewDifficulty);
	void QtnDevCheatsEnabledEvent__DelegateSignature(class AQtnPlayerPawn* PlayerPawn, bool Enabled);
	void QtnCombatInhibitedEvent__DelegateSignature(bool IsInhibited, bool IsServer);
	void QtnCombatEvent__DelegateSignature(bool CombatBeginning);
	void QtnBossThreatEvent__DelegateSignature(class AActor* bossThreat, bool CombatBeginning);
	void QtnAppLifetimeDelegate__DelegateSignature();
	void QtnAllExpectedPlayersReadyEvent__DelegateSignature(int32 NumExpectedPlayers, bool IsServer);
	void QtnActorSpawnedEvent__DelegateSignature(class AQtnSpawner* Spawner, class AActor* SpawnedActor);
	void OnSetScriptedVOScene_ServerOnly(const struct FGameplayTag& ScriptedVOScene);
	void OnRep_ScriptedVOScene();
	void OnRep_PlayersInCombat();
	void OnRep_PlayerReadyInfo();
	void OnRep_IsSimPaused();
	void OnRep_IsCombatInhibited();
	void OnRep_EnemyUpgradeLevels();
	void OnRep_Difficulty();
	void OnRep_CurrentEnemyUpgrades();
	void OnRep_BossThreats();
	void OnEnemyUpgradesArrayChanged();
	void OnEnemyUpgradeLevelsArrayChanged();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void MulticastWorldCleanup(bool LootPickups);
	void MulticastStepMode(bool WantStepMode);
	void MulticastPlayersOnly(bool WantPlayersOnly);
	void MulticastOnPlayerStatesChanged();
	bool IsSimPaused();
	bool IsReadyForGameplay();
	bool IsLocalCutsceneActive(bool* DoWorldCleanup);
	bool IsCombatInhibited();
	bool HasPlayerJoinedMostRecentCombat(class AQtnBodyPawn* PlayerBody);
	class UQtnVOManager* GetVOManager();
	class UQtnTeamManagerComponent* GetTeamManager();
	float GetQtnTimeSeconds(class UObject* WorldContextObject);
	float GetQtnRealDeltaSeconds(class UObject* WorldContextObject);
	class UQtnPlayerNameplateManagerComponent* GetQtnNameplateManagerComponent(class UObject* WorldContextObject);
	class AQtnGameState* GetQtnGameState(class UObject* SelfReference);
	void GetPlayersAndBossesInCombat(TArray<class AQtnBodyPawn*>* PlayerBodies, TArray<class AActor*>* bossThreats);
	class UQtnGameInstance* GetOwningGameInstance();
	class AQtnPlayerUI* GetLocalPlayerUI();
	class AQtnPlayerState* GetLocalPlayerState();
	class AQtnPlayerPawn* GetLocalPlayerPawn();
	class AQtnBodyPawn* GetLocalPlayerOriginalBody();
	class AQtnBodyPawn* GetLocalPlayerOccupiedBody();
	class AQtnPlayerController* GetLocalPlayerController();
	TArray<struct FQtnRolledUpgradeData> GetEnemyUpgradeLevels();
	enum class EQtnArcEnum GetEffectiveArc();
	enum class EQtnDifficulty GetDifficulty();
	TArray<TSubclassOf<class UQtnUpgrade>> GetCurrentEnemyUpgrades();
	float GetCombatInhibitableSeconds(class UObject* WorldContextObject);
	TArray<class AQtnPlayerPawn*> GetCheatingDevs();
	TArray<class AQtnPlayerState*> GetAuthoritativePlayerArray();
	void DoWorldCleanup_ServerOnly(bool LootPickups, bool DeadBodies, bool LivingBodies, const TArray<TSubclassOf<class AQtnPawn>>& PawnTypesToIgnore);
	bool DoCutscenesAllowTrainingWidgets();
	bool AreDevCheatsLocallyEnabled();
	bool AreBotsOrPlayersInCombat();
	bool AreAllExpectedPlayersReady(int32* NumExpectedPlayers, int32* NumReadyPlayers);
	void AddSimPauser_ServerOnly(class UObject* TimeStopper);
	void AddLocalActiveCutscene(class UObject* LocalCutsceneObject, bool DoWorldCleanup);
	void AddCombatInhibitor_ServerOnly(class UObject* CombatInhibitor);
	void AddBossThreat_ServerOnly(class AActor* bossActor);
};

// 0x38 (0x398 - 0x360)
// Class QtnGame.QtnGameViewportClient
class UQtnGameViewportClient : public UGameViewportClient
{
public:
	uint8                                        Pad_203C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_fadeStartTime;                                   // 0x364(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_fadeDuration;                                    // 0x368(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntPoint                             M_viewportDimensionsThisFrame;                     // 0x36C(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_203D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_fadeTokens;                                      // 0x378(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UQtnScreenLoading*>             M_loadingScreens;                                  // 0x388(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnGameViewportClient* GetDefaultObj();

};

// 0x0 (0x250 - 0x250)
// Class QtnGame.QtnGenericDestructable
class AQtnGenericDestructable : public AQtnReplicatedActor
{
public:

	static class UClass* StaticClass();
	static class AQtnGenericDestructable* GetDefaultObj();

};

// 0xD0 (0xF8 - 0x28)
// Class QtnGame.QtnGlobalRunProgress
class UQtnGlobalRunProgress : public UObject
{
public:
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasCheckpointHappened;                           // 0x30(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2042[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<TSubclassOf<class UQtnRunSubProgress>, class UQtnRunSubProgress*> M_trackedSubProgress;                              // 0x38(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnRunSubProgress>> DefaultSubProgresses;                              // 0x88(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnPlayerRunProgress>     PlayerProgressArchetype;                           // 0x98(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, class UQtnPlayerRunProgress*> M_trackedPlayerProgress;                           // 0xA0(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	enum class EQtnDifficulty                    M_runDifficulty;                                   // 0xF0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2043[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnGlobalRunProgress* GetDefaultObj();

	void SetRunDifficulty_ServerOnly(enum class EQtnDifficulty RunDifficulty);
	void ResetRunProgress_ServerOnly();
	void OnRunProgressReset_ServerOnly();
	void OnRunProgressCheckpoint_ServerOnly(bool FlushMissionProgress);
	void OnPlayerExitWorld_ServerOnly(class AQtnPlayerPawn* PlayerPawn, class AQtnBodyPawn* PlayerBody);
	void OnPlayerEnterWorld_ServerOnly(class AQtnPlayerPawn* PlayerPawn, class AQtnBodyPawn* PlayerBody, bool HasCheckpointHappened);
	void OnMapEndPlay_ServerOnly(bool TravelPending);
	void OnMapBeginPlay_ServerOnly();
	void OnGlobalRunProgressInit();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnAllExpectedPlayersReady_ServerOnly(int32 NumExpectedPlayers);
	bool HasCheckpointHappened_ServerOnly();
	class UQtnRunSubProgress* GetSubProgress_ServerOnly(TSubclassOf<class UQtnRunSubProgress> SubProgressArchetype);
	class FString GetStringFromNetId(struct FUniqueNetIdRepl& PlayerUniqueNetId);
	enum class EQtnDifficulty GetRunDifficulty_ServerOnly();
	class UQtnPlayerRunProgress* GetPlayerRunProgressFromUniqueNetId_ServerOnly(struct FUniqueNetIdRepl& PlayerUniqueNetId);
	class UQtnPlayerRunProgress* GetPlayerRunProgress_ServerOnly(class AQtnPlayerState* PlayerState);
	class UQtnGlobalRunProgress* GetGlobalRunProgress_ServerOnly(class UObject* WorldContextObject);
	struct FUniqueNetIdRepl GetEmptyNetId();
	void CheckpointRunProgress_ServerOnly(bool FlushMissionProgress);
	class UQtnRunSubProgress* AddSubProgress_ServerOnly(TSubclassOf<class UQtnRunSubProgress> SubProgressArchetype);
};

// 0x30 (0x58 - 0x28)
// Class QtnGame.QtnGoal
class UQtnGoal : public UObject
{
public:
	uint8                                        Pad_2049[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnGoalManager*                       R_pOwningGoalManager;                              // 0x30(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UQtnGoal*>                      R_childGoals;                                      // 0x38(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	enum class EQtnGoalStatus                    L_goalStatus;                                      // 0x48(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnGoalStatus                    R_goalStatus;                                      // 0x49(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_204B[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTag                          GoalID;                                            // 0x4C(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_204C[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnGoal* GetDefaultObj();

	void StartGoal_ServerOnly();
	class UQtnGoal* SpawnChildGoal_ServerOnly(TSoftClassPtr<class UQtnGoal> SoftGoalClass);
	void OnTickActiveGoal(float DeltaSeconds);
	void OnRep_GoalStatus();
	void OnPlayerExitWorld_ServerOnly(class AQtnPlayerPawn* PlayerSoul, class AQtnBodyPawn* PlayerBody);
	void OnPlayerEnterWorld_ServerOnly(class AQtnPlayerPawn* PlayerSoul, class AQtnBodyPawn* PlayerBody);
	void OnGoalStart(bool WillEndImmediatelyFromLateJoin);
	void OnGoalSpawned_ServerOnly();
	void OnGoalEnd(bool JustStartedFromLateJoin);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsOnServer();
	class UQtnGoalManager* GetOwningGoalManager();
	float GetGoalWeight(TSubclassOf<class UQtnGoal> GoalClass);
	enum class EQtnGoalStatus GetGoalStatus();
	TArray<class UQtnGoal*> GetChildGoals();
	void EndGoal_ServerOnly();
	float CalculateGoalWeight();
};

// 0xA8 (0xD0 - 0x28)
// Class QtnGame.QtnGoalManager
class UQtnGoalManager : public UObject
{
public:
	uint8                                        Pad_2054[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnGameState*                         R_pOwningGameState;                                // 0x30(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UQtnGoal*>                      R_seedGoals;                                       // 0x38(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnGoal*>                      M_activeGoals;                                     // 0x48(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnGoal*>                      M_pendingGoalsWithStatusChanges;                   // 0x58(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AActor>, struct FQtnGoalMarkerBucket> M_goalMarkerBuckets_ServerOnly;                    // 0x68(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_expectedPlayersReady_ServerOnly;                 // 0xB8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2055[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnGoal>>          M_spawningGoalChain;                               // 0xC0(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnGoalManager* GetDefaultObj();

	class UQtnGoal* SpawnSeedGoal_ServerOnly(TSoftClassPtr<class UQtnGoal> SoftGoalClass);
	void SortGoalsByWeight(TArray<TSubclassOf<class UQtnGoal>>& UnSortedGoalClasses, TArray<struct FQtnGoalWeightPair>* SortedGoalClasses, float* TotalWeight, float EliminateGoalsAtOrBelowThisWeight);
	void SetupSeedGoals_ServerOnly();
	void SelectRandomGoalsByWeight(TArray<TSubclassOf<class UQtnGoal>>& PossibleGoalClasses, TArray<TSubclassOf<class UQtnGoal>>* SelectedGoalClasses, float EliminateGoalsAtOrBelowThisWeight, int32 MaxNumberToSelect);
	void OnReadyForGameplay_ServerOnly();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	TArray<TSubclassOf<class UQtnGoal>> LoadGoalClasses(TArray<TSoftClassPtr<class UQtnGoal>>& SoftGoalClasses);
	TSubclassOf<class UQtnGoal> LoadGoalClass(TSoftClassPtr<class UQtnGoal> SoftGoalClass);
	bool IsOnServer();
	TArray<class UQtnGoal*> GetSeedGoals();
	class UQtnGoalManager* GetGoalManager(class UObject* WorldContextObject);
	void FindMarkedActors_ServerOnly(TSubclassOf<class AActor> ActorClass, TArray<struct FGameplayTag>& GameplayTags, TArray<class FName>& MarkerComponentTags, TArray<class AActor*>* FoundActors);
	void FindGoals(TSubclassOf<class UQtnGoal> GoalClass, TArray<class UQtnGoal*>* FoundGoals, bool ActiveGoalsOnly);
};

// 0x8 (0xD8 - 0xD0)
// Class QtnGame.QtnGoalManagerBaseNative
class UQtnGoalManagerBaseNative : public UQtnGoalManager
{
public:
	int32                                        R_currentArc;                                      // 0xD0(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_205A[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnGoalManagerBaseNative* GetDefaultObj();

	void SetCurrentArc_ServerOnly(int32 DesiredCurrentArc);
	void OnRep_CurrentArc();
	void OnCurrentArcChange(int32 NewArc);
	int32 GetCurrentArc();
};

// 0x10 (0xF0 - 0xE0)
// Class QtnGame.QtnGoalMarkerComponent
class UQtnGoalMarkerComponent : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                  GameplayTags;                                      // 0xE0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnGoalMarkerComponent* GetDefaultObj();

};

// 0x180 (0x3E0 - 0x260)
// Class QtnGame.QtnHealthBarWidget
class UQtnHealthBarWidget : public UUserWidget
{
public:
	bool                                         IsStatusThresholdMet;                              // 0x260(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2069[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnAttribute*>                 ActiveAttributesArray;                             // 0x268(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UQtnStatusEffect*>              ActiveStatusEffectArray;                           // 0x278(0x10)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UQtnAttribute*                         MaximumTrackedThresholdAttribute;                  // 0x288(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnDamageReceptorComponent*           DamageReceptorComponent;                           // 0x290(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnAttributeComponent*                AttributeComponent;                                // 0x298(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnAttribute*                         HealthAttribute;                                   // 0x2A0(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnAttribute*                         MaxHealthAttribute;                                // 0x2A8(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnHealthBarInitializationParameters HealthBarParameters;                               // 0x2B0(0x50)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UImage*                                HealthBarImage;                                    // 0x300(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              HealthBarMaterial;                                 // 0x308(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                StatusBarImage;                                    // 0x310(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                StatusBarGlowImage;                                // 0x318(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              StatusBarMaterial;                                 // 0x320(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              StatusBarGlowMaterial;                             // 0x328(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                              StandardStatusIconOverlay;                         // 0x330(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                StandardStatusIcon;                                // 0x338(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                StandardStatusIconGlow;                            // 0x340(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              StandardStatusIconMaterial;                        // 0x348(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              StandardStatusIconGlowMaterial;                    // 0x350(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                              BossStatusIconOverlay;                             // 0x358(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                BossStatusIcon;                                    // 0x360(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                BossStatusIconGlow;                                // 0x368(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              BossStatusIconMaterial;                            // 0x370(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              BossStatusIconGlowMaterial;                        // 0x378(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                            NameText;                                          // 0x380(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bIsHealthBarInhibited;                           // 0x388(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_206A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPlayerPawn*                        M_pLocalPlayerPawn;                                // 0x390(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         HealthBarEnabled;                                  // 0x398(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_206B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_LastVisibilityRequestTime;                       // 0x39C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                          M_FadeOutTimer;                                    // 0x3A0(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                          M_FadeTimerHandle;                                 // 0x3A8(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_CurrentFadeRunTime;                              // 0x3B0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_fadeStartTime;                                   // 0x3B4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_FadeStartValue;                                  // 0x3B8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_FadeTargetValue;                                 // 0x3BC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_fadeDuration;                                    // 0x3C0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_206C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FTimerHandle                          M_DamageFlashTimer;                                // 0x3C8(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_DamageFlashStartTime;                            // 0x3D0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_CurrentDamageFlashRunTime;                       // 0x3D4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_DamageFlashDuration;                             // 0x3D8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_206D[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnHealthBarWidget* GetDefaultObj();

	void TickInterpolateOpacity();
	void TickFlashDamage();
	bool ShouldHealthBarBeVisible();
	void OnStopHealthDamageEvent();
	void OnStopAttributeDamageEvent();
	void OnStatusEffectStartedEvent(class UQtnStatusEffect* StatusEffect);
	void OnStatusEffectEndedEvent(class UQtnStatusEffect* StatusEffect);
	void OnStartHealthDamageEvent();
	void OnStartAttributeDamageEvent();
	void OnRequestFadeOutHealthBar();
	void OnRequestFadeInHealthBar();
	void OnMaxHealthValueChanged(class UQtnAttribute* Attribute, float Value);
	void OnHealthValueChanged(class UQtnAttribute* Attribute, float Value);
	void OnHealthBarInhibitorChangedEvent(bool IsInhibited);
	void OnFadeOutTimerCompleted();
	void OnBodyAlivenessChanged(class AQtnBodyPawn* bodyPawn, class AActor* AlivenessInstigator, enum class EQtnBodyAliveness OldBodyAliveness, enum class EQtnBodyAliveness bodyAliveness, bool IsServer);
	void OnAttributeValueMetThreshold(class UQtnAttribute* Attribute, float Value);
	void OnAttributeValueDepleted(class UQtnAttribute* Attribute, float Value);
	void OnAttributeValueChanged(class UQtnAttribute* Attribute, float Value);
	void OnAttributeRemovedEvent(TSubclassOf<class UQtnAttribute> AttributeClass, class UQtnAttribute* Attribute);
	void InitializeHealthBar(class UQtnDamageReceptorComponent* DamageReceptor, struct FQtnHealthBarInitializationParameters& InitializationParams);
	void CompleteBindings();
	void BindToHealthAttributes(class UQtnAttribute* InHealthAttribute, class UQtnAttribute* InMaxHealthAttribute);
	bool BindTextWidgets(class UTextBlock* InNameText);
	bool BindStandardIconWidgets(class UOverlay* Overlay, class UImage* StatusIcon, class UImage* StatusIconGlow);
	bool BindBossIconWidgets(class UOverlay* Overlay, class UImage* StatusIcon, class UImage* StatusIconGlow);
	bool BindBarWidgets(class UImage* HealthBar, class UImage* StatusBar, class UImage* StatusBarGlow);
	void BindAttributeCallbacks(class UQtnAttribute* Attribute);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnHijackableInterface
class IQtnHijackableInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnHijackableInterface* GetDefaultObj();

};

// 0x78 (0x520 - 0x4A8)
// Class QtnGame.QtnHintVolumeComponent
class UQtnHintVolumeComponent : public UBoxComponent
{
public:
	TMap<class AQtnBodyController*, struct FVector> M_registeredAIs;                                   // 0x4A8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyController*>            M_foregroundThreats;                               // 0x4F8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                        AIFloodControlCapacity;                            // 0x508(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DeepSnow;                                          // 0x50C(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_206F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftObjectPtr<class AActor>>         AIFloodControlWaypoints;                           // 0x510(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnHintVolumeComponent* GetDefaultObj();

};

// 0x1B8 (0x320 - 0x168)
// Class QtnGame.QtnInputComponent
class UQtnInputComponent : public UInputComponent
{
public:
	uint8                                        Pad_2071[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnInputContext>>  M_InputContextStack;                               // 0x170(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2072[0x190];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x310(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnInputComponent* GetDefaultObj();

	void StaticResetKeyBindings(class UObject* WorldContextObject);
	void StaticRebindInputAction(class UObject* WorldContextObject, class FName ActionName, const struct FKey& Key);
	class FString StaticParseInputText(class UObject* WorldContextObject, class FText InputText, bool EncloseKeyboardKeysInBrackets);
	class UQtnInputComponent* StaticGetLocalInputComponent(class UObject* WorldContextObject);
	void StaticBeginRebindInputAction(class UObject* WorldContextObject, class FName ActionName, const struct FLatentActionInfo& LatentInfo);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
};

// 0x40 (0x78 - 0x38)
// Class QtnGame.QtnInputConfig
class UQtnInputConfig : public UDeveloperSettings
{
public:
	TArray<struct FQtnRebindableInputCategory>   RebindableInputsByCategory;                        // 0x38(0x10)(Edit, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<class FName>                          ImmutableInputs;                                   // 0x48(0x10)(Edit, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FKey>                          WhitelistedKeys;                                   // 0x58(0x10)(Edit, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FKey>                          CancelKeys;                                        // 0x68(0x10)(Edit, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnInputConfig* GetDefaultObj();

	TArray<struct FQtnRebindableInputCategory> StaticGetRebindableInputsByCategories();
};

// 0xA8 (0xD0 - 0x28)
// Class QtnGame.QtnInputContext
class UQtnInputContext : public UObject
{
public:
	TMap<class FName, class FName>               InputActionMap;                                    // 0x28(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, float>                     AxisScalarMap;                                     // 0x78(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                         SuppressUnmappedInputs;                            // 0xC8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2073[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnInputContext* GetDefaultObj();

};

// 0x28 (0x148 - 0x120)
// Class QtnGame.QtnInputDataBag
class UQtnInputDataBag : public UQtnDataBag
{
public:
	class UQtnInputComponent*                    M_pAssociatedInputComponent;                       // 0x120(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FInputActionKeyMapping>        SavedActionMappings;                               // 0x128(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>          SavedAxisMappings;                                 // 0x138(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnInputDataBag* GetDefaultObj();

};

// 0x0 (0x2A8 - 0x2A8)
// Class QtnGame.QtnInputFixupTextBlock
class UQtnInputFixupTextBlock : public UTextBlock
{
public:

	static class UClass* StaticClass();
	static class UQtnInputFixupTextBlock* GetDefaultObj();

};

// 0x0 (0x2A8 - 0x2A8)
// Class QtnGame.QtnInputTextBlock
class UQtnInputTextBlock : public UTextBlock
{
public:

	static class UClass* StaticClass();
	static class UQtnInputTextBlock* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class QtnGame.QtnInputTextMappingDataAsset
class UQtnInputTextMappingDataAsset : public UDataAsset
{
public:
	TArray<struct FTextMapping>                  TextKeyMappings;                                   // 0x30(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnInputTextMappingDataAsset* GetDefaultObj();

	void CheckAndRetrieveCorrectMapping(class FString& OutLocalizationString, class FText& CurrentLocalizationText, bool IsMouseAndKeyboard);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnInstantUpgrade
class UQtnInstantUpgrade : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnInstantUpgrade* GetDefaultObj();

	bool K2_ActivateUpgrade(class AQtnBodyPawn* TargetUser, struct FQtnRolledUpgradeResult& RolledUpgradeSettings);
};

// 0x470 (0x550 - 0xE0)
// Class QtnGame.QtnInventoryComponent
class UQtnInventoryComponent : public UActorComponent
{
public:
	uint8                                        Pad_2085[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0xE8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FQtnItemData>                  R_vaultWeapons;                                    // 0xF8(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnItemData>                  R_vaultPowers;                                     // 0x108(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                        R_rangedEquipmentOnRepInducer;                     // 0x118(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2086[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnItemEntry>                 R_rangedEquipment;                                 // 0x120(0x10)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnItemEntry>                 L_rangedEquipment;                                 // 0x130(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                        R_meleeEquipmentOnRepInducer;                      // 0x140(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2087[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnItemEntry>                 R_meleeEquipment;                                  // 0x148(0x10)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnItemEntry>                 L_meleeEquipment;                                  // 0x158(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                        R_nonEquippableItemsOnRepInducer;                  // 0x168(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2088[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnItemEntry>                 R_nonEquippableItems;                              // 0x170(0x10)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnItemEntry>                 L_nonEquippableItems;                              // 0x180(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FQtnItemData                          R_power1ItemData;                                  // 0x190(0x68)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FQtnItemData                          R_power2ItemData;                                  // 0x1F8(0x68)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                DefaultPower1Stat;                                 // 0x260(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                DefaultPower2Stat;                                 // 0x270(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnItemData                          M_defaultMeleeWeapon_ServerOnly;                   // 0x280(0x68)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FQtnItemData                          M_defaultRangedWeapon_ServerOnly;                  // 0x2E8(0x68)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FQtnItemData                          M_defaultPower1_ServerOnly;                        // 0x350(0x68)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FQtnItemData                          M_defaultPower2_ServerOnly;                        // 0x3B8(0x68)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                         M_hasReceivedInventory_ServerOnly;                 // 0x420(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_hasEverBeenReadyForGameplay;                     // 0x421(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2089[0x26];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnPowerChange_ServerOnly;                          // 0x448(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AQtnItem>, int32>     DefaultItems;                                      // 0x458(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                         IgnoreInventoryCapacity;                           // 0x4A8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_208A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnInventoryItemAdded;                              // 0x4B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ItemAddNotificationEvent;                          // 0x4C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInventoryItemRemoved;                            // 0x4D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ItemRemoveNotificationEvent;                       // 0x4E0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInventoryItemAddedDisplayOnlyNotificationEvent;  // 0x4F0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInventoryRefreshed;                              // 0x500(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FQtnCurrencyEntry>             R_currencyArray;                                   // 0x510(0x10)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FQtnCurrencyEntry>             L_currencyArray;                                   // 0x520(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCurrencyChange;                                  // 0x530(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSpecificCurrencyChange;                          // 0x540(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnInventoryComponent* GetDefaultObj();

	bool TryCosmeticPurchase(const struct FGameplayTag& CurrencyTag, int32 CurrencyPrice);
	class AQtnItem* SpawnWeapon_ServerOnly(struct FQtnItemData& WeaponItemData);
	void SetRangedUpgrades_ServerOnly(TArray<struct FQtnUpgradeRunProgressData>& RangedUpgrades);
	void SetPower2ItemData_ServerOnly(struct FQtnItemData& PowerItemData);
	void SetPower1ItemData_ServerOnly(struct FQtnItemData& PowerItemData);
	void SetMeleeUpgrades_ServerOnly(TArray<struct FQtnUpgradeRunProgressData>& MeleeUpgrades);
	void ServerSubtractCurrency(const struct FGameplayTag& CurrencyTag, int32 QuantityToSubtract, class UObject* Instigator);
	void ServerSpawnAndAddInventoryItem(TSubclassOf<class AQtnItem> ItemClass, int32 StackCount, bool NotifyPlayerUI);
	void ServerSetPower2ItemData(struct FQtnItemData& PowerItemData);
	void ServerSetPower1ItemData(struct FQtnItemData& PowerItemData);
	void ServerSetItemStackCount(TSubclassOf<class AQtnItem> ItemClass, int32 StackCount, bool NotifyUI);
	void ServerSetDefaultLoadout(struct FQtnItemData& MeleeWeapon, struct FQtnItemData& RangedWeapon, struct FQtnItemData& Power1, struct FQtnItemData& Power2);
	void ServerSetCurrency(const struct FGameplayTag& CurrencyTag, int32 Quantity);
	void ServerResetCurrency();
	void ServerRequestWeapon(int32 VaultIndex, bool RemoveOtherWeaponsFromSlot);
	void ServerRemoveSpecificItem(class AQtnItem* PItemToRemove, bool DropItIntoTheWorld, bool NotifyPlayerUI);
	void ServerRemoveItem(TSubclassOf<class AQtnItem> ItemClass, int32 StackCount, bool NotifyUI);
	void ServerDropItem(TSubclassOf<class AQtnItem> ItemClass, int32 StackCount);
	void ServerAddCurrency(const struct FGameplayTag& CurrencyTag, int32 QuantityToAdd, class UObject* Instigator);
	void OnRep_RangedEquipmentOnRepInducer();
	void OnRep_RangedEquipment();
	void OnRep_NonEquippableItemsOnRepInducer();
	void OnRep_NonEquippableItems();
	void OnRep_MeleeEquipmentOnRepInducer();
	void OnRep_MeleeEquipment();
	void OnRep_Currencies();
	void OnItemInventoryEquipEvent_ServerOnly(class AQtnItem* PItem, class AActor* POwningActor);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void LocalRequestWeapon(int32 VaultIndex, bool RemoveOtherWeaponsFromSlot);
	void LocalEquipOrUseItem(class AQtnItem* ItemInstance);
	bool HasInventoryItem(TSubclassOf<class AQtnItem> ItemClassToCheck, enum class EQtnItemDesignation ItemDesignation, bool AllowInheritedClasses);
	TArray<struct FQtnItemData> GetVaultWeapons();
	TArray<struct FQtnItemData> GetVaultPowers();
	TArray<struct FQtnItemEntry> GetRangedEquippables();
	struct FQtnItemData GetPower2ItemData();
	struct FQtnItemData GetPower1ItemData();
	class AQtnDronePawn* GetOwningDronePawn();
	class AQtnBodyPawn* GetOwningBodyPawn();
	TArray<struct FQtnItemEntry> GetNonEquippableItems();
	TArray<struct FQtnItemEntry> GetMeleeEquippables();
	int32 GetInventoryItemCount(TSubclassOf<class AQtnItem> ItemClassToCheck, bool ForHotkeyDisplay);
	class AQtnItem* GetInventoryItem(TSubclassOf<class AQtnItem> ItemClassToCheck, enum class EQtnItemDesignation ItemDesignation, bool AllowInheritedClasses);
	int32 GetCurrencyQuantity(const struct FGameplayTag& CurrencyTag);
	void GetCurrencyArray(TArray<struct FQtnCurrencyEntry>* CurrencyArray);
	class AQtnItem* GetBestRangedEquippable();
	class AQtnItem* GetBestMeleeEquippable();
	void ClientOnItemRemoved(TSubclassOf<class AQtnItem> ItemClass, int32 RemainingStackCount, bool NotifyPlayerUI);
	void ClientNotifyUIItemRemove(TSubclassOf<class AQtnItem> ItemClass);
	void ClientNotifyUIItemAddDisplayOnly(class AQtnItem* PLootItem);
	void ClientNotifyUIItemAdd(TSubclassOf<class AQtnItem> ItemClass);
	TArray<struct FQtnItemEntry> BuildUsableItemsDeck(TArray<struct FQtnItemEntry>& OutputDeck, class AQtnBodyPawn* IntendedVictim);
	TArray<struct FQtnItemEntry> BuildFilteredItemsList(bool RangedEquippables, bool MeleeEquippables, bool NonEquippables);
	void AddItemToVault_ServerOnly(struct FQtnItemData& ItemData);
};

// 0x318 (0x568 - 0x250)
// Class QtnGame.QtnItem
class AQtnItem : public AQtnReplicatedActor
{
public:
	uint8                                        Pad_2095[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pPreviousOwner;                                  // 0x268(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnVerbComponent*                     M_pVerbComponent;                                  // 0x270(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pOwningPawn;                                     // 0x278(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pOwningBodyPawn;                                 // 0x280(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        R_internalStackCount;                              // 0x288(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_doPhysics;                                       // 0x28C(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_pendingDestroy;                                  // 0x28D(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2096[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UStaticMeshComponent*                  M_pThirdPersonStaticMesh;                          // 0x290(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                M_pThirdPersonSkeletalMesh;                        // 0x298(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UMeshComponent*, class FName>     M_pModularThirdPersonMeshes;                       // 0x2A0(0x50)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnUpgradeSlotConfiguration>  ItemUpgradeSlots;                                  // 0x2F0(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UQtnUpgradeSlot*>               R_UpgradeSlots;                                    // 0x300(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FQtnTagPresence>               DescriptiveTags;                                   // 0x310(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                          ItemId;                                            // 0x320(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseSkeletalMeshAsPickup;                           // 0x328(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2097[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UAudioComponent*                       ItemAudioComponent;                                // 0x330(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_refreshAttachmentsPending;                       // 0x338(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2098[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnGameState*                         M_pCachedGameState;                                // 0x340(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UMeshComponent*>     M_attachedPawnSocketMeshes;                        // 0x348(0x50)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FQtnPickupVariation                   PickupVariation;                                   // 0x398(0x20)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                            PickupSoundAsset;                                  // 0x3B8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x3C0(0x28)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_ownerEvaluationPending;                          // 0x3E8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         R_shouldNotifyUI;                                  // 0x3E9(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2099[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            ItemReadyForGameplayEvent;                         // 0x3F0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnInventoryAddEvent;                               // 0x400(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInventoryRemoveEvent;                            // 0x410(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemDestroyPendingEvent;                         // 0x420(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInventoryEquipEvent;                             // 0x430(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemUseEvent;                                    // 0x440(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemActionNotifyEvent;                           // 0x450(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          R_lootRecipient;                                   // 0x460(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         R_hasEverHadLootRecipient;                         // 0x468(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_209A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFrobAccumulatorComponent*          M_pFrobAccumulator;                                // 0x470(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          L_pAccumulatingBodyPawn;                           // 0x478(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          R_pAccumulatingBodyPawn;                           // 0x480(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnThrowableComponent*                M_pThrowableComponent;                             // 0x488(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnEquippableComponent*               M_pEquippableComponent;                            // 0x490(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_hasBeenEquipped;                                 // 0x498(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_209B[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UShapeComponent*                       M_pTargetingShape;                                 // 0x4A0(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bWasDropped;                                       // 0x4A8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAllowDropping;                                    // 0x4A9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsCriticalItem;                                   // 0x4AA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowInteraction;                                  // 0x4AB(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_209C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  DisplayName;                                       // 0x4B0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0x4C8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                        InventoryCapacity;                                 // 0x4E0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        StartingPickupCount;                               // 0x4E4(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IgnoreSaveLoad;                                    // 0x4E8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DetachSkeletalMeshIfUnused;                        // 0x4E9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_209D[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FrobDistance;                                      // 0x4EC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnItemData                          R_itemData;                                        // 0x4F0(0x68)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x558(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnItem* GetDefaultObj();

	bool WillBeDestroyed();
	bool ShouldNotifyUIOfAddRemove();
	void SetPhysicsAllowed_AuthorityOnly(bool DoPhysics);
	void SetLootRecipient_ServerOnly(class AQtnBodyPawn* PLootRecipient);
	void SetItemData_AuthorityOnly(const struct FQtnItemData& ItemData);
	void ServerSetStackCount(int32 StackCount);
	void QtnOnItemReadyForGameplayEvent__DelegateSignature(class AQtnItem* ReadyItem);
	void PlayDetachedItemSound(class USoundBase* Sound, bool Spatialize);
	void PlayAttachedItemSound(class USoundBase* Sound, bool Spatialize);
	void OnRep_PendingDestroy();
	void OnRep_LootRecipient();
	void OnRep_ItemData();
	void OnRep_InternalStackCount();
	void OnRep_HasEverHadLootRecipient();
	void OnRep_DoPhysics();
	void OnRep_AccumulatingBodyPawn();
	void OnItemUse(class AQtnBodyPawn* UsingBodyPawn, enum class EQtnItemUseIntent UseIntent);
	void OnItemSetThirdPersonMeshesHidden(bool bNewHiddenInGame);
	void OnItemDestroyPending(class AActor* OwningActor);
	void OnItemActionNotify(class AQtnPawn* UsingPawn, enum class EQtnItemUseAction UseAction);
	void OnInventoryRemove(class AActor* OwningActor);
	void OnInventoryAdd(class AActor* OwningActor);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnAttachItemData(const struct FQtnItemData& ItemData);
	void MulticastPlaySound(class USoundBase* Sound, bool Spatialize, bool Attached);
	void MulticastHandleItemPickup(class AQtnBodyPawn* PFrobbingPawn);
	bool IsRangedWeapon();
	bool IsLootRecipientLocalPlayer();
	bool IsLootRecipient(class AQtnBodyPawn* PBodyPawn);
	bool IsHandMeshVisible();
	bool IsEquipped();
	bool IsBaseWeapon();
	bool HasLootRecipient();
	void HandleItemPickupDiscard_ServerOnly(class AQtnBodyPawn* FrobbingPawn);
	void HandleItemPickup_ServerOnly(class AQtnBodyPawn* FrobbingPawn);
	void HandleFrobAccumulatorSuccess(class UQtnFrobAccumulatorComponent* PAccumulator, class AQtnPawn* PLastFrobbingPawn, bool IsServer);
	class UQtnVerbComponent* GetVerbComponent();
	TArray<class UQtnUpgradeSlot*> GetUpgradeSlots();
	class AQtnPawn* GetOwningPawn();
	class UQtnInventoryComponent* GetOwningInventoryComponent();
	class AQtnBodyPawn* GetOwningBodyPawn();
	class UMeshComponent* GetMeshFromPawnSocket(class FName& SocketName);
	class AQtnBodyPawn* GetLootRecipient();
	struct FQtnItemData GetItemData();
	class AQtnItem* GetItemArchetype(TSubclassOf<class AQtnItem> ItemClass);
	class UTexture2D* GetIconForUI();
	void DropItem(int32 NumToDrop);
	void DoUseItem(class AQtnPawn* UsingPawn, class AActor* IntendedTarget, bool AltUse, enum class EQtnItemUseIntent UseIntent);
	void DetachMeshFromPawnSocket(class FName& SocketName);
	bool CanBeUsedOnTarget(class AQtnPawn* UsingPawn, class AActor* Target, bool AltUse, class FText* AffordanceMessage, class FText* RejectionMessage);
	void AttachMeshToPawnSocket(class FName& SocketName, class UMeshComponent* MeshToAttach);
	void AddModularThirdPersonStaticMesh(class UStaticMesh* StaticMesh, class UMaterialInterface* Material, class FName SocketName);
	void AddModularThirdPersonSkeletalMesh(class USkeletalMesh* SkeletalMesh, class UMaterialInterface* Material, class FName SocketName);
};

// 0x58 (0x330 - 0x2D8)
// Class QtnGame.QtnItemContainer
class AQtnItemContainer : public ASkeletalMeshActor
{
public:
	class FText                                  DisplayName;                                       // 0x2D8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0x2F0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x308(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnItemContainer* GetDefaultObj();

	class AQtnItemContainer* GetItemContainerArchetype(TSubclassOf<class AQtnItemContainer> ItemContainerClass);
	class UTexture2D* GetIconForUI();
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnItemDataProviderInterface
class IQtnItemDataProviderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnItemDataProviderInterface* GetDefaultObj();

	struct FVector FetchWorldLocation();
	bool FetchShowItemPopUpBool();
	struct FQtnItemData FetchItemData();
	class AActor* FetchItemActor();
};

// 0x60 (0x88 - 0x28)
// Class QtnGame.QtnItemGeoDatabase
class UQtnItemGeoDatabase : public UObject
{
public:
	class UQtnGameInstance*                      M_pGameInstance;                                   // 0x28(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                            ModularWeaponDataTable;                            // 0x30(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FQtnTagReactiveWeighting> GeometryDatabase;                                  // 0x38(0x50)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnItemGeoDatabase* GetDefaultObj();

	struct FQtnModularWeaponAttachment RollGeometryForPart(class UQtnTagDescriptionComponent* TagsOfItem, int32 LevelOfItem, enum class EQtnModularWeaponPart PartOfItem, class FName* ChosenName);
	TArray<struct FQtnTagReactiveWeighting> MakeTagReactionArrayFromModularWeaponArray(TArray<struct FQtnModularWeaponAttachmentConfiguration>& ModularWeaponList);
	struct FQtnModularWeaponAttachment GetConfigurationByNameAndPart(class UQtnTagDescriptionComponent* TagsOfItem, class FName NameOfItem, int32 LevelOfItem, enum class EQtnModularWeaponPart PartOfItem);
	void FindGeoOptionsByTagAndCategory(class UQtnTagDescriptionComponent* TagsOfItem, int32 LevelOfItem, enum class EQtnModularWeaponPart PartOfItem, TArray<class FName>* PossibleNames, TArray<float>* PossibleWeights, TArray<struct FQtnModularWeaponAttachmentConfiguration>* PossibleAttachments);
	struct FQtnModularWeaponConfiguration FindCorrectGeoDatabase(class UQtnTagDescriptionComponent* TagsOfItem, int32 LevelOfItem, bool* WasConfigurationFound);
	void ExtractListsGivenConfigurationAndPart(struct FQtnModularWeaponConfiguration& ConfigurationList, enum class EQtnModularWeaponPart PartOfItem, TArray<class FName>* NameList, TArray<struct FQtnModularWeaponAttachmentConfiguration>* ModularWeaponList);
};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnJsonObject
class UQtnJsonObject : public UObject
{
public:
	uint8                                        Pad_20B7[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnJsonObject* GetDefaultObj();

	void SetStringField(const class FString& FieldName, const class FString& StringValue);
	void SetStringArrayField(const class FString& FieldName, TArray<class FString>& StringArray);
	void SetObjectField(const class FString& FieldName, class UQtnJsonObject* JsonObject);
	void SetObjectArrayField(const class FString& FieldName, TArray<class UQtnJsonObject*>& ObjectArray);
	void SetIntField(const class FString& FieldName, int32 Number);
	void SetIntArrayField(const class FString& FieldName, TArray<int32>& IntArray);
	void SetFloatField(const class FString& FieldName, float Number);
	void SetFloatArrayField(const class FString& FieldName, TArray<float>& FloatArray);
	void SetFieldNull(const class FString& FieldName);
	void SetField(const class FString& FieldName, class UQtnJsonValue* JsonValue);
	void SetBoolField(const class FString& FieldName, bool InValue);
	void SetBoolArrayField(const class FString& FieldName, TArray<bool>& boolArray);
	void SetArrayField(const class FString& FieldName, TArray<class UQtnJsonValue*>& InArray);
	void SetArchetypeField(const class FString& FieldName, class UClass* Archetype);
	void SetArchetypeArrayField(const class FString& FieldName, TArray<class UClass*>& ArchetypeArray);
	void Reset();
	void RemoveField(const class FString& FieldName);
	void MergeJsonObject(class UQtnJsonObject* InJsonObject, bool Overwrite);
	void ImportFromString(const class FString& JsonString, bool* Success);
	bool HasField(const class FString& FieldName);
	class FString GetStringField(const class FString& FieldName);
	void GetStringArrayField(const class FString& FieldName, TArray<class FString>* StringArray);
	class UQtnJsonObject* GetObjectField(const class FString& FieldName);
	void GetObjectArrayField(const class FString& FieldName, TArray<class UQtnJsonObject*>* ObjectArray);
	int32 GetIntField(const class FString& FieldName);
	void GetIntArrayField(const class FString& FieldName, TArray<int32>* IntArray);
	float GetFloatField(const class FString& FieldName);
	void GetFloatArrayField(const class FString& FieldName, TArray<float>* FloatArray);
	void GetfieldNames(TArray<class FString>* FieldNames);
	class UQtnJsonValue* GetField(const class FString& FieldName);
	bool GetBoolField(const class FString& FieldName);
	void GetBoolArrayField(const class FString& FieldName, TArray<bool>* boolArray);
	void GetArrayField(const class FString& FieldName, TArray<class UQtnJsonValue*>* ValueArray);
	class UClass* GetArchetypeField(const class FString& FieldName);
	void GetArchetypeArrayField(const class FString& FieldName, TArray<class UClass*>* ArchetypeArray);
	class FString ExportToString(bool Condensed);
	class UQtnJsonObject* ConstructQtnJsonObject(class UObject* WorldContextObject);
};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnJsonValue
class UQtnJsonValue : public UObject
{
public:
	uint8                                        Pad_20C2[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnJsonValue* GetDefaultObj();

	bool IsNull();
	class FString GetTypeString();
	enum class EQtnJsonType GetJsonValueType();
	class UQtnJsonValue* ConstructQtnJsonValueString(class UObject* WorldContextObject, const class FString& StringValue);
	class UQtnJsonValue* ConstructQtnJsonValueObject(class UObject* WorldContextObject, class UQtnJsonObject* JsonObject);
	class UQtnJsonValue* ConstructQtnJsonValueInt(class UObject* WorldContextObject, int32 Number);
	class UQtnJsonValue* ConstructQtnJsonValueFloat(class UObject* WorldContextObject, float Number);
	class UQtnJsonValue* ConstructQtnJsonValueBool(class UObject* WorldContextObject, bool InValue);
	class UQtnJsonValue* ConstructQtnJsonValueArray(class UObject* WorldContextObject, TArray<class UQtnJsonValue*>& InArray);
	class UQtnJsonValue* ConstructQtnJsonValueArchetype(class UObject* WorldContextObject, class UClass* Archetype);
	class FString AsString();
	class UQtnJsonObject* AsObject();
	int32 AsInt();
	float AsFloat();
	bool AsBool();
	void AsArray(TArray<class UQtnJsonValue*>* ValueArray);
	class UClass* AsArchetype();
};

// 0x0 (0x258 - 0x258)
// Class QtnGame.QtnLevelScriptActor
class AQtnLevelScriptActor : public ALevelScriptActor
{
public:

	static class UClass* StaticClass();
	static class AQtnLevelScriptActor* GetDefaultObj();

};

// 0x0 (0x250 - 0x250)
// Class QtnGame.QtnLevelTerrain
class AQtnLevelTerrain : public AActor
{
public:

	static class UClass* StaticClass();
	static class AQtnLevelTerrain* GetDefaultObj();

};

// 0x8 (0x268 - 0x260)
// Class QtnGame.QtnLocalizedUserWidget
class UQtnLocalizedUserWidget : public UUserWidget
{
public:
	bool                                         M_wasCultureChanged;                               // 0x260(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_20C7[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnLocalizedUserWidget* GetDefaultObj();

	void OnCultureChangedEvent();
	void OnCultureChanged();
};

// 0x88 (0x258 - 0x1D0)
// Class QtnGame.QtnLocalOptionsSaveData
class UQtnLocalOptionsSaveData : public UQtnSaveData
{
public:
	FMulticastInlineDelegateProperty_            OnSubtitleSettingsChangedEvent;                    // 0x1D0(0x10)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        DefaultGammaValue;                                 // 0x1E0(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultResolutionScale;                            // 0x1E4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DefaultVSync;                                      // 0x1E8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DefaultSmoothFramerate;                            // 0x1E9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_20D3[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        DefaultTextureQuality;                             // 0x1EC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        DefaultShadowQuality;                              // 0x1F0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EColorBlindMode                   DefaultColorBlindnessMode;                         // 0x1F4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EColorBlindMode                   SavedColorBlindnessMode;                           // 0x1F5(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_20D4[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        DefaultColorBlindnessStrength;                     // 0x1F8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SavedColorBlindnessStrength;                       // 0x1FC(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ESubtitleFontType                 DefaultSubtitleType;                               // 0x200(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ESubtitleFontType                 SavedSubtitleType;                                 // 0x201(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ESubtitleFontSize                 DefaultSubtitleSize;                               // 0x202(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ESubtitleFontSize                 SavedSubtitleSize;                                 // 0x203(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultSubtitleBackgroundOpacity;                  // 0x204(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedSubtitleOpacity;                              // 0x208(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                          DefaultSubtitleTextColor;                          // 0x20C(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                          SavedSubtitleTextColor;                            // 0x21C(0x10)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        DefaultFogQuality;                                 // 0x22C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        DefaultAntiAliasingQuality;                        // 0x230(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedGammaRatio;                                   // 0x234(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SavedResolutionScale;                              // 0x238(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedVSync;                                        // 0x23C(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SavedSmoothFramerate;                              // 0x23D(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_20D5[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        SavedTextureQuality;                               // 0x240(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SavedShadowQuality;                                // 0x244(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SavedFogQuality;                                   // 0x248(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SavedAntiAliasingQuality;                          // 0x24C(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         Saved_NeedsBenchmark_WindowsOnly;                  // 0x250(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_20D6[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnLocalOptionsSaveData* GetDefaultObj();

	void SetVSync(bool VSync, bool ApplyNow);
	void SetTextureQuality(int32 TextureQuality, bool ApplyNow);
	void SetSubtitleType(enum class ESubtitleFontType InType);
	void SetSubtitleTextColor(const struct FLinearColor& InColor);
	void SetSubtitleSize(enum class ESubtitleFontSize InSize);
	void SetSubtitleBackgroundOpacity(float InOpacity);
	void SetSmoothFramerate(bool SmoothFramerate);
	void SetShadowQuality(int32 ShadowQuality, bool ApplyNow);
	void SetResolutionScale(float ResolutionScale, bool ApplyNow);
	void SetGammaRatio(float GammaRatio);
	void SetFogQuality(int32 FogQuality, bool ApplyNow);
	void SetColorBlindStrength(int32 InStrength);
	void SetColorBlindMode(enum class EColorBlindMode InMode);
	void SetAntiAliasingQuality(int32 AntiAliasingQuality, bool ApplyNow);
	void RunBenchmark_WindowsOnly(int32* OutTextureQuality, int32* OutShadowQuality, int32* OutFogQuality, int32* OutAntiAliasingQuality);
	bool GetVSync();
	int32 GetTextureQuality();
	enum class ESubtitleFontType GetSubtitleType();
	struct FLinearColor GetSubtitleTextColor();
	enum class ESubtitleFontSize GetSubtitleSize();
	float GetSubtitleBackgroundOpacity();
	bool GetSmoothFramerate();
	int32 GetShadowQuality();
	float GetResolutionScale();
	float GetGammaRatio();
	int32 GetFogQuality();
	float GetDefaultGammaRatio();
	int32 GetColorBlindStrength();
	enum class EColorBlindMode GetColorBlindMode();
	int32 GetAntiAliasingQuality();
};

// 0x8 (0x260 - 0x258)
// Class QtnGame.QtnLocalPlayer
class UQtnLocalPlayer : public ULocalPlayer
{
public:
	enum class EQtnLocalPlayerMode               M_localPlayerMode;                                 // 0x258(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_20D7[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnLocalPlayer* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnLootCullDistanceProvider
class UQtnLootCullDistanceProvider : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQtnLootCullDistanceProvider* GetDefaultObj();

	float GetCustomLootCullDistance();
};

// 0x108 (0x670 - 0x568)
// Class QtnGame.QtnLootItem
class AQtnLootItem : public AQtnItem
{
public:
	enum class EQtnLootItemType                  R_LootType;                                        // 0x568(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_20E6[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USphereComponent*                      TriggerUI;                                         // 0x570(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                      TriggerPickup;                                     // 0x578(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPlayerPawn*                        InteractingPawn;                                   // 0x580(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQtnLootSpawnSettings                 SpawnSettings;                                     // 0x588(0x38)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                            M_DropSFX;                                         // 0x5C0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                            M_PickupSFX;                                       // 0x5C8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        PickupAnimationDuration;                           // 0x5D0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               PickupStartPoint;                                  // 0x5D4(0xC)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                           LinearProgressCurve;                               // 0x5E0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                           MoveProgressCurve;                                 // 0x5E8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                           SpawnHeightCurve;                                  // 0x5F0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         R_IsPickupActive;                                  // 0x5F8(0x1)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_20E7[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_AnimTimer;                                       // 0x5FC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_needsConfigureVisuals;                           // 0x600(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_20E8[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SpawnHeight;                                       // 0x604(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SpawnAnimationDuration;                            // 0x608(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SpawnPickupBlockingDuration;                       // 0x60C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         ShowUIPopup;                                       // 0x610(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         InSpawnAnimation;                                  // 0x611(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_20E9[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnTagDescriptionComponent*           TagDescriptionComponent;                           // 0x618(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnFrobAccumulatorComponent*          FrobAccumulatorComponent;                          // 0x620(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_RequireFrobPickup;                               // 0x628(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         HasGeneratedStats;                                 // 0x629(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_20EB[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnFXActor*                           M_pAttachedFXActor;                                // 0x630(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnFXActor>               M_pAttachedFXActorClass;                           // 0x638(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_bSpawnComplete;                                  // 0x640(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_20EC[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnCurrencySpawnSettings             R_CurrencySettings;                                // 0x644(0xC)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnMediaSpawnSettings                R_MediaSettings;                                   // 0x650(0x8)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnWeaponSpawnSettings               R_WeaponSettings;                                  // 0x658(0x10)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnConsumableSpawnSettings           R_ConsumableSettings;                              // 0x668(0x8)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnLootItem* GetDefaultObj();

	void SpawnAsWeapon_ServerOnly(struct FQtnWeaponSpawnSettings& InSpawnSettings);
	void SpawnAsMedia_ServerOnly(struct FQtnMediaSpawnSettings& InSpawnSettings);
	void SpawnAsCurrency_ServerOnly(struct FQtnCurrencySpawnSettings& InSpawnSettings);
	void SpawnAsConsumable_ServerOnly(struct FQtnConsumableSpawnSettings& InSpawnSettings);
	void OnUpdateFrobFillUIEvent(float InFillRatio);
	void OnTriggerEnter(class AQtnPlayerPawn* User, enum class EQtnLootTriggerType TriggerType);
	void OnSpawnUpdateEvent(float Progress);
	void OnSpawnStartEvent();
	void OnSpawnCompleteEvent();
	void OnSpawnAnimationChanged();
	void OnShowPlayerUIEvent(bool ShowUI);
	void OnRep_WeaponSettings();
	void OnRep_MediaSettings();
	void OnRep_LootType();
	void OnRep_CurrencySettings();
	void OnRep_ConsumableSettings();
	void OnPickupUpdateEvent(float Progress);
	void OnPickupStartEvent(class AQtnPlayerPawn* TargetPawn);
	void OnPickupCurrency_ServerOnly();
	void OnPickupCurrency_LocalOnly();
	void OnPickupConsumable_ServerOnly();
	void OnPickupConsumable_LocalOnly();
	void OnPickupCompleteEvent();
	void OnConfigureVisualsEvent();
	void MulticastSpawnAnimation(const struct FQtnLootSpawnSettings& InSpawnSettings);
	void MulticastPickupStart(class AQtnPlayerPawn* User);
	void MulticastPickupComplete(class AQtnPlayerPawn* User);
	bool IsHeldByAPlayer();
	bool IsAutoPickup();
	bool GetConsumableBehaviourTags(TArray<struct FQtnConsumableBehaviourTag>* TagsArray);
	void GenerateStats_ServerOnly();
	void DelaySpawnAnimation_ServerOnly(const struct FQtnLootSpawnSettings& Settings, float SpawnDelay);
	bool CanUserPickup(class AQtnPlayerPawn* User);
};

// 0x68 (0x148 - 0xE0)
// Class QtnGame.QtnLootManagementComponent
class UQtnLootManagementComponent : public UActorComponent
{
public:
	uint8                                        Pad_20EF[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FGameplayTag, struct FQtnManagedLoot> M_managedLootMap;                                  // 0xE8(0x50)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x138(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootManagementComponent* GetDefaultObj();

	int32 ReserveLimitedLootItems(const struct FGameplayTag& LootItemType, int32 DesiredLootCount, const struct FVector& LootLocation);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void CleanUpManagedLootItems();
};

// 0x50 (0x2D8 - 0x288)
// Class QtnGame.QtnLootManagementVolume
class AQtnLootManagementVolume : public AVolume
{
public:
	TMap<struct FGameplayTag, int32>             M_lootLimitMap;                                    // 0x288(0x50)(Edit, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnLootManagementVolume* GetDefaultObj();

};

// 0x70 (0x150 - 0xE0)
// Class QtnGame.QtnLootTableComponent
class UQtnLootTableComponent : public UActorComponent
{
public:
	TSubclassOf<class UQtnLootTableContainer>    M_lootTableClass;                                  // 0xE0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnLootTableModifiers                M_lootTableModifiers;                              // 0xE8(0x68)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableComponent* GetDefaultObj();

};

// 0x0 (0x150 - 0x150)
// Class QtnGame.QtnLootTableRootComponent
class UQtnLootTableRootComponent : public UQtnLootTableComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnLootTableRootComponent* GetDefaultObj();

	void RollLootFromTable(TArray<struct FQtnRolledLootItem>* RolledLootItems, TSubclassOf<class UQtnLootTableContainer> LootTableClass, float baseQualityModifier, float baseQuantityModifier, const struct FGameplayTagContainer& FilterTags);
	void RollLoot(TArray<struct FQtnRolledLootItem>* RolledLootItems, float baseQualityModifier, float baseQuantityModifier, const struct FGameplayTagContainer& FilterTags);
	void GatherLootInfo(TMap<struct FGameplayTag, struct FQtnRangedFloat>& ItemCountsToModify);
};

// 0x50 (0x1A0 - 0x150)
// Class QtnGame.QtnLootSpawnerComponent
class UQtnLootSpawnerComponent : public UQtnLootTableRootComponent
{
public:
	bool                                         M_bHasSpawnedLoot;                                 // 0x150(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         UseVerboseDebugging;                               // 0x151(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2104[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnPendingLoot>               M_PendingLootBackups;                              // 0x158(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTimerHandle>                  M_SpawnTimerHandles;                               // 0x168(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	enum class ECollisionChannel                 TraceChannel;                                      // 0x178(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2105[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LootRadius;                                        // 0x17C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        OffsetRadius;                                      // 0x180(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SpawnDelay;                                        // 0x184(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               GroundCheckOffset;                                 // 0x188(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               SourceCheckOffset;                                 // 0x194(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootSpawnerComponent* GetDefaultObj();

	void SpawnLootForSelectPlayers_ServerOnly(TArray<class AQtnPlayerPawn*>& PlayerPawns, float* SecondsToFinishSpawning);
	void SpawnLoot_ServerOnly(float* SecondsToFinishSpawning, const struct FVector& StartLocation);
	bool ShouldSpawnLoot_ServerOnly();
	void ResetLootComponent();
	bool ModifyLootResults(class AQtnPlayerPawn* IntendedLootRecipient, TArray<struct FQtnRolledLootItem>& LootResults);
	bool IsPlayerValidLootRecipient(class AQtnPlayerPawn* PlayerPawn);
	bool HasLootTableTag_ServerOnly(struct FGameplayTag& TagToCheck);
	void HandleSpawning(class AQtnLootItem* LootItem, struct FQtnPendingLoot& PendingLootData, struct FGameplayTag& ItemTypeTag);
	void GenerateSpiralLocations(int32 Count, float Radius, float OffsetSegmentRadius, TArray<struct FVector>* SpiralLocations, TArray<struct FRotator>* SpiralRotations);
	void AddLootTableTag_ServerOnly(struct FGameplayTag& TagToAdd);
};

// 0x18 (0x40 - 0x28)
// Class QtnGame.QtnLootTableContainer
class UQtnLootTableContainer : public UObject
{
public:
	class UQtnLootTableEntry*                    M_rootEntry;                                       // 0x28(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQtnLootTableFlatEntry>        M_flatTable;                                       // 0x30(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableContainer* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnLootTableEntry
class UQtnLootTableEntry : public UObject
{
public:
	int32                                        M_quantityMin;                                     // 0x28(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        M_quantityMax;                                     // 0x2C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_rerollPerQuantity;                               // 0x30(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2108[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnLootTableEntry* GetDefaultObj();

};

// 0x10 (0x48 - 0x38)
// Class QtnGame.QtnLootTableEntryAnd
class UQtnLootTableEntryAnd : public UQtnLootTableEntry
{
public:
	TArray<class UQtnLootTableEntry*>            M_entries;                                         // 0x38(0x10)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryAnd* GetDefaultObj();

};

// 0x68 (0xA0 - 0x38)
// Class QtnGame.QtnLootTableEntryBonus
class UQtnLootTableEntryBonus : public UQtnLootTableEntry
{
public:
	struct FQtnLootTableModifiers                M_lootTableModifiers;                              // 0x38(0x68)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryBonus* GetDefaultObj();

};

// 0x18 (0x50 - 0x38)
// Class QtnGame.QtnLootTableEntryDifficultyQuantity
class UQtnLootTableEntryDifficultyQuantity : public UQtnLootTableEntry
{
public:
	float                                        M_difficultyQuantityModifiers[0x4];                // 0x38(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnLootTableEntry*                    M_entry;                                           // 0x48(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryDifficultyQuantity* GetDefaultObj();

};

// 0x18 (0x50 - 0x38)
// Class QtnGame.QtnLootTableEntryDifficultyWeight
class UQtnLootTableEntryDifficultyWeight : public UQtnLootTableEntry
{
public:
	float                                        M_difficultyWeightModifiers[0x4];                  // 0x38(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnLootTableEntry*                    M_entry;                                           // 0x48(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryDifficultyWeight* GetDefaultObj();

};

// 0x50 (0x88 - 0x38)
// Class QtnGame.QtnLootTableEntryItem
class UQtnLootTableEntryItem : public UQtnLootTableEntry
{
public:
	TSoftClassPtr<class AQtnItem>                M_itemClass;                                       // 0x38(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                 M_addedTags;                                       // 0x60(0x20)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       M_value;                                           // 0x80(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryItem* GetDefaultObj();

};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnLootTableEntryNull
class UQtnLootTableEntryNull : public UQtnLootTableEntry
{
public:

	static class UClass* StaticClass();
	static class UQtnLootTableEntryNull* GetDefaultObj();

};

// 0x10 (0x48 - 0x38)
// Class QtnGame.QtnLootTableEntryOr
class UQtnLootTableEntryOr : public UQtnLootTableEntry
{
public:
	TArray<struct FQtnLootTableWeightedEntry>    M_entries;                                         // 0x38(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryOr* GetDefaultObj();

};

// 0x50 (0x88 - 0x38)
// Class QtnGame.QtnLootTableEntryRaritySelector
class UQtnLootTableEntryRaritySelector : public UQtnLootTableEntry
{
public:
	TMap<struct FGameplayTag, class UQtnLootTableEntry*> M_entries;                                         // 0x38(0x50)(Edit, ExportObject, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryRaritySelector* GetDefaultObj();

};

// 0x70 (0xA8 - 0x38)
// Class QtnGame.QtnLootTableEntryReference
class UQtnLootTableEntryReference : public UQtnLootTableEntry
{
public:
	TSubclassOf<class UQtnLootTableContainer>    M_referenceClass;                                  // 0x38(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnLootTableModifiers                M_lootTableModifiers;                              // 0x40(0x68)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryReference* GetDefaultObj();

};

// 0x18 (0x50 - 0x38)
// Class QtnGame.QtnLootTableEntryTagDecorator
class UQtnLootTableEntryTagDecorator : public UQtnLootTableEntry
{
public:
	TArray<struct FQtnReactionToTag>             M_tagReactions;                                    // 0x38(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UQtnLootTableEntry*                    M_entry;                                           // 0x48(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableEntryTagDecorator* GetDefaultObj();

};

// 0x78 (0xA0 - 0x28)
// Class QtnGame.QtnLootTableGlobals
class UQtnLootTableGlobals : public UObject
{
public:
	TSubclassOf<class UQtnLootTableContainer>    M_bonusLootTableClass;                             // 0x28(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                 M_rarityTagContainer;                              // 0x30(0x20)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnLootTableWeightTuple> M_qualityWeightTuplesMap;                          // 0x50(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnLootTableGlobals* GetDefaultObj();

	void SetBonusLootTableClass(class UObject* WorldContextObject, TSubclassOf<class UQtnLootTableContainer> bonusLootTableClass);
	TSubclassOf<class UQtnLootTableContainer> GetBonusLootTableClass(class UObject* WorldContextObject);
};

// 0x18 (0x58 - 0x40)
// Class QtnGame.QtnMaterialExpressionSceneDepthCopy
class UQtnMaterialExpressionSceneDepthCopy : public UMaterialExpression
{
public:
	struct FExpressionInput                      Coordinates;                                       // 0x40(0x14)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_2116[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMaterialExpressionSceneDepthCopy* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnMathUtilities
class UQtnMathUtilities : public UObject
{
public:
	float                                        AimAssistDegreesMouseLook;                         // 0x28(0x4)(BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AimAssistDegreesStickLook;                         // 0x2C(0x4)(BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AimAssistMaxDistance;                              // 0x30(0x4)(BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DirectHitSweepRadius;                              // 0x34(0x4)(BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMathUtilities* GetDefaultObj();

	bool WillPassBehind(class AQtnPawn* MovingPawn, struct FVector& TargetPosition, float FutureSeconds);
	int32 RandomRound(float F);
	int32 QtnWrapInt(int32 CurrentValue, int32 MinValue, int32 MaxValue);
	float QtnWrapFloat(float CurrentValue, float MinValue, float MaxValue);
	bool IsCloseEnoughAABB(struct FVector& PointA, struct FVector& PointB, float HorizontalTolerance, float VerticalTolerance);
	bool IsCloseEnough(struct FVector& PointA, struct FVector& PointB, float HorizontalTolerance, float VerticalTolerance);
	bool IsActorWithinViewCone(class AActor* ActorToCheck, struct FVector& ViewLocation, struct FVector& ViewDirection, struct FQtnRangedFloat& ConeHalfAngleDegrees, float ViewDistance);
	void GetVelocityToTarget(struct FVector* ProjectileVelocity, struct FVector& MuzzlePosition, float ProjectileSpeed, class AQtnPlayerController* LocalPlayerController, const struct FVector& TargetVector, const struct FVector& Gravity, float AimAssistRadius);
	void GetVelocityFromDistanceAndHeight(float HorizontalDistance, float ApexHeight, float GravityMagnitude, float* HorizontalSpeed, float* VerticalSpeed, float* TotalAirTime);
	struct FVector2D GetScreenRatioFromLocation(class UObject* WorldContextObject, const struct FVector2D& ScreenLocation);
	struct FVector2D GetScreenOffsetFromText(const class FString& TextToMeasure, class UFont* FontToMeasure, const struct FVector2D& TextScale, const struct FVector2D& SpacingAdjust, enum class EHorizTextAligment HorizontalAlignment, enum class EVerticalTextAligment VerticalAlignment);
	struct FVector2D GetScreenLocationFromWorld(class UObject* WorldContextObject, const struct FVector& WorldLocation, bool* IsWithinView, const struct FVector2D& SafeZoneRatio);
	struct FVector2D GetScreenLocationFromRatio(class UObject* WorldContextObject, const struct FVector2D& ScreenRatio);
	struct FVector GetSafeFuturePosition(class AQtnPawn* QueryingPawn, class AQtnPawn* MovingPawn, struct FVector& PerceivedPosition, struct FVector& PerceivedVelocity, float FutureSeconds, bool CheckForWalls);
	struct FRotator GetRotatorBetweenVectors(struct FVector& StartDirection, struct FVector& EndDirection);
	bool GetPredictiveAimVelocityForPawnTarget(struct FVector* ProjectileVelocity, struct FVector& MuzzlePosition, struct FVector& MuzzleDirection, float MaxMuzzleDeviationDegrees, float ProjectileSpeed, class AQtnPawn* TargetPawn, struct FVector& ProjectileGravity, const struct FVector2D& MissDistanceXY);
	bool GetPredictiveAimVelocity(struct FVector* ProjectileVelocity, struct FVector& MuzzlePosition, float ProjectileSpeed, struct FVector& TargetPosition, struct FVector& TargetVelocity, struct FVector& Gravity);
	struct FVector GetNearestPointOnLineSegmentToView(class AQtnPawn* ViewingPawn, struct FVector& SegmentStart, struct FVector& SegmentEnd);
	struct FVector GetNearestPointOnLineSegment(struct FVector& TestLocation, struct FVector& SegmentStart, struct FVector& SegmentEnd);
	float GetLaunchSpeedFromThrowDistance(float MaxThrowDistance, float GravityMagnitude);
	struct FVector GetFuturePosition(class AQtnPawn* MovingPawn, struct FVector& PerceivedPosition, struct FVector& PerceivedVelocity, float FutureSeconds, bool CheckForWalls);
	struct FRotator GetCardinalRotation(struct FVector& SelfLocation, struct FVector& PositionInFront, enum class EQtnCardinalDirection CardinalDirection);
	enum class EQtnCardinalDirection GetCardinalDirectionFromMovement(const struct FVector& ForwardVector, struct FVector& WorldMovement, bool* IsValid);
	enum class EQtnCardinalDirection GetCardinalDirection(class AActor* SelfActor, struct FVector& Location, bool* IsValid);
	void GetCameraAimAssistVelocity(struct FVector* ProjectileVelocity, struct FVector& MuzzlePosition, float ProjectileSpeed, class AQtnPlayerController* LocalPlayerController, float TraceDistanceCm, const struct FVector& Gravity, float AimAssistRadius);
	class AQtnPawn* GetBestPawnWithinViewCone(TArray<class AQtnPawn*>& PawnsToCheck, struct FVector& ViewLocation, struct FVector& ViewDirection, struct FQtnRangedFloat& ConeHalfAngleDegrees, float ViewDistance, bool IgnoreDeadBodies);
	class AQtnPawn* GetBestPawnFromLocationWithLOS(TArray<class AQtnPawn*>& PawnsToCheck, struct FVector& FromLocation, struct FVector& StartLOSLocation, class AActor* IgnoreActorForLOS, bool IgnoreDeadBodies);
	class AActor* GetBestActorWithinViewCone(TArray<class AActor*>& ActorsToCheck, struct FVector& ViewLocation, struct FVector& ViewDirection, struct FQtnRangedFloat& ConeHalfAngleDegrees, float ViewDistance);
	enum class EQtnAttackMotion GetAttackMotion(class AActor* AttackingActor, struct FVector& StartPoint, struct FVector& EndPoint);
	void GetAimingArc(TArray<struct FVector>* OutputVectors, int32* ThresholdIndex, class AActor* AimingActor, struct FVector& StartPoint, struct FVector& StartVelocity, const struct FVector& Gravity, float SimDurationSeconds, enum class ECollisionChannel SweepChannel, float DeltaSecondsStep, bool UsePhysicsSweeps, float SphereCheckRadius, float LinearDampening, float ThresholdDistance);
	struct FVector GetAdjustedAimWithinCone2D(struct FVector& OriginalAim, struct FVector& ConeDirection, float ConeHalfAngleDegrees);
	struct FVector GetAdjustedAimWithinCone(struct FVector& OriginalAim, struct FVector& ConeDirection, float ConeHalfAngleDegrees);
	void GatherPawnsWithinRadiusFlags_BP(class AQtnPawn* QueryingPawn, const struct FVector& Origin, float Radius, int32 TeamAttitude, TArray<class AQtnPawn*>* Pawns, bool IgnoreQueryingPawn, bool IgnoreDeadPawns, bool blockedByGeo);
	void GatherPawnsWithinRadius(class AQtnPawn* QueryingPawn, const struct FVector& Origin, float Radius, enum class EQtnTeamAttitude TeamAttitude, TArray<class AQtnPawn*>* Pawns, bool IgnoreQueryingPawn, bool IgnoreDeadPawns, bool blockedByGeo);
	void GatherPawnsWithinCapsule(class AQtnPawn* QueryingPawn, const struct FVector& CapsuleBase, const struct FVector& CapsuleTip, float CapsuleRadius, enum class EQtnTeamAttitude TeamAttitude, TArray<class AQtnPawn*>* Pawns, bool IgnoreQueryingPawn, bool IgnoreDeadPawns, bool blockedByGeo);
	void GatherEnemiesWithinViewCone(class AQtnPawn* QueryingPawn, const struct FVector& ViewLocation, struct FVector& ViewDirection, struct FQtnRangedFloat& ConeHalfAngleDegrees, float ViewDistance, TArray<class AQtnPawn*>* EnemyPawns, bool IgnoreDeadPawns, bool blockedByGeo);
	void GatherEnemiesWithinRadius(class AQtnPawn* QueryingPawn, const struct FVector& Origin, float Radius, TArray<class AQtnPawn*>* EnemyPawns, bool IgnoreDeadPawns, bool blockedByGeo);
	void GatherEnemiesWithinCapsule(class AQtnPawn* QueryingPawn, const struct FVector& CapsuleBase, const struct FVector& CapsuleTip, float CapsuleRadius, TArray<class AQtnPawn*>* EnemyPawns, bool IgnoreDeadPawns, bool blockedByGeo);
	void GatherActorsWithinRadius(class AActor* QueryingActor, const struct FVector& Origin, float Radius, TArray<class AActor*>* OtherActors, bool IgnoreQueryingActor, bool OnlyDamageReceptorActors, bool blockedByGeo);
	void GatherActorsWithinCapsule(class AActor* QueryingActor, const struct FVector& CapsuleBase, const struct FVector& CapsuleTip, float CapsuleRadius, TArray<class AActor*>* OtherActors, bool IgnoreQueryingActor, bool OnlyDamageReceptorActors, bool blockedByGeo);
	class AActor* FindSomethingCoolToBreak(struct FVector& MuzzlePosition, struct FVector& MuzzleDirection, class AQtnPawn* TargetPawn, struct FVector& Origin, float Radius, class UQtnDamageReceptorComponent** DamageReceptor);
	void CreateVerticesFromSpline(class USplineComponent* Spline, struct FLinearColor& BaseColor, struct FLinearColor& ThresholdColor, TArray<struct FVector>& OutVerts, TArray<struct FVector2D>& OutUvs, TArray<struct FLinearColor>& OutVertColors, float AimWidth, int32 ThresholdIndex);
	void CreateTriangleIndicesFromSpline(class USplineComponent* Spline, TArray<int32>& OutIndices);
	void ConvertSecondsToTimeDisplay(float TotalSecondsToConvert, int32* Days, int32* Hours, int32* Minutes, int32* Seconds);
	void ConvertDirectionToDegreesAndMagnitude(struct FVector2D& Direction, float* Degrees, float* Magnitude);
	bool CanBeConsideredGroundForPawn(struct FVector& HitNormal, class AQtnPawn* TestPawn);
	bool CanBeConsideredGround(struct FVector& HitNormal, float WalkableFloorAngle);
	struct FVector AdjustMuzzlePositionForWalls(class AQtnPawn* ShootingPawn, struct FVector& OriginalMuzzlePosition, bool* WallDetected);
	struct FVector AdjustAimLocationForMiss(struct FVector& MuzzlePosition, struct FVector& AimLocation, struct FQtnRangedFloat& LateralMissRange, struct FQtnRangedFloat& OverheadMissRange);
};

// 0x18 (0xC0 - 0xA8)
// Class QtnGame.QtnMentalFSM
class UQtnMentalFSM : public UQtnFSM
{
public:
	TSubclassOf<class UQtnMentalStatePatrol>     DefaultMentalStatePatrol;                          // 0xA8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UQtnMentalState>>   MentalStates;                                      // 0xB0(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMentalFSM* GetDefaultObj();

};

// 0x48 (0x78 - 0x30)
// Class QtnGame.QtnMentalState
class UQtnMentalState : public UQtnFSMState
{
public:
	class AQtnBodyController*                    OwningBodyController;                              // 0x30(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnBlackboardComponent*               Blackboard;                                        // 0x38(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalSubFSM*                      M_pMentalSubFSM;                                   // 0x40(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            InitMentalStateEvent;                              // 0x48(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            EnterMentalStateEvent;                             // 0x58(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ExitMentalStateEvent;                              // 0x68(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMentalState* GetDefaultObj();

	void QtnInitMentalStateEvent__DelegateSignature(class UQtnMentalState* SelfMentalState);
	void QtnExitMentalStateEvent__DelegateSignature(class UQtnMentalState* SelfMentalState, TSubclassOf<class UQtnMentalState> NextMentalStateClass);
	void QtnEnterMentalStateEvent__DelegateSignature(class UQtnMentalState* SelfMentalState, class UQtnMentalState* PreviousMentalState);
	void OnVerbStopped(class UQtnVerb* StoppedVerb, enum class EQtnStopReason StopReason);
	void OnVerbStarted(class UQtnVerb* StartedVerb);
	void OnTickMentalState(float FDeltaSeconds);
	void OnThinkMentalState(float TimeSinceLastThought);
	void OnInitMentalState();
	void OnExitMentalState(TSubclassOf<class UQtnMentalState> NextMentalStateClass);
	void OnEnterMentalState(class UQtnMentalState* PreviousMentalState);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnDamageApplied(struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo);
	class AQtnPawn* GetRelevantEnemy();
};

// 0x258 (0x2D0 - 0x78)
// Class QtnGame.QtnMentalStateCombat
class UQtnMentalStateCombat : public UQtnMentalState
{
public:
	class AQtnPawn*                              M_pLastKnownEnemy;                                 // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentEnemy;                                   // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasVisualLineOfSight;                            // 0x88(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isFeelingPainFromDamage;                         // 0x89(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needEnemyRefresh;                                // 0x8A(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_217C[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_searchDelay;                                     // 0x8C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_pendingVictory;                                  // 0x90(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_217D[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_victoryDelay;                                    // 0x94(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isInActivePursuit;                               // 0x98(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isUsingRangedTactics;                            // 0x99(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_217E[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               M_combatPosition;                                  // 0x9C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnHintVolumeComponent*               M_pFloodControlHint;                               // 0xA8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentForegroundTicketedEnemy;                 // 0xB0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentAttackTicketedEnemy;                     // 0xB8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_attackTicketTimer;                               // 0xC0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_217F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnTicketType>            M_currentAttackTicketClass;                        // 0xC8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_tauntBarkTimer;                                  // 0xD0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnSensoryEvidenceCategory       M_bestEvidence;                                    // 0xD4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2180[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       PostCombatSearchRunDuration;                       // 0xD8(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       PostCombatSearchJogDuration;                       // 0xE0(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SprintRange;                                       // 0xE8(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        DodgeAwayDistanceMax;                              // 0xF0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2181[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       TelegraphAction;                                   // 0xF8(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       M_pendingScriptedAction;                           // 0x108(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2182[0x138];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pBestAttackVerb;                                 // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnVerb*                              M_pLastKnownAttackVerb;                            // 0x258(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_meleeNavProjectionDistance;                      // 0x260(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                       M_meleePathQueryID;                                // 0x264(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2183[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnVerb>                  DefaultFavoriteAttackVerb;                         // 0x278(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ForceRangedTactics;                                // 0x280(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2184[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnTicketType>            ForegroundTicketType;                              // 0x288(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnTicketType>            AttackTicketType;                                  // 0x290(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AttackTicketDuration;                              // 0x298(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MeleeRange_OwningFactor;                           // 0x29C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnVerb*                              M_pTauntVerb;                                      // 0x2A0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       TauntInterval;                                     // 0x2A8(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnVerb>                  TauntVerbClass;                                    // 0x2B0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_hasConfirmedNoAlliesToRevive;                    // 0x2B8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2185[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       SearchDelayDuration;                               // 0x2BC(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_2186[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pFavoriteAttackVerb;                             // 0x2C8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMentalStateCombat* GetDefaultObj();

	void SetFavoriteAttackVerb(TSubclassOf<class UQtnVerb> AttackVerbClass);
	bool HasForegroundTicket();
	bool HasAttackTicket();
};

// 0x68 (0xE0 - 0x78)
// Class QtnGame.QtnMentalStateFlee
class UQtnMentalStateFlee : public UQtnMentalState
{
public:
	class AQtnPawn*                              M_pLastKnownEnemy;                                 // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lastKnownPosition;                               // 0x80(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_visualSightingConfirmed;                         // 0x8C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_currentEnemyIsAScaryBear;                        // 0x8D(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2187[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_helpBarkTimer;                                   // 0x90(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_patrolDelayTimer;                                // 0x94(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_speedBurstTimer;                                 // 0x98(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       HelpBarkInterval;                                  // 0x9C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       PatrolDelayDuration;                               // 0xA4(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       ScaredyCatRange;                                   // 0xAC(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       FleeRange;                                         // 0xB4(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SpeedBurstDuration;                                // 0xBC(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2188[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnBlackboardComponent*               M_systemicBlackboard;                              // 0xC8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                         FleeBehaviorTree;                                  // 0xD0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        VisionAwarenessThreshold;                          // 0xD8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2189[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStateFlee* GetDefaultObj();

};

// 0x48 (0xC0 - 0x78)
// Class QtnGame.QtnMentalStateFollowAlly
class UQtnMentalStateFollowAlly : public UQtnMentalState
{
public:
	class AQtnPawn*                              M_pAllyPawnToFollow;                               // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_remainingPatience;                               // 0x80(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_perceivedAllyLocation;                           // 0x84(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pChosenAllyToRevive;                             // 0x90(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FollowPatience;                                    // 0x98(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       FollowRange;                                       // 0x9C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        M_navProjectionDistance;                           // 0xA4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                       M_pathQueryID;                                     // 0xA8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_218A[0x14];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStateFollowAlly* GetDefaultObj();

	class AQtnPawn* GetAlly();
};

// 0x8 (0x80 - 0x78)
// Class QtnGame.QtnMentalStateIncapacitated
class UQtnMentalStateIncapacitated : public UQtnMentalState
{
public:
	bool                                         M_doSearchUponRecovery;                            // 0x78(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_218B[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStateIncapacitated* GetDefaultObj();

};

// 0xB8 (0x130 - 0x78)
// Class QtnGame.QtnMentalStateInvestigate
class UQtnMentalStateInvestigate : public UQtnMentalState
{
public:
	class AQtnPawn*                              M_pLastPerceivedEnemy;                             // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentPerceivedEnemy;                          // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lastPerceivedLocation;                           // 0x88(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_218C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnHintVolumeComponent*               M_pFloodControlHint;                               // 0x98(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_remainingReactionLinger;                         // 0xA0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isBackgroundThreat;                              // 0xA4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnLocoSpeedEnum                 M_locoSpeed;                                       // 0xA5(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnInvestigateReactionEnum       M_reactionEscalation;                              // 0xA6(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnSensoryEvidenceCategory       M_bestEvidence;                                    // 0xA7(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        CombatAwarenessThreshold;                          // 0xA8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AwarenessSprintThreshold;                          // 0xAC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnInvestigationReaction             Reactions[0x4];                                    // 0xB0(0x80)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMentalStateInvestigate* GetDefaultObj();

};

// 0x1A0 (0x218 - 0x78)
// Class QtnGame.QtnMentalStatePatrol
class UQtnMentalStatePatrol : public UQtnMentalState
{
public:
	float                                        M_barkTimer;                                       // 0x78(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_movementLingerTimer;                             // 0x7C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_movementLingerYaw;                               // 0x80(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lookLingerTimer;                                 // 0x84(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_patrolNavProjectionDistance;                     // 0x88(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_numWaypointsTraversedOnCurrentRoute;             // 0x8C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_currentRouteElapsedTime;                         // 0x90(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_currentRoamingPatience;                          // 0x94(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnPatrolRouteComponent*              M_pTetheredPatrolRoute;                            // 0x98(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnPatrolRouteComponent*              M_pChosenPatrolRoute;                              // 0xA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnPatrolRouteComponent*              M_pLastFailedPatrolRoute;                          // 0xA8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnWaypoint*                          M_pCurrentWaypoint;                                // 0xB0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnWaypoint*                          M_pMovementLingerWaypoint;                         // 0xB8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AQtnVisualWaypoint*>            M_visualWaypoints;                                 // 0xC0(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AQtnVisualWaypoint*                    M_pCurrentVisualWaypoint;                          // 0xD0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lookFocusPosition;                               // 0xD8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_lookFocusBodyAim;                                // 0xE4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_backtracking;                                    // 0xE5(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_218D[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_partialPathPatience;                             // 0xE8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_218E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<uint32, class UQtnPatrolRouteComponent*> M_patrolPathQueries;                               // 0xF0(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UQtnPatrolRouteComponent*, float> M_patrolPathCosts;                                 // 0x140(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                        Pad_218F[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_ambientAnimTimer;                                // 0x1A0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2190[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       M_currentAmbientAction;                            // 0x1A8(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        M_frobTimer;                                       // 0x1B8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_allowMantlingDuringPatrol;                       // 0x1BC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasExperiencedPathFail;                          // 0x1BD(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2191[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFrobbableComponent*                M_pFrobbableDistraction;                           // 0x1C0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       BarkInterval;                                      // 0x1C8(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        ChanceOfIdleExpression;                            // 0x1D0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2192[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnAnimBarkStruct>            IdleExpressions;                                   // 0x1D8(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FQtnAnimBarkStruct                    M_queuedAnimBark;                                  // 0x1E8(0x20)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	enum class EQtnLocoSpeedEnum                 M_locoSpeed;                                       // 0x208(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2193[0xF];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStatePatrol* GetDefaultObj();

};

// 0x38 (0xB0 - 0x78)
// Class QtnGame.QtnMentalStatePlayerControlled
class UQtnMentalStatePlayerControlled : public UQtnMentalState
{
public:
	uint8                                        Pad_2197[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UObject*                               M_pScriptedActionCaller;                           // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       M_intendedBodyAction;                              // 0x88(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        M_scriptedActionTimer;                             // 0x98(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_waitingForScriptedActionTimer;                   // 0x9C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_scriptedActionOverridesCombat;                   // 0xA0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2199[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               M_lastNavLocation;                                 // 0xA4(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalStatePlayerControlled* GetDefaultObj();

};

// 0x20 (0x98 - 0x78)
// Class QtnGame.QtnMentalStateScriptedAction
class UQtnMentalStateScriptedAction : public UQtnMentalState
{
public:
	class UObject*                               M_pScriptedActionCaller;                           // 0x78(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pLookFocus;                                      // 0x80(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_overrideCombat;                                  // 0x88(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_219A[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_durationTimer;                                   // 0x8C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_failsafeTimer;                                   // 0x90(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_219B[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStateScriptedAction* GetDefaultObj();

};

// 0x218 (0x290 - 0x78)
// Class QtnGame.QtnMentalStateScriptedBT
class UQtnMentalStateScriptedBT : public UQtnMentalState
{
public:
	class UBehaviorTree*                         M_pBehaviorTree;                                   // 0x78(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnAIJobRole*                         M_pActiveAIJobRole;                                // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_wasEmployed;                                     // 0x88(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_overrideCombat;                                  // 0x89(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_doAttacks;                                       // 0x8A(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_219D[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnVerb>                  M_verbClassWaitedFor;                              // 0x90(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isMoveToInProgress;                              // 0x98(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_219F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_durationTimer;                                   // 0x9C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasExpired;                                      // 0xA0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A1[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_elapsedTimeWithoutEnemy;                         // 0xA4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_elapsedTimeWithoutEnemySighting;                 // 0xA8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasVisualLineOfSight;                            // 0xAC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isFeelingPainFromDamage;                         // 0xAD(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A3[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_tauntBarkTimer;                                  // 0xB0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_idleVOTimer;                                     // 0xB4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needEnemyRefresh;                                // 0xB8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A4[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPawn*                              M_pClosestKnownEnemy;                              // 0xC0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pLastKnownEnemy;                                 // 0xC8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnSensoryEvidenceCategory       M_bestEvidence;                                    // 0xD0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A5[0x13F];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UShapeComponent*>               M_tetherShapeComponents;                           // 0x210(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>               M_tetherSceneComponents;                           // 0x220(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AVolume*>                       M_tetherVolumes;                                   // 0x230(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATriggerBase*>                  M_tetherTriggers;                                  // 0x240(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                        M_tetherActors;                                    // 0x250(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UQtnPatrolRouteComponent*>      M_tetherPatrols;                                   // 0x260(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       M_tetherRadii;                                     // 0x270(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        M_tetherVerticalRatio;                             // 0x278(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_combatPosition;                                  // 0x27C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       IdleVOInterval;                                    // 0x288(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalStateScriptedBT* GetDefaultObj();

};

// 0x38 (0xB0 - 0x78)
// Class QtnGame.QtnMentalStateScriptedDestination
class UQtnMentalStateScriptedDestination : public UQtnMentalState
{
public:
	class AQtnPlayerController*                  M_pPlayerController;                               // 0x78(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pDestinationActor;                               // 0x80(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                              M_manualRotation;                                  // 0x88(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_overrideCombat;                                  // 0x94(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_destroyRequested;                                // 0x95(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_verbsInhibited;                                  // 0x96(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A6[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_giveupTimer;                                     // 0x98(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_finishUponReachingDestination;                   // 0x9C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isDone;                                          // 0x9D(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A7[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFrobbableComponent*                M_pFrobbableComponent;                             // 0xA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21A8[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStateScriptedDestination* GetDefaultObj();

};

// 0x60 (0xD8 - 0x78)
// Class QtnGame.QtnMentalStateSearch
class UQtnMentalStateSearch : public UQtnMentalState
{
public:
	class AQtnPawn*                              M_pSearchTarget;                                   // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnHintVolumeComponent*               M_pFloodControlHint;                               // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnSearchLineTracer                  M_searchLineTracer;                                // 0x88(0x28)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_isRunning;                                       // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21AC[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_walkDuration;                                    // 0xB4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_remainingTime;                                   // 0xB8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       M_searchStride;                                    // 0xBC(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_isBackgroundThreat;                              // 0xC4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_psychicIntuition;                                // 0xC5(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasDoneSearchBeginBark;                          // 0xC6(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_allowClimbingDuringSearch;                       // 0xC7(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_searchStrideTimer;                               // 0xC8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SearchStrideDelay;                                 // 0xCC(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21AE[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalStateSearch* GetDefaultObj();

};

// 0x18 (0xC0 - 0xA8)
// Class QtnGame.QtnMentalSubFSM
class UQtnMentalSubFSM : public UQtnFSM
{
public:
	TSubclassOf<class UQtnMentalSubState>        StartingMentalSubStateClass;                       // 0xA8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UQtnMentalSubState>> MentalSubStates;                                   // 0xB0(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMentalSubFSM* GetDefaultObj();

};

// 0x40 (0x70 - 0x30)
// Class QtnGame.QtnMentalSubState
class UQtnMentalSubState : public UQtnFSMState
{
public:
	class AQtnBodyController*                    OwningBodyController;                              // 0x30(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnMentalState*                       OwningMentalState;                                 // 0x38(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            InitMentalSubStateEvent;                           // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            EnterMentalSubStateEvent;                          // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ExitMentalSubStateEvent;                           // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnMentalSubState* GetDefaultObj();

	void RequestSubStateChange(TSubclassOf<class UQtnMentalSubState> SubStateClass);
	void QtnInitMentalSubStateEvent__DelegateSignature(class UQtnMentalSubState* SelfMentalSubState);
	void QtnExitMentalSubStateEvent__DelegateSignature(class UQtnMentalSubState* SelfMentalSubState, TSubclassOf<class UQtnMentalSubState> NextMentalSubStateClass);
	void QtnEnterMentalSubStateEvent__DelegateSignature(class UQtnMentalSubState* SelfMentalSubState, class UQtnMentalSubState* PreviousMentalSubState);
	void OnVerbStopped(class UQtnVerb* StoppedVerb, enum class EQtnStopReason StopReason);
	void OnVerbStarted(class UQtnVerb* StartedVerb);
	void OnTickMentalSubState(float FDeltaSeconds);
	void OnThinkMentalSubState(float TimeSinceLastThought);
	void OnInitMentalSubState();
	void OnExitMentalSubState(TSubclassOf<class UQtnMentalSubState> NextMentalSubStateClass);
	void OnEnterMentalSubState(class UQtnMentalSubState* PreviousMentalSubState);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnDamageApplied(struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo);
};

// 0x20 (0x90 - 0x70)
// Class QtnGame.QtnMentalSubStateCombatBase
class UQtnMentalSubStateCombatBase : public UQtnMentalSubState
{
public:
	class UQtnMentalStateCombat*                 M_pOwningCombatState;                              // 0x70(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                       M_allyPathQueryID;                                 // 0x78(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_21BC[0x14];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateCombatBase* GetDefaultObj();

};

// 0x48 (0xD8 - 0x90)
// Class QtnGame.QtnMentalSubStateBackgroundTactics
class UQtnMentalSubStateBackgroundTactics : public UQtnMentalSubStateCombatBase
{
public:
	class AQtnPawn*                              M_pForegroundEnemy;                                // 0x90(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_tetherLocation;                                  // 0x98(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_tauntCountdown;                                  // 0xA4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnAITetherResponse              M_lastKnownTetherResponse;                         // 0xA8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21BD[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnWaypoint*                          M_pChosenWaypoint;                                 // 0xB0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       M_fallbackRange;                                   // 0xB8(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       TauntInterval;                                     // 0xC0(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UQtnBlackboardComponent*               M_systemicBlackboard;                              // 0xC8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                         HideEvaluationBehavior;                            // 0xD0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateBackgroundTactics* GetDefaultObj();

};

// 0x28 (0x98 - 0x70)
// Class QtnGame.QtnMentalSubStateBTAmbient
class UQtnMentalSubStateBTAmbient : public UQtnMentalSubState
{
public:
	class UQtnMentalStateScriptedBT*             M_pOwningScriptedState;                            // 0x70(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_bestTetherLocation;                              // 0x78(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                              M_tetherOrientation;                               // 0x84(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	enum class EQtnAITetherResponse              M_tetherStatus;                                    // 0x90(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21BF[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateBTAmbient* GetDefaultObj();

};

// 0xB8 (0x128 - 0x70)
// Class QtnGame.QtnMentalSubStateBTCombat
class UQtnMentalSubStateBTCombat : public UQtnMentalSubState
{
public:
	class UQtnMentalStateScriptedBT*             M_pOwningScriptedBTState;                          // 0x70(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pLastKnownEnemy;                                 // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentEnemy;                                   // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pForegroundEnemy;                                // 0x88(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentForegroundTicketedEnemy;                 // 0x90(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pCurrentAttackTicketedEnemy;                     // 0x98(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_attackTicketTimer;                               // 0xA0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C3[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnTicketType>            M_currentAttackTicketClass;                        // 0xA8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isInPursuit;                                     // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C4[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pBestAttackVerb;                                 // 0xB8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnVerb*                              M_pLastRequestedAttackVerb;                        // 0xC0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_bestTetherLocation;                              // 0xC8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                              M_tetherOrientation;                               // 0xD4(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	enum class EQtnAITetherResponse              M_tetherStatus;                                    // 0xE0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       M_fallbackRange;                                   // 0xE4(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C6[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              M_pFavoriteAttackVerb;                             // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_timeWithoutAnAttackAtDestination;                // 0xF8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needsInitialDestination;                         // 0xFC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C7[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_tauntVerbCountdown;                              // 0x100(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C8[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnBlackboardComponent*               M_systemicBlackboard;                              // 0x108(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_navProjectionDistance;                           // 0x110(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                       M_pursuitPathQueryID;                              // 0x114(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21C9[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateBTCombat* GetDefaultObj();

	void SetFavoriteAttackVerb(TSubclassOf<class UQtnVerb> AttackVerbClass);
	bool HasForegroundTicket();
	bool HasAttackTicket();
};

// 0x20 (0x90 - 0x70)
// Class QtnGame.QtnMentalSubStateBTFrob
class UQtnMentalSubStateBTFrob : public UQtnMentalSubState
{
public:
	uint8                                        Pad_21CB[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnMentalStateScriptedBT*             M_pOwningScriptedState;                            // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFrobbableComponent*                M_pTargetFrobbable;                                // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_remainingFrobDuration;                           // 0x88(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_frobCancelRequested;                             // 0x8C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21CC[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateBTFrob* GetDefaultObj();

};

// 0x20 (0x90 - 0x70)
// Class QtnGame.QtnMentalSubStateBTPawnAction
class UQtnMentalSubStateBTPawnAction : public UQtnMentalSubState
{
public:
	uint8                                        Pad_21CD[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnMentalStateScriptedBT*             M_pOwningScriptedState;                            // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_remainingActionDuration;                         // 0x80(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21CE[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pLookFocusActor;                                 // 0x88(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateBTPawnAction* GetDefaultObj();

};

// 0x8 (0x78 - 0x70)
// Class QtnGame.QtnMentalSubStateDormant
class UQtnMentalSubStateDormant : public UQtnMentalSubState
{
public:
	bool                                         M_hasTicked;                                       // 0x70(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21CF[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateDormant* GetDefaultObj();

};

// 0x20 (0xB0 - 0x90)
// Class QtnGame.QtnMentalSubStateRangedTactics
class UQtnMentalSubStateRangedTactics : public UQtnMentalSubStateCombatBase
{
public:
	class UBehaviorTree*                         SubStateBehaviorTree;                              // 0x90(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnBlackboardComponent*               M_systemicBlackboard;                              // 0x98(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPawn*                              M_pRelevantEnemy;                                  // 0xA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_timeWithoutAnAttackAtDestination;                // 0xA8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_needsNewDestination;                             // 0xAC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_21D0[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateRangedTactics* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class QtnGame.QtnMentalSubStateFleeTactics
class UQtnMentalSubStateFleeTactics : public UQtnMentalSubStateRangedTactics
{
public:
	float                                        FleeDistance;                                      // 0xB0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_21D1[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnMentalSubStateFleeTactics* GetDefaultObj();

};

// 0x18 (0xA8 - 0x90)
// Class QtnGame.QtnMentalSubStateMeleeTactics
class UQtnMentalSubStateMeleeTactics : public UQtnMentalSubStateCombatBase
{
public:
	struct FQtnRangedFloat                       M_fallbackRange;                                   // 0x90(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       FormationRangeRatios;                              // 0x98(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pForegroundEnemy;                                // 0xA0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateMeleeTactics* GetDefaultObj();

};

// 0x8 (0xB0 - 0xA8)
// Class QtnGame.QtnMentalSubStateHealTactics
class UQtnMentalSubStateHealTactics : public UQtnMentalSubStateMeleeTactics
{
public:
	class AQtnBodyPawn*                          M_pChosenAllyToHelp;                               // 0xA8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateHealTactics* GetDefaultObj();

};

// 0x8 (0x98 - 0x90)
// Class QtnGame.QtnMentalSubStateReviveTactics
class UQtnMentalSubStateReviveTactics : public UQtnMentalSubStateCombatBase
{
public:
	class AQtnBodyPawn*                          M_pChosenAllyToRevive;                             // 0x90(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateReviveTactics* GetDefaultObj();

};

// 0x10 (0x80 - 0x70)
// Class QtnGame.QtnMentalSubStateScriptedAction
class UQtnMentalSubStateScriptedAction : public UQtnMentalSubState
{
public:
	uint8                                        Pad_21D6[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnMentalStateCombat*                 M_pOwningCombatState;                              // 0x78(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateScriptedAction* GetDefaultObj();

};

// 0x10 (0xB8 - 0xA8)
// Class QtnGame.QtnMentalSubStateSerpentine
class UQtnMentalSubStateSerpentine : public UQtnMentalSubStateMeleeTactics
{
public:
	struct FQtnRangedFloat                       SerpentineRange;                                   // 0xA8(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SerpentineRadii;                                   // 0xB0(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMentalSubStateSerpentine* GetDefaultObj();

};

// 0x50 (0x170 - 0x120)
// Class QtnGame.QtnNarrativeDataBag
class UQtnNarrativeDataBag : public UQtnDataBag
{
public:
	TMap<TSubclassOf<class UQtnNarrativeThread>, struct FQtnNarrativeThreadInfo> UnlockedNarrativeThreads;                          // 0x120(0x50)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnNarrativeDataBag* GetDefaultObj();

	bool UnlockSpecificElement(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype, TSubclassOf<class UQtnNarrativeElement> NarrativeElementArchetype);
	class UQtnNarrativeElement* UnlockNextElement(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype);
	void ResetNarrativeThread(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype);
	void ResetAllNarrativeThreads();
	void MarkElementAsPresented(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype, TSubclassOf<class UQtnNarrativeElement> NarrativeElementArchetype, bool WantPresented);
	bool HasElementBeenPresented(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype, TSubclassOf<class UQtnNarrativeElement> NarrativeElementArchetype);
	class UQtnNarrativeElement* GetNextElement(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype);
	void BuildListOfUnlockedNarrativeElements(TSubclassOf<class UQtnNarrativeThread> NarrativeThreadArchetype, TArray<struct FQtnNarrativeElementInfo>* UnlockedNarrativeElementInfo);
	void BuildListOfKnownNarrativeThreads(TArray<class UQtnNarrativeThread*>* KnownNarrativeThreads);
};

// 0x30 (0x58 - 0x28)
// Class QtnGame.QtnNarrativeElement
class UQtnNarrativeElement : public UObject
{
public:
	class FText                                  ElementTitle;                                      // 0x28(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  NarrativeText;                                     // 0x40(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnNarrativeElement* GetDefaultObj();

	class UQtnNarrativeElement* GetDefaultNarrativeElement(TSubclassOf<class UQtnNarrativeElement> NarrativeElementArchetype);
};

// 0x30 (0x58 - 0x28)
// Class QtnGame.QtnNarrativeThread
class UQtnNarrativeThread : public UObject
{
public:
	enum class EQtnNarrativeUnlockIntent         UnlockIntent;                                      // 0x28(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_21E2[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  ThreadTitle;                                       // 0x30(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UQtnNarrativeElement>> NarrativeElements;                                 // 0x48(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnNarrativeThread* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnNavArea
class UQtnNavArea : public UNavArea
{
public:

	static class UClass* StaticClass();
	static class UQtnNavArea* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnNavArea_Mantle
class UQtnNavArea_Mantle : public UQtnNavArea
{
public:

	static class UClass* StaticClass();
	static class UQtnNavArea_Mantle* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class QtnGame.QtnNavFilter_NoMantling
class UQtnNavFilter_NoMantling : public UNavigationQueryFilter
{
public:

	static class UClass* StaticClass();
	static class UQtnNavFilter_NoMantling* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnNavHelperInterface
class IQtnNavHelperInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnNavHelperInterface* GetDefaultObj();

	struct FVector GetNavLocation();
};

// 0x8 (0x15E8 - 0x15E0)
// Class QtnGame.QtnNavigationSystem
class UQtnNavigationSystem : public UNavigationSystemV1
{
public:
	bool                                         M_isReadyToUse;                                    // 0x15E0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_21F9[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnNavigationSystem* GetDefaultObj();

	bool QtnIsNavMeshReadyToUse(class UObject* WorldContextObject);
	bool QtnHasPath(class AActor* QueryingActor, const struct FVector& PathStart, const struct FVector& PathEnd, const struct FVector& StartProjectionExtent, const struct FVector& EndProjectionExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass, int32 MaxSearchNodes, bool AllowPartialPaths);
	struct FVector QtnGetRandomReachablePoint(bool* FoundRandomReachablePoint, class AActor* QueryingActor, const struct FVector& Origin, float Radius, const struct FVector& StartProjectionExtent, bool IgnoreReachability);
	struct FVector QtnGetPointOnNavMesh(bool* FoundPoint, class AActor* QueryingActor, const struct FVector& OriginalLocation, const struct FVector& ProjectionExtent);
	class UNavigationPath* QtnFindPathSynchronously(class AActor* QueryingActor, const struct FVector& PathStart, const struct FVector& PathEnd, const struct FVector& StartProjectionExtent, const struct FVector& EndProjectionExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass, int32 MaxSearchNodes, bool AllowPartialPaths);
	void QtnFindPathAsynchronously(class AActor* QueryingActor, const struct FLatentActionInfo& LatentInfo, class UNavigationPath** PathResult, struct FVector& PathStart, struct FVector& PathEnd, const struct FVector& StartProjectionExtent, const struct FVector& EndProjectionExtent, int32 MaxSearchNodes, bool AllowPartialPaths);
	bool IsOnNavMesh(class AActor* QueryingActor, const struct FVector& Location, float Radius, const struct FVector& ProjectionExtent);
};

// 0x0 (0x58 - 0x58)
// Class QtnGame.QtnNavigationSystemModuleConfig
class UQtnNavigationSystemModuleConfig : public UNavigationSystemModuleConfig
{
public:

	static class UClass* StaticClass();
	static class UQtnNavigationSystemModuleConfig* GetDefaultObj();

};

// 0x28 (0x1E8 - 0x1C0)
// Class QtnGame.QtnNavLinkCustomComponent
class UQtnNavLinkCustomComponent : public UNavLinkCustomComponent
{
public:
	uint8                                        Pad_21FA[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pOwningActor;                                    // 0x1C8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         CanBeUsedByAI;                                     // 0x1D0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CanBeUsedByCompass;                                // 0x1D1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_21FB[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x1D8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnNavLinkCustomComponent* GetDefaultObj();

	void SetNavLinkEnabled(bool bEnabled);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsNavLinkEnabled();
};

// 0x10 (0x1F8 - 0x1E8)
// Class QtnGame.QtnNavLinkBounceComponent
class UQtnNavLinkBounceComponent : public UQtnNavLinkCustomComponent
{
public:
	struct FVector                               BounceLocation;                                    // 0x1E8(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ShouldJumpToStartBounce;                           // 0x1F4(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_21FC[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnNavLinkBounceComponent* GetDefaultObj();

};

// 0x8 (0x258 - 0x250)
// Class QtnGame.QtnNavLinkCustomProxy
class AQtnNavLinkCustomProxy : public AActor
{
public:
	class UQtnNavLinkCustomComponent*            NavLinkCustomComponent;                            // 0x250(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnNavLinkCustomProxy* GetDefaultObj();

};

// 0x18 (0x200 - 0x1E8)
// Class QtnGame.QtnNavLinkDoorComponent
class UQtnNavLinkDoorComponent : public UQtnNavLinkCustomComponent
{
public:
	class AQtnDoor*                              M_pDoor;                                           // 0x1E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UQtnPathFollowingComponent*>    M_trackedDoorUsers;                                // 0x1F0(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnNavLinkDoorComponent* GetDefaultObj();

};

// 0x40 (0x228 - 0x1E8)
// Class QtnGame.QtnNavLinkMantleComponent
class UQtnNavLinkMantleComponent : public UQtnNavLinkCustomComponent
{
public:
	class UQtnSynchComponent*                    M_pMantleSyncComponent;                            // 0x1E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnNavLinkMantleTraversalType    StartToEndTraversal;                               // 0x1F0(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnNavLinkMantleTraversalType    EndToStartTraversal;                               // 0x1F1(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_21FE[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSoftObjectPtr<class AQtnDoor>               LinkedDoor;                                        // 0x1F8(0x28)(Edit, ExportObject, DisableEditOnTemplate, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                             LinkedDoorReach;                                   // 0x220(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnNavLinkMantleComponent* GetDefaultObj();

};

// 0x8 (0x258 - 0x250)
// Class QtnGame.QtnNavLinkMantleProxy
class AQtnNavLinkMantleProxy : public AActor
{
public:
	class UQtnNavLinkMantleComponent*            NavLinkMantleComponent;                            // 0x250(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnNavLinkMantleProxy* GetDefaultObj();

};

// 0x48 (0x430 - 0x3E8)
// Class QtnGame.QtnNewKidAnimInstance
class UQtnNewKidAnimInstance : public UQtnBodyAnimGraphTP
{
public:
	class AQtnBodyPawn*                          VictimBody;                                        // 0x3E8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               MovementVelocity;                                  // 0x3F0(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               UndieBonePos;                                      // 0x3FC(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                              HeadAimRotation;                                   // 0x408(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                        StanceBlendTime;                                   // 0x414(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        HeadAim;                                           // 0x418(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        OverrideUndieBoneWeight;                           // 0x41C(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MovementVectorWeight;                              // 0x420(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         Intention_LocoUpright;                             // 0x424(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         Intention_LocoAir;                                 // 0x425(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         Intention_NOT_LocoUpright_Air;                     // 0x426(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         Intention_LocoThrottleGT0;                         // 0x427(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         OverrideUndieBone;                                 // 0x428(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_21FF[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnNewKidAnimInstance* GetDefaultObj();

};

// 0x10 (0x48 - 0x38)
// Class QtnGame.QtnNintendoSwitchConfig
class UQtnNintendoSwitchConfig : public UDeveloperSettings
{
public:
	TArray<TSoftObjectPtr<class UStaticMesh>>    MeshesWithBadLightmaps;                            // 0x38(0x10)(Edit, ZeroConstructor, Config, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnNintendoSwitchConfig* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnOnlineErrorCodeLibrary
class UQtnOnlineErrorCodeLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQtnOnlineErrorCodeLibrary* GetDefaultObj();

	class FText Conv_OnlineErrorToText(const struct FQtnOnlineErrorCode& Error);
};

// 0x70 (0x98 - 0x28)
// Class QtnGame.QtnOnlineIdentityProxy
class UQtnOnlineIdentityProxy : public UObject
{
public:
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2201[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_hasStartedLogin;                                 // 0x38(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasCompletedLogin;                               // 0x39(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_wasLoginSuccessful;                              // 0x3A(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2202[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                M_loginError;                                      // 0x40(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasStartedGetCanPlay;                            // 0x50(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasCompletedGetCanPlay;                          // 0x51(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2203[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	uint32                                       M_canPlayResult;                                   // 0x54(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasStartedGetCanUseUGC;                          // 0x58(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasCompletedGetCanUseUGC;                        // 0x59(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2204[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	uint32                                       M_canUseUGCResult;                                 // 0x5C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                M_validControllerIndices;                          // 0x60(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         M_hasExternalUIJustClosed;                         // 0x70(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2205[0x27];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOnlineIdentityProxy* GetDefaultObj();

};

// 0x2A8 (0x2D8 - 0x30)
// Class QtnGame.QtnOnlineManager
class UQtnOnlineManager : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnMatchmakingComplete;                             // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMatchmakingStateChanged;                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInviteAcceptedByExternalUi;                      // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInviteAccepted;                                  // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnJoinPartyCompleted;                              // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLostConnection;                                  // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSessionDestroyedByServer;                        // 0x90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSessionChanged;                                  // 0xA0(0x10)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	bool                                         bUseFindSessions;                                  // 0xB0(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2213[0x227];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOnlineManager* GetDefaultObj();

	void UpdateHostSessionGameModeMode_ServerOnly(enum class EQtnGameModeType GameMode);
	void UpdateHostSession_ServerOnly(enum class EQtnGameModeType GameMode, int32 MaxUnlockedArc, int32 CurrentArc, enum class EQtnDifficulty Difficulty);
	bool StartMatchmaking(bool bIsLan, enum class EQtnGameModeType GameMode, int32 MaxUnlockedArc, int32 CurrentArc, enum class EQtnDifficulty Difficulty, bool AvoidSpoilers, FDelegateProperty_ OnComplete);
	bool MatchmakingWaitingConnection(FDelegateProperty_ OnComplete);
	bool MacthmakingWaitingDetermineHost(FDelegateProperty_ OnComplete);
	bool IsPlayFabPartyReady();
	bool IsNetworkConnected();
	void HandleOnSessionChanged(enum class EQtnSessionState NewSessionState, enum class EQtnSessionPrivacy Privacy, bool bIsLan);
	enum class EOnlineMangerMatchmakingState GetMatchmakingState();
	bool CancelMatchmaking(FDelegateProperty_ OnComplete);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnOnlineNodes
class UQtnOnlineNodes : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQtnOnlineNodes* GetDefaultObj();

	bool QtnIsLanSession(class UObject* WorldContextObject);
	enum class EQtnSessionState QtnGetSessionState(class UObject* WorldContextObject);
	enum class EQtnSessionPrivacy QtnGetSessionPrivacy(class UObject* WorldContextObject);
	void QtnClearOnSessionStateChanged(class UObject* WorldContextObject, FDelegateProperty_ OnChanged);
	void QtnClearOnInviteAcceptedByExternalUi(class UObject* WorldContextObject, FDelegateProperty_ OnAccepted);
	void QtnClearOnInviteAccepted(class UObject* WorldContextObject, FDelegateProperty_ OnAccepted);
	void QtnBindOnSessionStateChanged(class UObject* WorldContextObject, FDelegateProperty_ OnChanged);
	void QtnBindOnInviteAcceptedByExternalUi(class UObject* WorldContextObject, FDelegateProperty_ OnAccepted);
	void QtnBindOnInviteAccepted(class UObject* WorldContextObject, FDelegateProperty_ OnAccepted);
};

// 0x38 (0x68 - 0x30)
// Class QtnGame.QtnHostParty
class UQtnHostParty : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_2222[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UWorld*                                M_world;                                           // 0x60(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnHostParty* GetDefaultObj();

	class UQtnHostParty* QtnHostParty(class UObject* WorldContextObject, enum class EQtnSessionPrivacy Privacy, bool bLan, int32 MaxArc, int32 CurrentArc, enum class EQtnDifficulty Difficulty, enum class EQtnGameModeType IsHordeMode);
	void OnComplete(enum class EQtnSessionPrivacy NewPrivacy, enum class EQtnHostPartyResult Result, const struct FQtnOnlineErrorCode& ErrorCode);
};

// 0x38 (0x68 - 0x30)
// Class QtnGame.QtnJoinParty
class UQtnJoinParty : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_2229[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UWorld*                                M_world;                                           // 0x60(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnJoinParty* GetDefaultObj();

	class UQtnJoinParty* QtnJoinParty(class UObject* WorldContextObject, bool bIsLan, enum class EQtnGameModeType GameMode, int32 MaxArc, int32 CurrentArc, enum class EQtnDifficulty Difficulty, bool AvoidSpoilers, bool AllowsHordeMode);
	void OnComplete(enum class EQtnJoinPartyResult Result, const struct FQtnOnlineErrorCode& ErrorCode);
};

// 0x28 (0x58 - 0x30)
// Class QtnGame.QtnDisbandParty
class UQtnDisbandParty : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                M_world;                                           // 0x50(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnDisbandParty* GetDefaultObj();

	class UQtnDisbandParty* QtnDisbandParty(class UObject* WorldContextObject);
	void OnComplete(enum class EQtnDisbandPartyResult Result);
};

// 0x38 (0x68 - 0x30)
// Class QtnGame.QtnStartMatchmaking
class UQtnStartMatchmaking : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_2231[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UWorld*                                M_world;                                           // 0x60(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnStartMatchmaking* GetDefaultObj();

	class UQtnStartMatchmaking* QtnStartMatchmaking(class UObject* WorldContextObject, bool bIsLan, enum class EQtnGameModeType GameMode, int32 MaxArc, int32 CurrentArc, enum class EQtnDifficulty Difficulty, bool AvoidSpoilers);
	void OnComplete(enum class EQtnMatchmakingResult Result, int32 PendingConnectionsNum);
};

// 0x28 (0x58 - 0x30)
// Class QtnGame.QtnCancelMatchmaking
class UQtnCancelMatchmaking : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                M_world;                                           // 0x50(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnCancelMatchmaking* GetDefaultObj();

	class UQtnCancelMatchmaking* QtnCancelMatchmaking(class UObject* WorldContextObject);
	void OnComplete(enum class EQtnMatchmakingResult Result);
};

// 0x28 (0x58 - 0x30)
// Class QtnGame.QtnMatchmakingWaitingConnection
class UQtnMatchmakingWaitingConnection : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                M_world;                                           // 0x50(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMatchmakingWaitingConnection* GetDefaultObj();

	class UQtnMatchmakingWaitingConnection* QtnMatchmakingWaitingConntection(class UObject* WorldContextObject);
	void OnComplete(enum class EQtnMatchmakingResult Result);
};

// 0x18 (0x48 - 0x30)
// Class QtnGame.QtnMatchmakingWaitingDetermineHost
class UQtnMatchmakingWaitingDetermineHost : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnDetermineHostComplete;                           // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                M_world;                                           // 0x40(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnMatchmakingWaitingDetermineHost* GetDefaultObj();

	class UQtnMatchmakingWaitingDetermineHost* QtnMatchmakingWaitingDetermineHost(class UObject* WorldContextObject);
	void OnComplete(bool bIsHost);
};

// 0x128 (0x2F0 - 0x1C8)
// Class QtnGame.QtnOnlineSession
class UQtnOnlineSession : public UOnlineSessionClient
{
public:
	class FText                                  M_kickReason;                                      // 0x1C8(0x18)(Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2236[0x110];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOnlineSession* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnOnlineUtilities
class UQtnOnlineUtilities : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnOnlineUtilities* GetDefaultObj();

	int32 GetServerSetting(struct FBlueprintSessionResult& Result, enum class EQtnServerSetting ServerSetting);
};

// 0x8 (0x38 - 0x30)
// Class QtnGame.QtnSaveLoadState
class UQtnSaveLoadState : public UQtnFSMState
{
public:
	uint8                                        Pad_2239[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnSaveLoadState* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnOptionsLoadState
class UQtnOptionsLoadState : public UQtnSaveLoadState
{
public:
	bool                                         M_localOnly;                                       // 0x38(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_223A[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOptionsLoadState* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnOptionsSaveState
class UQtnOptionsSaveState : public UQtnSaveLoadState
{
public:
	bool                                         M_localOnly;                                       // 0x38(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_223B[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOptionsSaveState* GetDefaultObj();

};

// 0x30 (0x58 - 0x28)
// Class QtnGame.QtnOutcomeCalculator
class UQtnOutcomeCalculator : public UObject
{
public:
	struct FGameplayTag                          OutcomeTag;                                        // 0x28(0x8)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                          EventToListenTo;                                   // 0x30(0x8)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                 ResultLifetimes;                                   // 0x38(0x20)(Edit, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnOutcomeCalculator* GetDefaultObj();

	struct FQtnPlayerOutcomeResult K2_CalculateOutcome(struct FQtnEventMessage& EventMessage);
};

// 0x60 (0x90 - 0x30)
// Class QtnGame.QtnOutcomeTrackingSubsystem
class UQtnOutcomeTrackingSubsystem : public UGameInstanceSubsystem
{
public:
	TMap<struct FUniqueNetIdRepl, struct FQtnPlayerOutcomeSession> OutcomeSessionMap;                                 // 0x30(0x50)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<class UQtnOutcomeCalculator*>         OutcomeCalculators;                                // 0x80(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnOutcomeTrackingSubsystem* GetDefaultObj();

	void ResetAllSessionOutcomes_ServerOnly(const struct FGameplayTag& LifetimeTag);
	void OnQtnEventOccured(struct FQtnEventMessage& EventMessage);
	void ManuallyAddPlayerOutcomeValue_ServerOnly(class AQtnBodyPawn* TargetPlayer, const struct FGameplayTag& OutcomeTag, const struct FGameplayTagContainer& LifetimeTags, struct FQtnPlayerOutcomeResult& Result);
	struct FQtnPlayerOutcomeSummary GetPlayerOutcomeValue_ServerOnly(class AQtnBodyPawn* TargetPlayer, const struct FGameplayTag& OutcomeTag, const struct FGameplayTag& LifetimeTag);
	class UQtnOutcomeTrackingSubsystem* GetOutcomeTrackingSubsystem(class UObject* WorldContextObject);
	struct FQtnPlayerOutcomeSummary GetGlobalOutcomeValue_ServerOnly(const struct FGameplayTag& OutcomeTag, const struct FGameplayTag& LifetimeTag);
};

// 0x40 (0x68 - 0x28)
// Class QtnGame.QtnOutlineFX
class UQtnOutlineFX : public UObject
{
public:
	class AActor*                                M_pTargetActor;                                    // 0x28(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_StencilValue;                                    // 0x30(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_223F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UPrimitiveComponent*>           M_Meshes;                                          // 0x38(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<int32>                                M_PreviousStencilValues;                           // 0x48(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<bool>                                 M_PreviousRenderCustomDepths;                      // 0x58(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnOutlineFX* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnOutlineFXInterface
class IQtnOutlineFXInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnOutlineFXInterface* GetDefaultObj();

};

// 0x230 (0x258 - 0x28)
// Class QtnGame.QtnOverlayFX
class UQtnOverlayFX : public UObject
{
public:
	bool                                         M_bIsActive;                                       // 0x28(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2241[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pTargetActor;                                    // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_BeginTime;                                       // 0x38(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_EndTime;                                         // 0x3C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_CurrentWeight;                                   // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2242[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UMeshComponent*>                M_TargetMeshes;                                    // 0x48(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                M_OverlayMeshes;                                   // 0x58(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                    Material;                                          // 0x68(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPerPlatformBool                      bIgnoreTranslucentMaterial;                        // 0x70(0x1)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         bUseAlternateTranslucentMaterial;                  // 0x71(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2243[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInterface*                    AlternateTranslucentMaterial;                      // 0x78(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bUseAlternateClothMaterial;                        // 0x80(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2244[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInterface*                    AlternateClothMaterial;                            // 0x88(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  ScalarParameterName;                               // 0x90(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bIsLooping;                                        // 0x98(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bUseSimpleCurve;                                   // 0x99(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2245[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        BlendInTime;                                       // 0x9C(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        Duration;                                          // 0xA0(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        BlendOutTime;                                      // 0xA4(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                    PrimaryCurve;                                      // 0xA8(0x88)(Edit, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                    OptionalLoopCurve;                                 // 0x130(0x88)(Edit, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                    BlendOutCurve;                                     // 0x1B8(0x88)(Edit, NativeAccessSpecifierPrivate)
	bool                                         bOverrideRenderChannel;                            // 0x240(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnRenderChannel                 RenderChannelOverride;                             // 0x241(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2247[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnEffectFinished;                                  // 0x248(0x10)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnOverlayFX* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnOverlayFXInterface
class IQtnOverlayFXInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnOverlayFXInterface* GetDefaultObj();

	TArray<class UMeshComponent*> GetOverlayMeshes();
};

// 0x10 (0x5D0 - 0x5C0)
// Class QtnGame.QtnOverlayInstancedStaticMeshComponent
class UQtnOverlayInstancedStaticMeshComponent : public UInstancedStaticMeshComponent
{
public:
	uint8                                        Pad_2249[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnOverlayFX*                         M_pOverlayFX;                                      // 0x5C8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnOverlayInstancedStaticMeshComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnOverlayMeshInterface
class IQtnOverlayMeshInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnOverlayMeshInterface* GetDefaultObj();

};

// 0x10 (0xF10 - 0xF00)
// Class QtnGame.QtnOverlaySkeletalMeshComponent
class UQtnOverlaySkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	class UQtnOverlayFX*                         M_pOverlayFX;                                      // 0xF00(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_224A[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOverlaySkeletalMeshComponent* GetDefaultObj();

};

// 0x18 (0x530 - 0x518)
// Class QtnGame.QtnOverlayStaticMeshComponent
class UQtnOverlayStaticMeshComponent : public UStaticMeshComponent
{
public:
	uint8                                        Pad_224B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnOverlayFX*                         M_pOverlayFX;                                      // 0x520(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_224C[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnOverlayStaticMeshComponent* GetDefaultObj();

};

// 0x0 (0x68 - 0x68)
// Class QtnGame.QtnPakChunk
class UQtnPakChunk : public UPrimaryAssetLabel
{
public:

	static class UClass* StaticClass();
	static class UQtnPakChunk* GetDefaultObj();

};

// 0x1C0 (0x440 - 0x280)
// Class QtnGame.QtnPathFollowingComponent
class UQtnPathFollowingComponent : public UPathFollowingComponent
{
public:
	class AQtnBodyController*                    M_pOwningController;                               // 0x280(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_pathfindingFailed;                               // 0x288(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2250[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_pathfindingFailedElapsedTime;                    // 0x28C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_navRecoveryTimer;                                // 0x290(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isPathfindingBlocked;                            // 0x294(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2251[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_isPathfindingBlockedElapsedTime;                 // 0x298(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2252[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pLastBlockingActor;                              // 0x2A0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_lastBlockingImpactPoint;                         // 0x2A8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_timeSinceLastBlockage;                           // 0x2B4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isAnkleBlocked;                                  // 0x2B8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2253[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_movementBlockTimer;                              // 0x2BC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       M_cosineTwistAngle;                                // 0x2C0(0x8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                               M_bumpSteering;                                    // 0x2C8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_bumpSteeringStrength;                            // 0x2D4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_formationSteering;                               // 0x2D8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_smoothedFormationSteering;                       // 0x2E4(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_calculatedPathSteering;                          // 0x2F0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_effectivePathSteering;                           // 0x2FC(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isOnPartialPath;                                 // 0x308(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2254[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_partialPathElapsedTime;                          // 0x30C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pAIDestinationActor;                             // 0x310(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_AIDestinationPoint;                              // 0x318(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_actualPathingDestination;                        // 0x324(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_movementNeedsRefresh;                            // 0x330(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isNearEndOfPath;                                 // 0x331(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2255[0x2E];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIMoveRequest                        M_pendingMoveRequest;                              // 0x360(0x40)(Transient, NativeAccessSpecifierPrivate)
	struct FAIRequestID                          M_currentMoveRequestID;                            // 0x3A0(0x4)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                       M_forwardGroundPathQueryID;                        // 0x3A4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2256[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_formationNullifiesSteering;                      // 0x3B8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2257[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_elapsedTimeFormationHasPreventedMovement;        // 0x3BC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_wantsAIToJumpOrMantle;                           // 0x3C0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_wantsAIToCrouch;                                 // 0x3C1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2258[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FormationTwistRange;                               // 0x3C4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       FormationTwistAngle;                               // 0x3C8(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bCanSkipLedgeAvoidanceAndFormationSteering;        // 0x3D0(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2259[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_lastAsyncCalculateLedgeAvoidanceTime;            // 0x3D4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_lastAsyncCalculateLedgeAvoidanceResult;          // 0x3D8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_ledgeAvoidanceFormationTracesScheduled;          // 0x3D9(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_ledgeAvoidancePathTracesScheduled;               // 0x3DA(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_225A[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	uint32                                       M_ledgeAvoidanceTracesComplete;                    // 0x3DC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_ledgeAvoidanceFormationWallTraceResult;          // 0x3E0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_ledgeAvoidanceFormationGroundTraceResult;        // 0x3E1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_ledgeAvoidancePathWallTraceResult;               // 0x3E2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_ledgeAvoidancePathGroundTraceResult;             // 0x3E3(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               M_pathSegmentStart;                                // 0x3E4(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               M_pathSegmentEnd;                                  // 0x3F0(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_225B[0x34];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  AggregationKey;                                    // 0x430(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        RoundRobinBucketSize;                              // 0x438(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_225C[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnPathFollowingComponent* GetDefaultObj();

	bool IsPathfindingBlocked(float* ElapsedTime);
	bool IsAtDestination(const struct FVector2D& Leeway);
	bool HasPathfindingFailed(float* ElapsedTime);
	struct FVector GetAIDestinationPoint();
	class AActor* GetAIDestinationActor();
	bool CanInterruptPathFollowing();
};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnPatrolManager
class UQtnPatrolManager : public UObject
{
public:
	TArray<class UQtnPatrolRouteComponent*>      M_registeredPatrolRoutes;                          // 0x28(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnPatrolManager* GetDefaultObj();

};

// 0x8 (0x258 - 0x250)
// Class QtnGame.QtnPatrolRoute
class AQtnPatrolRoute : public AActor
{
public:
	class UQtnPatrolRouteComponent*              PatrolRouteComponent;                              // 0x250(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnPatrolRoute* GetDefaultObj();

};

// 0xA0 (0x180 - 0xE0)
// Class QtnGame.QtnPatrolRouteComponent
class UQtnPatrolRouteComponent : public UActorComponent
{
public:
	TArray<class AQtnBodyController*>            M_adopters;                                        // 0xE0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                        M_lastRandomIndex;                                 // 0xF0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitGapFixups;                                // 0xF4(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnPatrolRouteType               RouteType;                                         // 0xF5(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_225F[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnWaypoint*>                  Waypoints;                                         // 0xF8(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FQtnActorFilter                       AIAdoptionFilter;                                  // 0x108(0x40)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         RouteEnabled;                                      // 0x148(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2260[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        PreferredAdoptionCount;                            // 0x14C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        AdoptionCapacity;                                  // 0x150(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SniperAngleDegreesMin;                             // 0x154(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SniperAngleDegreesMax;                             // 0x158(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       SniperStickinessClamp;                             // 0x15C(0x8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       TetherRadii;                                       // 0x164(0x8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                        TetherVerticalRatio;                               // 0x16C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AVolume>>        TetherVolumes;                                     // 0x170(0x10)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnPatrolRouteComponent* GetDefaultObj();

	class AQtnWaypoint* GetClosestWaypoint(struct FVector& Position, float* DistanceFromWaypoint);
};

// 0x50 (0x78 - 0x28)
// Class QtnGame.QtnPerk
class UQtnPerk : public UObject
{
public:
	uint8                                        Pad_227F[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnPerkComponent*                     R_pOwningPerkComponent;                            // 0x30(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                   PerkSettings;                                      // 0x38(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                R_LoadoutIndices;                                  // 0x48(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                        R_ActiveInstances;                                 // 0x58(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        L_ActiveInstances;                                 // 0x5C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_bPendingActiveInstanceChange;                    // 0x60(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2283[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTag                          PerkID;                                            // 0x64(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2284[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnPerk* GetDefaultObj();

	void RemoveLoadoutLevel_ServerOnly(class AQtnBodyPawn* TargetBodyPawn, int32 LoadoutLevelsToRemove);
	void RemoveLoadoutInstance_ServerOnly(class AQtnBodyPawn* TargetBodyPawn, int32 LoadoutSourceSlot);
	void OnRep_OwningPerkComponent();
	void OnRep_ActiveInstances();
	void OnPerkStackChangeEvent(class AQtnBodyPawn* TargetBodyPawn, int32 PreviousLevel, int32 NewLevel, bool IsServer);
	void OnGameEventEvent_ServerOnly(struct FQtnEventMessage& EventMessage);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnDeactivatePerkEvent(class AQtnBodyPawn* TargetBodyPawn);
	void OnActivatePerkEvent(class AQtnBodyPawn* TargetBodyPawn);
	void LoadFromSaveData_ServerOnly(class AQtnBodyPawn* TargetBodyPawn, struct FQtnSavedPerkLoadoutData& LoadoutData);
	float GetValueOfPerk(int32 ValueIndex);
	TArray<int32> GetReplicatedLoadoutIndices();
	int32 GetReplicatedActiveInstances();
	float GetPerkValueAtInstanceCount(int32 ValueIndex, int32 InstanceCount);
	struct FQtnPerkSettings GetPerkSettings();
	class UQtnPerkComponent* GetOwningPerkComponent();
	class FText GetFormattedValueAtIndexAtInstanceCount(int32 ArrayIndex, int32 InstanceCount);
	class FText GetFormattedValueAtIndex(int32 ArrayIndex);
	struct FQtnSavedPerkLoadoutData CreateSavedLoadoutData();
	void CalculateDamageValues(class UQtnVerb* SourceVerb, class AActor* TargetActor, float InBaseDamage, TSubclassOf<class UQtnDamageType> DamageType, float* OutDamageScalar, float* OutBonusDamage);
	void BeginListeningToEvent_ServerOnly(struct FGameplayTag& EventTag);
	void AddLoadoutLevel_ServerOnly(class AQtnBodyPawn* TargetBodyPawn, int32 LoadoutLevelsToAdd);
	void AddLoadoutInstance_ServerOnly(class AQtnBodyPawn* TargetBodyPawn, int32 LoadoutSourceSlot);
};

// 0x58 (0x138 - 0xE0)
// Class QtnGame.QtnPerkComponent
class UQtnPerkComponent : public UActorComponent
{
public:
	uint8                                        Pad_229E[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UDataTable*                            ParentPerkDataTable;                               // 0xE8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          M_pOwningBodyPawn;                                 // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQtnPerk*>                      L_Perks;                                           // 0xF8(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UQtnPerk*>                      R_Perks;                                           // 0x108(0x10)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnLoadoutChangedEvent;                             // 0x118(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x128(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnPerkComponent* GetDefaultObj();

	void ServerResetPerks();
	void ServerLoadPerk(struct FQtnSavedPerkLoadoutData& PerkSaveData);
	void ServerDeactivatePerks(TArray<TSubclassOf<class UQtnPerk>>& PerkClasses, TArray<int32>& SourceLoadoutSlots);
	void ServerDeactivatePerk(TSubclassOf<class UQtnPerk> PerkClass, int32 SourceLoadoutSlot);
	void ServerActivatePerk(TSubclassOf<class UQtnPerk> PerkClass, int32 SourceLoadoutSlot);
	void OnRep_Perks();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void LoadPerk_ServerOnly(struct FQtnSavedPerkLoadoutData& PerkSaveData);
	bool IsPerkLoadoutActive(TSubclassOf<class UQtnPerk> PerkClass, int32 SourceLoadoutSlot);
	bool IsPerkActive(TSubclassOf<class UQtnPerk> PerkClass);
	int32 GetPerkInstanceCount(TSubclassOf<class UQtnPerk> PerkClass);
	class AQtnBodyPawn* GetOwningBodyPawn();
	TArray<class UQtnPerk*> GetAllPerks();
	class UQtnPerk* FindPerk(TSubclassOf<class UQtnPerk> PerkClass);
	void DeactivatePerk_ServerOnly(TSubclassOf<class UQtnPerk> PerkClass, int32 SourceLoadoutSlot);
	void ClientPerkStacksChanged();
	int32 CalculatePlayerLevelFromPerks();
	void CalculateDamageValues(class UQtnVerb* SourceVerb, class AActor* TargetActor, float InBaseDamage, TSubclassOf<class UQtnDamageType> DamageType, float* OutDamageScalar, float* OutBonusDamage);
	void ActivatePerk_ServerOnly(TSubclassOf<class UQtnPerk> PerkClass, int32 SourceLoadoutSlot);
};

// 0x50 (0x78 - 0x28)
// Class QtnGame.QtnPerkMap
class UQtnPerkMap : public UObject
{
public:
	TMap<class UUserWidget*, struct FQtnPerkMapEntry> PerkMapEntriesMap;                                 // 0x28(0x50)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnPerkMap* GetDefaultObj();

	void SetSimulationState(class UUserWidget* PerkWidget, enum class EQtnPerkMapSimulationState SimState);
	void SetBuildState(class UUserWidget* PerkWidget, bool IsActive);
	TArray<struct FQtnPerkMapIsland> CheckPerkMapForIslands(class UUserWidget* DisconnectedWidget, bool UseSimulationState);
	void AddPerkWidgetToMap(class UUserWidget* PerkWidget, TArray<class UUserWidget*>& ConnectedWidgets, TSubclassOf<class UQtnPerk> PerkClass, bool ConnectedToSource);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnPlatformUtilitiesBlueprintLibrary
class UQtnPlatformUtilitiesBlueprintLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQtnPlatformUtilitiesBlueprintLibrary* GetDefaultObj();

	bool UseSwitchQuality();
	void ShowDebugMenu();
	void CollectGarbageWithParams(bool FullPurge);
	void BranchUseSwitchQuality(enum class EQtnUtilitiesSwitchQuality* Branch);
};

// 0x0 (0xA8 - 0xA8)
// Class QtnGame.QtnPlayerControlFSM
class UQtnPlayerControlFSM : public UQtnFSM
{
public:

	static class UClass* StaticClass();
	static class UQtnPlayerControlFSM* GetDefaultObj();

};

// 0x200 (0x7A0 - 0x5A0)
// Class QtnGame.QtnPlayerController
class AQtnPlayerController : public APlayerController
{
public:
	uint8                                        Pad_22BB[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnGameInstance*                      M_pCachedGameInstance;                             // 0x5A8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isAimingLocalOnly;                               // 0x5B0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_22BC[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_aimCausersLocalOnly;                             // 0x5B8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FQtnTargetingSweeper                  M_targetingLineTracer;                             // 0x5C8(0x30)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FQtnTargetingCone>             TargetingCones;                                    // 0x5F8(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class AQtnPlayerPawn*                        M_pPlayerPawn;                                     // 0x608(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnPlayerState*                       M_pPlayerState;                                    // 0x610(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnPlayerUI*                          M_pPlayerUI;                                       // 0x618(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnGameState*                         M_pGameState;                                      // 0x620(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        M_accumulatedForwardIntention;                     // 0x628(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        M_accumulatedRightIntention;                       // 0x62C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        M_accumulatedYawInput;                             // 0x630(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        M_accumulatedPitchInput;                           // 0x634(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_isCurrentlyOccupied;                             // 0x638(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22BD[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnPawn*>                      R_trackedThreats;                                  // 0x640(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         R_serverTravelPending;                             // 0x650(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         R_isUnderScriptedControl;                          // 0x651(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22BE[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_trackedThreatTimer;                              // 0x654(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          R_pPendingBodyToOccupy;                            // 0x658(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_pendingBodyToOccupyAcknowledgedByClient_ServerOnly; // 0x660(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_waitingForPendingBodyToOccupyOnClient;           // 0x661(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         M_processGyroAiming;                               // 0x662(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22BF[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        GyroYawScale;                                      // 0x664(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        GyroPitchScale;                                    // 0x668(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SprintSpeed;                                       // 0x66C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22C0[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	enum class EMovementMode                     M_lastKnownMovementMode;                           // 0x690(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22C1[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USoundMix*                             SoundMixModifier_Environment_Terrain;              // 0x698(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                             SoundMixModifier_Environment_Underwater;           // 0x6A0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                             SoundMixModifier_Eyes_Open;                        // 0x6A8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                             SoundMixModifier_Eyes_Closed;                      // 0x6B0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AudioListenerCameraToPawnBlend;                    // 0x6B8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22C2[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnScreen>>        M_uiPauseRequests_ServerOnly;                      // 0x6C0(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                        Pad_22C3[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnPlayerControlFSM*                  M_pPlayerControlFSM;                               // 0x6D8(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnPlayerControlStateBeforeOccupy*    M_pBeforeOccupyState;                              // 0x6E0(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnPlayerControlStateOccupying*       M_pOccupyingState;                                 // 0x6E8(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnPlayerControlStateHijacking*       M_pHijackingState;                                 // 0x6F0(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnPlayerControlStateDisembodied*     M_pDisembodiedState;                               // 0x6F8(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnPlayerControlStateTravelPending*   M_pTravelPendingState;                             // 0x700(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnCloudOptionsSaveData*              M_pCloudOptionsSaveData;                           // 0x708(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            PlayerControllerOccupyEvent;                       // 0x710(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerControllerUnOccupyEvent;                     // 0x720(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnBodyPawn>              PlayerBodyPawnClass;                               // 0x730(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnPlayerOptions                     PlayerOptions;                                     // 0x738(0x8)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        TrackedThreatLingerDuration;                       // 0x740(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MinCameraDistanceFromHead;                         // 0x744(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22C4[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_gameActionInhibitors;                            // 0x750(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_gameMovementInhibitors;                          // 0x760(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_gameLookInhibitors;                              // 0x770(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_forceFeedbackInhibitors;                         // 0x780(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_sprintInhibitors;                                // 0x790(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AQtnPlayerController* GetDefaultObj();

	void UntoggleSprint_LocalOnly();
	void SetTelepathicMessage(class FText& Message);
	void SetProcessGyroAiming(bool bProcessGyroAiming);
	void SetLobbyReadyState(bool Ready);
	void ServerSetStartLocation(const struct FVector& StartLocation);
	void ServerRemoveUIPauseRequest(TSubclassOf<class UQtnScreen> ScreenClass);
	void ServerKickSelfForDisconnection();
	void ServerAddUIPauseRequest(TSubclassOf<class UQtnScreen> ScreenClass);
	void ServerAcknowledgePendingBodyToOccupy();
	void ResetViewTargetToBody(bool PreserveCameraLook, float BlendTime, enum class EViewTargetBlendFunction BlendFunc, float BlendExp, bool LockOutgoing);
	void RemoveSprintInhibitor(class UObject* Inhibitor);
	void RemoveInputContext(TSubclassOf<class UQtnInputContext> InputContextClass);
	void RemoveGameMovementInhibitor(class UObject* Inhibitor);
	void RemoveGameLookInhibitor(class UObject* Inhibitor);
	void RemoveGameActionInhibitor(class UObject* Inhibitor);
	void RemoveForceFeedbackInhibitor(class UObject* Inhibitor);
	void QueueClientTravel(class FName LevelName, bool bAbsolute, const class FString& Options);
	void PushInputContext(TSubclassOf<class UQtnInputContext> InputContextClass);
	void PopInputContext();
	void OnRep_ServerTravelPending();
	void OnRep_PendingBodyToOccupy();
	void OnPlayerControllerUnOccupy(class AQtnBodyPawn* OccupiedBodyPawn);
	void OnPlayerControllerOccupy(class AQtnBodyPawn* OccupiedBodyPawn, bool FirstTime);
	void OnPlayerControllerDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnLocalPlayerScriptedControlChanged(bool IsUnderScriptedControl);
	bool IsTravelPending();
	bool IsSprintInhibited();
	bool IsInputActionAllowed(class FName InputAction);
	bool IsGameMovementInhibited();
	bool IsGameLookInhibited();
	bool IsGameActionInhibited();
	bool IsForceFeedbackInhibited();
	void HandleInventoryItemRemoved(class AQtnItem* PRemovedItem);
	void HandleInventoryItemAdded(class AQtnItem* PAddedItem);
	TArray<class AQtnPawn*> GetTrackedThreats();
	TArray<class UObject*> GetSprintInhibitors();
	class AQtnPlayerUI* GetPlayerUI();
	class AQtnPlayerState* GetPlayerState();
	class AQtnPlayerPawn* GetPlayerPawn();
	class AQtnBodyPawn* GetOriginalBodyPawn();
	class AQtnBodyPawn* GetOccupiedBodyPawn();
	void GetLocalPlayerControllerBP(class UObject* SelfReference, class AQtnPlayerController** LocalPlayerController, enum class EQtnOutputValidityEnum* OutputPin);
	float GetContextualInputAxisScalar(class FName InputAxis);
	class FName GetContextualInputAction(class FName InputAction);
	class FString ExecuteConsoleCommand(const class FString& Cmd);
	void ClientSetScriptedControlResponse(bool WantScriptedControl);
	void ClientSaveProgressData();
	void ClientRespondToPawnUnHijack(class AQtnPawn* PHijackedPawn);
	void ClientRespondToPawnHijack(class AQtnPawn* PHijackedPawn);
	void ClientRemoveEnemyThreat(class AQtnPawn* PEnemyThreat);
	void ClientPreSeamlessTravel();
	void ClientPostLogin();
	void ClientPerceiveSelfNoise(float Intensity);
	void ClientLoadProgressData();
	void ClientAddEnemyThreat(class AQtnPawn* PEnemyThreat);
	void CheckSprint(float DeltaSeconds, TSubclassOf<class UQtnPerk> EnergeticPerkClass, TSubclassOf<class UQtnAttributeStamina> StaminaAttributeClass, TSubclassOf<class UQtnTutorial> MovementSprintTutorialArchetype, class FName MovementSprintTutorialGoalIdentity);
	void AddSprintInhibitor(class UObject* Inhibitor);
	void AddGameMovementInhibitor(class UObject* Inhibitor);
	void AddGameLookInhibitor(class UObject* Inhibitor);
	void AddGameActionInhibitor(class UObject* Inhibitor);
	void AddForceFeedbackInhibitor(class UObject* Inhibitor);
};

// 0x8 (0x38 - 0x30)
// Class QtnGame.QtnPlayerControlState
class UQtnPlayerControlState : public UQtnFSMState
{
public:
	class AQtnPlayerController*                  M_pOwningPlayerController;                         // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UQtnPlayerControlState* GetDefaultObj();

};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnPlayerControlStateBeforeOccupy
class UQtnPlayerControlStateBeforeOccupy : public UQtnPlayerControlState
{
public:

	static class UClass* StaticClass();
	static class UQtnPlayerControlStateBeforeOccupy* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnPlayerControlStateDisembodied
class UQtnPlayerControlStateDisembodied : public UQtnPlayerControlState
{
public:
	class USoundMix*                             SoundMixModifier_Disembodied;                      // 0x38(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnPlayerControlStateDisembodied* GetDefaultObj();

};

// 0x28 (0x60 - 0x38)
// Class QtnGame.QtnPlayerControlStateHijacking
class UQtnPlayerControlStateHijacking : public UQtnPlayerControlState
{
public:
	class AQtnPawn*                              M_pHijackedPawn;                                   // 0x38(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pPreviousHijackedPawnOwner;                      // 0x40(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pPreviousEquippedItemRight;                      // 0x48(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pPreviousEquippedItemLeft;                       // 0x50(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                             SoundMixModifier_Hijacking;                        // 0x58(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnPlayerControlStateHijacking* GetDefaultObj();

};

// 0x18 (0x50 - 0x38)
// Class QtnGame.QtnPlayerControlStateOccupying
class UQtnPlayerControlStateOccupying : public UQtnPlayerControlState
{
public:
	class AQtnBodyPawn*                          M_pOccupiedBodyPawn;                               // 0x38(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_unlockedBodyYawAdjustment;                       // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_firstTime;                                       // 0x44(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_22CB[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USoundMix*                             SoundMixModifier_Occupying;                        // 0x48(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnPlayerControlStateOccupying* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnPlayerControlStateTravelPending
class UQtnPlayerControlStateTravelPending : public UQtnPlayerControlState
{
public:
	bool                                         M_travelAttempted;                                 // 0x38(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_22CC[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnPlayerControlStateTravelPending* GetDefaultObj();

};

// 0x30 (0x150 - 0x120)
// Class QtnGame.QtnPlayerDataBag
class UQtnPlayerDataBag : public UQtnDataBag
{
public:
	TArray<TSubclassOf<class UQtnWorldCustomization>> EarnedWorldCustomizations;                         // 0x120(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            AssociatePlayerDataEvent;                          // 0x130(0x10)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            UnAssociatePlayerDataEvent;                        // 0x140(0x10)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnPlayerDataBag* GetDefaultObj();

	void OnUnAssociatePlayerData(class AQtnPlayerPawn* PlayerPawn);
	void OnAssociatePlayerData(class AQtnPlayerPawn* PlayerPawn);
	bool HasWorldCustomization(TSubclassOf<class UQtnWorldCustomization> WorldCustomization);
	TArray<TSubclassOf<class UQtnWorldCustomization>> GetAvailableWorldCustomizations(TSubclassOf<class UQtnWorldCustomization> baseClass);
};

// 0x48 (0x128 - 0xE0)
// Class QtnGame.QtnPlayerNameplateManagerComponent
class UQtnPlayerNameplateManagerComponent : public UActorComponent
{
public:
	TSubclassOf<class UQtnPlayerNameplateWidget> WidgetClass;                                       // 0xE0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FQtnPlayerNameplateInfo>       M_ActivePlayerNameplatesArray;                     // 0xE8(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         M_bHasValidSetup;                                  // 0xF8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_22D7[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_PlayerNameplateScale;                            // 0xFC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bAreNameplatesHidden;                            // 0x100(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_22D8[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_NameplateInhibitors_LocalOnly;                   // 0x108(0x10)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnNameplateScaleChangedEvent;                      // 0x118(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnPlayerNameplateManagerComponent* GetDefaultObj();

	void SetupActorNameplate(class AQtnPawn* TargetPawn, struct FVector& Offset);
	void SetNameplatesScale(float Scale);
	void SetNameplatesHidden(bool IsHidden);
	void RemoveNameplateVisibilityInhibitor(class UObject* InhibitorObject);
	void QtnNameplateScalingEvent__DelegateSignature(float NewScale);
	class UQtnPlayerNameplateManagerComponent* GetQtnPlayerNameplateManagerComponent(class UObject* WorldContextObject);
	float GetNameplatesScale();
	void EditorHelper_SetWidgetClass(TSubclassOf<class UUserWidget> ClassToSet);
	void DestroyActorNameplate(class AQtnPawn* TargetPawn);
	bool AreNameplatesHidden();
	void AddNameplateVisibilityInhibitor(class UObject* InhibitorObject);
};

// 0x10 (0x270 - 0x260)
// Class QtnGame.QtnPlayerNameplateWidget
class UQtnPlayerNameplateWidget : public UUserWidget
{
public:
	class AQtnPawn*                              TargetPawn;                                        // 0x260(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        OffsetAmount;                                      // 0x268(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_22DA[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnPlayerNameplateWidget* GetDefaultObj();

	void OnUpdateNameplateScale(float WidgetScale);
	void OnInitializeNameplateWidgetEvent(class AQtnPawn* Target);
};

// 0x150 (0xC20 - 0xAD0)
// Class QtnGame.QtnPlayerPawn
class AQtnPlayerPawn : public AQtnPawn
{
public:
	float                                        M_neglectCalculationTimer;                         // 0xAD0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_22FF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnInputComponent>        InputComponentArchetype;                           // 0xAD8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasRegisteredSelfWithSaveLoadManager;            // 0xAE0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2301[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPlayerState*                       M_pPlayerState;                                    // 0xAE8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerController*                  M_pPlayerController;                               // 0xAF0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pCurrentAttachedBodyPawn;                        // 0xAF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          R_pOriginalBodyPawn;                               // 0xB00(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          R_pOccupiedBodyPawn;                               // 0xB08(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_playerReadyForGameplayPending;                   // 0xB10(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_hasOptedInToPassiveEscape;                       // 0xB11(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_isConsciousnessSuppressed;                       // 0xB12(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2304[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class APlayerCameraManager*                  M_pCachedLocalCameraManager;                       // 0xB18(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasOccupiedBodyBefore;                           // 0xB20(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasEverBeenReadyForGameplay;                     // 0xB21(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2305[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSet<class AQtnBodyPawn*>                    M_potentiallyRelevantBodyPawns;                    // 0xB28(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_isPlayingInMission;                              // 0xB78(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_doFadeUp;                                        // 0xB79(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2306[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnFriendshipComponent*               M_pFriendshipComponent;                            // 0xB80(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnPawn*                              R_pCurrentPawnFocus;                               // 0xB88(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                       R_pCurrentComponentFocus;                          // 0xB90(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerPawnOccupyEvent;                             // 0xB98(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            PlayerPawnUnOccupyEvent;                           // 0xBA8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        FadeUpDuration;                                    // 0xBB8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2307[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            PlayerPawnSuppressionEvent;                        // 0xBC0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UQtnFaceBlindnessFX*                   M_pBodyFaceBlindness;                              // 0xBD0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PassiveEscapeButtonMashRate;                       // 0xBD8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2309[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPawn*                              R_pHijackedPawn;                                   // 0xBE0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_230A[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnSetIntentionEquippedItemMeleeEvent;              // 0xBF0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSetIntentionEquippedItemRangedEvent;             // 0xC00(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UQtnDevCheatsComponent>    DevCheatsArchetype;                                // 0xC10(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnDevCheatsComponent*                R_pDevCheats;                                      // 0xC18(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AQtnPlayerPawn* GetDefaultObj();

	void SetSuppression_ServerOnly(bool WantSuppression);
	void ServerToggleGhostCheat();
	void ServerToggleFlyCheat();
	void ServerSetPotentiallyRelevantBodyPawn(class AQtnBodyPawn* PBodyPawn, bool IsPotentiallyRelevant);
	void ServerSetPassiveEscape(bool WantPassiveEscape);
	void ServerSetIntentionWorldMovement(const struct FVector& WorldMovement);
	void ServerSetIntentionWorldLook(float WorldLookYaw, float WorldLookPitch, bool bodyYawAlso);
	void ServerSetIntentionWorldBodyYaw(float WorldBodyYaw);
	void ServerSetIntentionTargetedObject(class UObject* PTargetedObject);
	void ServerSetIntentionStance(enum class EQtnBodyStance Stance);
	void ServerSetIntentionRelativeLookYaw(float RelativeLookYaw);
	void ServerSetIntentionEquippedItemRanged(class AQtnItem* PEquippedClassRanged);
	void ServerSetIntentionEquippedItemMelee(class AQtnItem* PEquippedClassMelee);
	void ServerSetHijackedPawn(class AQtnPawn* PPawnToHijack);
	void ServerSetBodyActionPressed(enum class EQtnUIBodyActionEnum BodyAction, bool Pressed);
	void ServerPlayerUnOccupy(class AQtnBodyPawn* POccupiedBodyPawn);
	void ServerEnsureDevCheats();
	void QtnPlayerPawnUnOccupyEvent__DelegateSignature(class AQtnBodyPawn* OccupiedBodyPawn);
	void QtnPlayerPawnSuppressionEvent__DelegateSignature(class AQtnBodyPawn* OccupiedBodyPawn, bool Suppressed);
	void QtnPlayerPawnOccupyEvent__DelegateSignature(class AQtnBodyPawn* OccupiedBodyPawn, bool FirstTime);
	void QtnPlayerPawnEquipEvent__DelegateSignature(class AQtnItem* EquippedItem);
	void OnRep_OriginalBodyPawn();
	void OnRep_IsConsciousnessSuppressed();
	void OnRep_HijackedPawn();
	void OnPlayerPawnUnOccupy(class AQtnBodyPawn* OccupiedBodyPawn);
	void OnPlayerPawnOccupy(class AQtnBodyPawn* OccupiedBodyPawn, bool FirstTime);
	void NotifyLocalPlayer(class UObject* SelfReference, class FText NotificationText, enum class EQtnNotificationType NotificationType, float Duration);
	void MulticastSetGhostCheat(bool WantGhost);
	void MulticastSetFlyCheat(bool WantFly);
	void LocalSetIntentionStance(enum class EQtnBodyStance Stance);
	bool IsCurrentlyInAMission();
	bool IsConsciousnessSuppressed();
	bool IsBodyPawnPotentiallyRelevantToLocalPlayer(class AQtnBodyPawn* PBodyPawn);
	bool IsBodyPawnPotentiallyRelevantToAnyPlayer_ServerOnly(class AQtnBodyPawn* PBodyPawn);
	bool HasOptedInToPassiveEscape();
	void HandleBodyAliveChange_ServerOnly(class AQtnBodyPawn* bodyPawn, class AActor* AlivenessInstigator, enum class EQtnBodyAliveness OldBodyAliveness, enum class EQtnBodyAliveness bodyAliveness, bool IsServer);
	void GetTelepathicMessageInfo(class FText* Text, bool* bSeen);
	float GetTeamSurvivalRatio(class UObject* SelfReference, int32* NumSurvivors, int32* TeamSize);
	class AQtnPlayerState* GetQtnPlayerState();
	class AQtnPlayerController* GetQtnPlayerController();
	class AQtnPlayerUI* GetPlayerUI();
	class AQtnBodyPawn* GetOriginalBodyPawn();
	class AQtnBodyPawn* GetOccupiedBodyPawn();
	int32 GetNumberOfPlayers(class UObject* SelfReference);
	class AQtnPlayerPawn* GetLocalPlayerPawn(class UObject* SelfReference, enum class EQtnOutputValidityEnum* OutputPin);
	class AQtnBodyPawn* GetLocalPlayerOriginalBody(class UObject* SelfReference, enum class EQtnOutputValidityEnum* OutputPin);
	class AQtnBodyPawn* GetLocalPlayerOccupiedBody(class UObject* SelfReference, enum class EQtnOutputValidityEnum* OutputPin);
	void GetLocalPlayerInformation(class UObject* SelfReference, class AQtnBodyPawn** OccupiedBodyPawn, class AQtnPlayerPawn** PlayerPawn, class AQtnPlayerController** PlayerController, class AQtnPlayerUI** PlayerUI, class AQtnPlayerState** QtnPlayerState, bool* IsHosting, enum class EQtnOutputValidityEnum* OutputPin);
	class AQtnPlayerController* GetLocalPlayerController();
	class AQtnPawn* GetHijackedPawn();
	class UQtnDevCheatsComponent* GetDevCheatsComponent();
	class AQtnPawn* GetCurrentlyControlledPawn();
	class AQtnBodyPawn* GetAvailableBodyPawn();
	void GetAllQtnPlayerBodies(class UObject* SelfReference, TArray<class AQtnBodyPawn*>* FoundPlayerBodies);
	void GetAllPlayerPawns(class UObject* SelfReference, TArray<class AQtnPlayerPawn*>* FoundPlayerPawns);
	void ClientSetIntentionEquippedItemRanged(class AQtnItem* PEquippedItemRanged, bool UNSET);
	void ClientSetIntentionEquippedItemMelee(class AQtnItem* PEquippedItemMelee, bool UNSET);
	void ClientSetIntentionAction(const struct FQtnActionIntention& ActionIntention);
	void ClearHijackedpawn();
};

// 0x0 (0xCB0 - 0xCB0)
// Class QtnGame.QtnPlayerPawnMovement
class UQtnPlayerPawnMovement : public UQtnMovementComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnPlayerPawnMovement* GetDefaultObj();

};

// 0x78 (0xA0 - 0x28)
// Class QtnGame.QtnPlayerRunProgress
class UQtnPlayerRunProgress : public UObject
{
public:
	TMap<TSubclassOf<class UQtnPlayerRunProgress>, class UQtnPlayerRunProgress*> M_trackedPlayerSubProgress;                        // 0x28(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AQtnPlayerState*                       M_pAssociatedPlayerState;                          // 0x78(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pAssociatedPlayerBody;                           // 0x80(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasCheckpointHappened;                           // 0x88(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2318[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnPlayerRunProgress>> DefaultPlayerSubProgresses;                        // 0x90(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnPlayerRunProgress* GetDefaultObj();

	void OnRunProgressReset_ServerOnly();
	void OnRunProgressCheckpoint_ServerOnly(class AQtnBodyPawn* PlayerBody, bool FlushMissionProgress);
	void OnReadyForGameplay_ServerOnly(class AQtnPlayerPawn* PlayerPawn, class AQtnBodyPawn* PlayerBody, bool HasCheckpointHappened);
	void OnPlayerRunProgressInit_ServerOnly();
	void OnMapEndPlay_ServerOnly(bool TravelPending);
	void OnMapBeginPlay_ServerOnly();
	void OnExitWorld_ServerOnly(class AQtnPlayerPawn* PlayerPawn, class AQtnBodyPawn* PlayerBody);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool HasCheckpointHappened_ServerOnly();
	class UQtnPlayerRunProgress* GetPlayerSubProgress_ServerOnly(TSubclassOf<class UQtnPlayerRunProgress> SubProgressArchetype);
	class AQtnPlayerState* GetAssociatedPlayerState_ServerOnly();
	class AQtnBodyPawn* GetAssociatedPlayerBody_ServerOnly();
	class UQtnPlayerRunProgress* AddPlayerSubProgress_ServerOnly(TSubclassOf<class UQtnPlayerRunProgress> SubProgressArchetype);
};

// 0x8 (0x288 - 0x280)
// Class QtnGame.QtnPlayerStart
class AQtnPlayerStart : public APlayerStart
{
public:
	bool                                         M_hasBeenUsed;                                     // 0x280(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_231B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        UseOnlyForArc;                                     // 0x284(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnPlayerStart* GetDefaultObj();

	bool IsPlayerStartValid(int32 Arc);
};

// 0x58 (0x3A8 - 0x350)
// Class QtnGame.QtnPlayerState
class AQtnPlayerState : public APlayerState
{
public:
	class AQtnPlayerController*                  M_pKnownPlayerController;                          // 0x350(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerPawn*                        M_pOwningPlayerPawn;                               // 0x358(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_gotBannedByHost;                                 // 0x360(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnPersistentPlayerState             M_persistentPlayerState;                           // 0x361(0x2)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_initialBodySpawnPending;                         // 0x363(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_saveLoadReadinessAcknowledgedLocally;            // 0x364(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_saveLoadReadinessAcknowledgedOnServer;           // 0x365(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2324[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        R_playerArrayIndex;                                // 0x368(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_bIsTalking;                                      // 0x36C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2325[0xF];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         R_lobbyReadyState;                                 // 0x37C(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2326[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                M_PlayerSessionId;                                 // 0x380(0x10)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                M_MatchmakingPlayerId;                             // 0x390(0x10)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        R_playerNumber;                                    // 0x3A0(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         R_bIsSilenced;                                     // 0x3A4(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2327[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnPlayerState* GetDefaultObj();

	class AQtnPlayerState* StaticGetLocalPlayerState(class UObject* WorldContextObject);
	void ServerSetLobbyReadyState(bool Ready);
	void ServerAcknowledgeSaveLoadReadiness();
	struct FUniqueNetIdRepl QtnGetUniqueId();
	void OnRep_LobbyReadyState();
	bool MatchesQtnUniqueId(struct FUniqueNetIdRepl& InUniqueId);
	bool IsPlayerTalking();
	bool IsLocalPlayer();
	bool IsHost();
	bool GotBannedByHost();
	float GetRelevantPing();
	class AQtnPlayerPawn* GetOwningPlayerPawn();
	class AQtnPlayerController* GetKnownPlayerController();
	class FString GetHumanReadableName();
	int32 GetAuthoritativePlayerArrayIndex();
	void GetAllPlayerStates(class UObject* SelfReference, TArray<class AQtnPlayerState*>* CurrentPlayerStates);
	void ClientNotifyKicked(bool banFromReentering, class FText& KickReason);
};

// 0x560 (0x8A0 - 0x340)
// Class QtnGame.QtnPlayerUI
class AQtnPlayerUI : public AHUD
{
public:
	class AQtnPlayerController*                  M_pOwningPlayerController;                         // 0x340(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pDebugTargetMovementGoal;                        // 0x348(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFont*                                 DebugFont;                                         // 0x350(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFont*                                 TargetingFont;                                     // 0x358(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_frameTimeMS;                                     // 0x360(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_debugHintTimer;                                  // 0x364(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             BugItDisplayLocationOffset;                        // 0x368(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UQtnScreenLoading>       LoadingScreenClass;                                // 0x370(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UQtnScreen>              DebugRootScreenClass;                              // 0x398(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_screenMessageRestoreValue;                       // 0x3C0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2362[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_screenMessageInhibitors;                         // 0x3C8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_uiInhibitors;                                    // 0x3D8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         M_refreshDebugTarget;                              // 0x3E8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_debugTargetSelectionPressed;                     // 0x3E9(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2364[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               M_refreshDebugTargetTraceLocation;                 // 0x3EC(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnDisplayDebugPage>> M_displayDebugPageClasses;                         // 0x3F8(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UQtnDisplayDebugPage*>          M_displayDebugPages;                               // 0x408(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                        M_displayDebugPageActive;                          // 0x418(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_displayDebugPageIndex;                           // 0x41C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnScreenStack                       M_screenStackStructs[0x4];                         // 0x420(0x280)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_waitingForSafeInitialization;                    // 0x6A0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_pendingInitFadeUp;                               // 0x6A1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2365[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          M_pOccupiedBodyPawn;                               // 0x6A8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_readyForGameplay;                                // 0x6B0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2366[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_uiActionInhibitors;                              // 0x6B8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UQtnScreenModalDialog*                 M_pModalDialogScreen;                              // 0x6C8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnScreenMessagingHUD*                M_pMessagingHUDScreen;                             // 0x6D0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_mouseAndKeyboardUsageDetected;                   // 0x6D8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_wasUsingMouseAndKeyboard;                        // 0x6D9(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_forceInputUsageChangeEvent;                      // 0x6DA(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2368[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector2D                             M_accumulatedMouseDelta;                           // 0x6DC(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             M_currentMouseDelta;                               // 0x6E4(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             M_lastMousePosition;                               // 0x6EC(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             M_lastCursorPosition;                              // 0x6F4(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             M_currentCursorDelta;                              // 0x6FC(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             M_currentLeftStickInput;                           // 0x704(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                             M_currentRightStickInput;                          // 0x70C(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_currentlyFeelingThreatened;                      // 0x714(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_236A[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UAudioComponent*                       UIAudioComponent;                                  // 0x718(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                            AIThreatAudioStinger;                              // 0x720(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UQtnScreen>>      ManagedScreenClasses;                              // 0x728(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UQtnScreen>>      ManagedScreenClassesSecondary;                     // 0x738(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UQtnScreen>>      ManagedScreenClassesTertiary;                      // 0x748(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UQtnScreen>>      ManagedScreenClassesQuaternary;                    // 0x758(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                        StickScrollMultiplier;                             // 0x768(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_236C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class FName>                          AlwaysOnSubtitleCategories;                        // 0x770(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnSubtitleChangedEvent;                            // 0x780(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TArray<enum class EQtnUIScreenActionEnum>    M_pressedScreenActions;                            // 0x790(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_236D[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            PlayerUIBodyOccupyEvent;                           // 0x7B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            PlayerUIBodyUnOccupyEvent;                         // 0x7C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                         M_wantsToSprint;                                   // 0x7D0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_sprintToggleActive;                              // 0x7D1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_isSprintPressed;                                 // 0x7D2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_236E[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnDebugScreen*>               M_pCurrentDebugScreenArray;                        // 0x7D8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ToggleUIEvent;                                     // 0x7E8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            ThreatAddRemoveEvent;                              // 0x7F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            InputUsageChangeEvent;                             // 0x808(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                M_pDebugTargetActor;                               // 0x818(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                  SubtitleText;                                      // 0x820(0x18)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FName                                  SubtitleCategory;                                  // 0x838(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IQtnTargetableInterface> M_pLastTargetableInterface;                        // 0x840(0x10)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UTexture2D*                            NormalReticleTexture;                              // 0x850(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                            FrobbingReticleTexture;                            // 0x858(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnAffordanceInfo                    M_affordanceInfo;                                  // 0x860(0x30)(Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnTutorial>              M_pMostRecentCustomTutorialArchetype;              // 0x890(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2370[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnPlayerUI* GetDefaultObj();

	void UnRegisterScreen(TSubclassOf<class UQtnScreen> ScreenClass, enum class EQtnScreenStackEnum ScreenStackIndex);
	void ToggleScreen(TSubclassOf<class UQtnScreen> ScreenClass, enum class EQtnScreenStackEnum ScreenStackIndex);
	void ShowScreen(TSubclassOf<class UQtnScreen> ScreenClass, enum class EQtnScreenStackEnum ScreenStackIndex);
	void ShowPopUpMessage(class FText TextToShow, float PopUpTime, bool IsQueued);
	void ShowHint(class FText HintText, float Duration, bool ShowEvenIfUIDisabled);
	class UQtnScreen* RegisterScreen(TSubclassOf<class UQtnScreen> ScreenClass, enum class EQtnScreenStackEnum ScreenStackIndex);
	class UUserWidget* QueueSimpleModalDialog(class FText Title, class FText Message);
	void QueueNotification(class FText NotificationText, float MinNotificationDuration);
	class UUserWidget* QueueModalDialog(class FText Title, class FText Message, class UObject* ConfigObject, enum class EQtnModalDialogType ModalDialogType, FDelegateProperty_& DialogFinishedDelegate, bool MustScrollToBottom);
	void QueueErrorDialog(class FText Title, class FText Message, const struct FQtnOnlineErrorCode& ErrorCode);
	void QtnToggleUI();
	void QtnSetUIEnabled(bool WantEnabled, class UObject* UiInhibitor);
	void QtnLetThereBeLight();
	void QtnInputUsageChangeEvent__DelegateSignature(bool IsUsingMouseAndKeyboard);
	void QtnDebugUI();
	void QtnDebugPageSet(int32& PageIndex);
	void QtnDebugActor(class FString& ActorName);
	void QtnBugItHotKey();
	void QtnBugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll);
	void QtnBugIt(const class FString& ScreenShotDescription);
	void OnPlayerUIUnOccupy(class AQtnBodyPawn* OccupiedBodyPawn);
	void OnPlayerUIUnHijack(class AQtnPawn* HijackedPawn);
	void OnPlayerUIReadyForGameplay();
	void OnPlayerUIOccupy(class AQtnBodyPawn* OccupiedBodyPawn, bool FirstTime);
	void OnPlayerUIHijack(class AQtnPawn* HijackedPawn);
	void OnDamageApplied(struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo);
	bool IsUsingMouseAndKeyboard();
	bool IsUIHidden();
	bool IsScreenActionPressed(enum class EQtnUIScreenActionEnum ScreenAction);
	bool IsReadyForSafeUsage();
	bool IsReadyForGameplay();
	bool IsLocalPlayerUIReadyBP(class UObject* SelfReference);
	bool IsBodyActionPressed(struct FQtnPawnIntentions& PawnIntentions, enum class EQtnUIBodyActionEnum BodyAction);
	bool IsAnyBodyActionPressed(struct FQtnPawnIntentions& PawnIntentions);
	void HideScreen(TSubclassOf<class UQtnScreen> ScreenClass, enum class EQtnScreenStackEnum ScreenStackIndex, bool UnRegister);
	void HideHint();
	void HideAllScreens();
	void HandleItemRemoveNotification(TSubclassOf<class AQtnItem> ItemClass);
	void HandleItemAddNotification(TSubclassOf<class AQtnItem> ItemClass);
	void HandleItemAddDisplayDataOnlyNotification(class FText InDisplayName);
	class UQtnViewportHUD* GetViewportHUD();
	TArray<class AQtnPawn*> GetTrackedThreats();
	class UQtnScreen* GetScreenThatOwnsThisWidget(class UUserWidget* UserWidget, enum class EQtnScreenStackEnum ScreenStackIndex, bool CheckSubScreens);
	class UQtnScreen* GetScreen(TSubclassOf<class UQtnScreen> ScreenClass, enum class EQtnScreenStackEnum ScreenStackIndex, bool CheckForInheritedClasses, bool RegisterOnDemand);
	struct FVector2D GetRightStickInput();
	class AQtnPlayerState* GetOwningQtnPlayerState();
	class AQtnPlayerController* GetOwningQtnPlayerController();
	class AQtnPlayerPawn* GetOwningPlayerPawn();
	class AQtnBodyPawn* GetOccupiedBody();
	struct FVector2D GetMousePosition();
	struct FVector2D GetMouseDelta();
	TSubclassOf<class UQtnTutorial> GetMostRecentCustomTutorialArchetype();
	class UQtnScreenMessagingHUD* GetMessagingHUD();
	void GetLocalPlayerUIBP(class UObject* SelfReference, class AQtnPlayerUI** LocalPlayerUI, enum class EQtnOutputValidityEnum* OutputPin);
	struct FVector2D GetLeftStickInput();
	class AActor* GetDebugTargetActor();
	class UCanvas* GetDebugCanvas();
	struct FVector2D GetCursorPosition();
	struct FVector2D GetCursorDelta();
	class FString GetButtonGlyphFromBodyAction(class UObject* SelfReference, enum class EQtnUIBodyActionEnum BodyAction, bool EncloseKeyboardKeysInBrackets);
	class FString GetBugItInfoFromBP();
	void GetAffordanceInfo(struct FQtnAffordanceInfo* AffordanceInfo);
	class UQtnScreen* GetActiveScreen(enum class EQtnScreenStackEnum ScreenStackIndex);
	void ForceInputChangeEvent(class UObject* SelfReference);
	void DebugActor(class AActor* ActorToDebug);
	void BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll);
	void BugIt(const class FString& ScreenShotDescription);
};

// 0xA0 (0x2F0 - 0x250)
// Class QtnGame.QtnPoolableActor
class AQtnPoolableActor : public AActor
{
public:
	uint32                                       MaxPoolSize;                                       // 0x250(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                       PoolPrimeSize;                                     // 0x254(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAutoCleanupEnable;                                // 0x258(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_237C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        UnsedCleanTime;                                    // 0x25C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ExpectedKillTime;                                  // 0x260(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_237D[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPoolingInfo                          R_PoolingInfo;                                     // 0x270(0x40)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPoolingInfo                          L_PoolingInfo;                                     // 0x2B0(0x40)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class AQtnPoolableActor* GetDefaultObj();

	void OnReusedFromPool();
	void OnRep_PoollingInfo();
	void OnReclaimToPool();
	bool IsPoolingEnabled();
	enum class EQtnActorPoolingState GetPoolingState();
};

// 0x778 (0x7A0 - 0x28)
// Class QtnGame.QtnPostProcessFX
class UQtnPostProcessFX : public UObject
{
public:
	uint8                                        Pad_237E[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_bIsActive;                                       // 0x30(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_237F[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pTargetActor;                                    // 0x38(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_BeginTime;                                       // 0x40(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_EndTime;                                         // 0x44(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_CurrentWeight;                                   // 0x48(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2380[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPostProcessSettings                  Settings;                                          // 0x50(0x560)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                        Priority;                                          // 0x5B0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InnerRadius;                                       // 0x5B4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        OuterRadius;                                       // 0x5B8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        Weight;                                            // 0x5BC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsLooping;                                        // 0x5C0(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsViewerEffect;                                   // 0x5C1(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseSimpleCurve;                                   // 0x5C2(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2382[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        BlendInTime;                                       // 0x5C4(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        Duration;                                          // 0x5C8(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BlendOutTime;                                      // 0x5CC(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                    PrimaryCurve;                                      // 0x5D0(0x88)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                    OptionalLoopCurve;                                 // 0x658(0x88)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                    BlendOutCurve;                                     // 0x6E0(0x88)(Edit, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>      SpawnedPostProcessMaterials;                       // 0x768(0x10)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>             M_storedPostProcessMaterials;                      // 0x778(0x10)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEffectFinished;                                  // 0x788(0x10)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_2384[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnPostProcessFX* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnProgressLoadState
class UQtnProgressLoadState : public UQtnSaveLoadState
{
public:
	uint8                                        Pad_2385[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnProgressLoadState* GetDefaultObj();

};

// 0x50 (0x220 - 0x1D0)
// Class QtnGame.QtnProgressSaveData
class UQtnProgressSaveData : public UQtnSaveData
{
public:
	class UQtnTutorialDataBag*                   M_pTutorialDataBag;                                // 0x1D0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnNarrativeDataBag*                  M_pNarrativeDataBag;                               // 0x1D8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnPlayerDataBag*                     M_pPlayerDataBag;                                  // 0x1E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnBodyDataBag*                       M_heroBodyDataBag;                                 // 0x1E8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_pOccupiedBodyPawn;                               // 0x1F0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_pendingRefreshPlayerStateInfo;                   // 0x1F8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2389[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnTutorialDataBag>       TutorialDataBagArchetype;                          // 0x200(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnNarrativeDataBag>      NarrativeDataBagArchetype;                         // 0x208(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnPlayerDataBag>         PlayerDataBagArchetype;                            // 0x210(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnBodyDataBag>           BodyDataBagArchetype;                              // 0x218(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnProgressSaveData* GetDefaultObj();

	class UQtnTutorialDataBag* GetTutorialDataBag();
	class UQtnPlayerDataBag* GetPlayerDataBag();
	class UQtnNarrativeDataBag* GetNarrativeDataBag();
	class UQtnBodyDataBag* GetBodyDataBag();
};

// 0x8 (0x40 - 0x38)
// Class QtnGame.QtnProgressSaveState
class UQtnProgressSaveState : public UQtnSaveLoadState
{
public:
	bool                                         M_finished;                                        // 0x38(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_238A[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnProgressSaveState* GetDefaultObj();

};

// 0x160 (0x450 - 0x2F0)
// Class QtnGame.QtnProjectile
class AQtnProjectile : public AQtnPoolableActor
{
public:
	class UQtnProjectileMovementComponent*       M_pProjectileMovementController;                   // 0x2F0(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                       RootToMove;                                        // 0x2F8(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                  Mesh;                                              // 0x300(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                            ContactFXTable;                                    // 0x308(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnContactData*                       ContactFXAsset;                                    // 0x310(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         DrawImpactDebug;                                   // 0x318(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_239F[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnGameState*                         M_pCachedGameState;                                // 0x320(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_readyForGameplayPending;                         // 0x328(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_reflectedThisFrame_ServerOnly;                   // 0x329(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23A0[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_reflectionCount_ServerOnly;                      // 0x32C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_blocked_ServerOnly;                              // 0x330(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23A1[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               M_lastHomingVelocity_ServerOnly;                   // 0x334(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_initPending;                                     // 0x340(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23A2[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnProjectileSweeper                 M_projectileSweeper;                               // 0x348(0xA0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                        SweepRadius;                                       // 0x3E8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               SweepCheckOffset;                                  // 0x3EC(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bUseSimplifiedSweep;                               // 0x3F8(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_HasIssuedRadialDamage;                           // 0x3F9(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         DestroyOnImpact;                                   // 0x3FA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         DoRadialBlockingGeometrySweep;                     // 0x3FB(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        RadialImpactOffset;                                // 0x3FC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                R_launchingActor;                                  // 0x400(0x8)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPawn*                              M_pProjectileCulprit;                              // 0x408(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnVerb*                              R_sourceVerb;                                      // 0x410(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               R_launchVelocity;                                  // 0x418(0xC)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ECollisionChannel                 SweepChannel;                                      // 0x424(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23A4[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnDamageType>            ProjectileDamageType;                              // 0x428(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnProjectileTargetGatheringType TargetGatheringType;                               // 0x430(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23A5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        BaseDamageRadius;                                  // 0x434(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultDamageAmount;                               // 0x438(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ScaleDamageUsingRadius;                            // 0x43C(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CausesKnockdown;                                   // 0x43D(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnHitStopResponse               HitStopResponse;                                   // 0x43E(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CanBeParried;                                      // 0x43F(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         CanBeBlocked;                                      // 0x440(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         HideActorUponDestroy;                              // 0x441(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23A7[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LifeSpanUponDestroy;                               // 0x444(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bPoolingEnabled;                                   // 0x448(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DespawnUponCombatInhibition;                       // 0x449(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23A9[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnProjectile* GetDefaultObj();

	void SetSweepDebugging(bool SetToDebug);
	void SetProjectileVelocity_ServerOnly(const struct FVector& NewVelocity);
	void SetProjectileGravityScale(float GravityScale);
	void ReflectProjectileAtPawn_ServerOnly(class UQtnVerb* ReflectingVerb, class AActor* ReflectingActor, class AQtnPawn* NewCulprit, class AQtnPawn* TargetPawn);
	void ReflectProjectile_ServerOnly(class UQtnVerb* ReflectingVerb, class AActor* ReflectingActor, class AQtnPawn* NewCulprit, struct FVector& NewVelocity);
	void OnRep_SourceVerb();
	void OnRep_LaunchVelocity();
	void OnRep_LaunchingActor();
	void OnReflection_ServerOnly(class UQtnVerb* ReflectingVerb, class AActor* ReflectingActor, class AQtnPawn* NewCulprit, struct FVector& NewVelocity);
	void OnQtnReadyForGameplay();
	void OnInitProjectile(class AActor* SourceOwner, class UQtnVerb* InSourceVerb, const struct FVector& InitialVelocity, bool IsServer);
	void OnFinalizeImpactEvent(const struct FHitResult& HitResult, bool IsServer);
	void OnBlocked_ServerOnly(class UQtnVerb* blockingVerb, class AActor* blockingActor, class AQtnPawn* blockingPawn);
	void OnActorPreHit_ServerOnly(class AActor* ActorAboutToBeHit, struct FHitResult& HitResult, bool* IgnoreCollision);
	void MulticastProjectileImpact(const struct FHitResult& HitResult);
	bool IsValidActorToHit(class AActor* TargetActor, struct FHitResult& HitResult);
	bool IsReadyForGameplay();
	void IncrementReflectionCount_ServerOnly();
	bool HandleDestroyProjectileEvent(struct FHitResult& HitResult, bool IsServer);
	class UQtnVerb* GetSourceVerb();
	class AActor* GetSourceActor();
	int32 GetReflectionCount_ServerOnly();
	struct FVector GetProjectileVelocity();
	class UQtnProjectileMovementComponent* GetProjectileMovement();
	struct FVector GetProjectileGravity();
	float GetKnockbackDuration(class AActor* TargetActor);
	struct FVector GetKnockbackAmount(class AActor* TargetActor);
	void GetDamageRadii(struct FQtnRangedFloat* DamageRadii);
	float GetDamageAmount(class AActor* TargetActor, float* BaseDamage);
	class AQtnPawn* GetCulprit();
	class FName GetContactFXKey();
	struct FQtnDamageInfo ConstructDamageInfo(class AActor* TargetActor);
	void BlockProjectile_ServerOnly(class UQtnVerb* blockingVerb, class AActor* blockingActor, class AQtnPawn* blockingPawn);
	void ApplyProjectileDamage(class AActor* ProjectileVictim, struct FQtnDamageInfo& DamageInfo);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnProjectileInterceptInterface
class IQtnProjectileInterceptInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnProjectileInterceptInterface* GetDefaultObj();

	void OnProjectilePreHit_ServerOnly(class AQtnProjectile* Projectile, bool* IgnoreCollision);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnProjectileLauncherInterface
class IQtnProjectileLauncherInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnProjectileLauncherInterface* GetDefaultObj();

	void OnProjectileSpawned(class AQtnProjectile* SpawnedProjectile, bool IsServer);
	class AQtnPawn* GetProjectileCulprit();
};

// 0x10 (0x210 - 0x200)
// Class QtnGame.QtnProjectileMovementComponent
class UQtnProjectileMovementComponent : public UProjectileMovementComponent
{
public:
	struct FVector                               M_lastPosition;                                    // 0x200(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        RoundRobinBucketSize;                              // 0x20C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnProjectileMovementComponent* GetDefaultObj();

};

// 0x48 (0x298 - 0x250)
// Class QtnGame.QtnProjectileSpawner
class AQtnProjectileSpawner : public AActor
{
public:
	class AQtnGameState*                         M_pCachedGameState;                                // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnBodyPawn*                          M_spawnedBodyPawn;                                 // 0x258(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnVerb*                              M_cachedVerb;                                      // 0x260(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_timeSinceLastSpawn;                              // 0x268(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isReadyToSpawn;                                  // 0x26C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23BB[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class AQtnBodyPawn>              BodyPawnClass;                                     // 0x270(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnProjectile>            ProjectileClass;                                   // 0x278(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ProjectileSpeed;                                   // 0x280(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ProjectileInterval;                                // 0x284(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ProjectileLateralOffset;                           // 0x288(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ProjectileCount;                                   // 0x28C(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSpawnInPersistentLevel;                           // 0x290(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23BC[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnProjectileSpawner* GetDefaultObj();

	class AQtnProjectile* SpawnSpecificProjectile(TSubclassOf<class AQtnProjectile> DesiredClassToSpawn, struct FVector& MuzzlePosition, struct FVector& ProjectileVelocity);
	class AQtnProjectile* SpawnProjectile(struct FVector& MuzzlePosition, struct FVector& ProjectileVelocity);
	void PostProjectileSpawned(class AQtnProjectile* SpawnedProjectile);
	void OnQtnReadyForGameplay();
	bool IsReadyToSpawn();
	void HandleSimPause(bool Paused);
	void HandleGameStateReadyForGameplay(class AQtnPlayerController* LocalPlayerController, class AQtnPlayerUI* LocalPlayerUI, class AQtnBodyPawn* LocalOccupiedBodyPawn);
};

// 0x48 (0x560 - 0x518)
// Class QtnGame.QtnProximityBasedReviveComponent
class UQtnProximityBasedReviveComponent : public UStaticMeshComponent
{
public:
	float                                        TracePieAngle;                                     // 0x518(0x4)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23BE[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          OwningBodyPawn;                                    // 0x520(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                       GroundTraceVectors;                                // 0x528(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                        TraceIndex;                                        // 0x538(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                              M_targetPlaneRotation;                             // 0x53C(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                       M_validTraceNormals;                               // 0x548(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                        M_reviveRadius;                                    // 0x558(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23BF[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnProximityBasedReviveComponent* GetDefaultObj();

	bool ShouldDoGroundTrace();
	void SetupGroundTraces();
	void DoGroundTraces(float DeltaTime);
};

// 0x50 (0x80 - 0x30)
// Class QtnGame.QtnRefreshGetCanPlayCallbackProxy
class UQtnRefreshGetCanPlayCallbackProxy : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_            OnComplete;                                        // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UQtnGameInstance*                      M_pGameInstance;                                   // 0x40(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRefreshGetCanPlayCallbackProxyTickFunction M_TickFunction;                                    // 0x48(0x30)(NativeAccessSpecifierPrivate)
	uint8                                        Pad_23C2[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnRefreshGetCanPlayCallbackProxy* GetDefaultObj();

	class UQtnRefreshGetCanPlayCallbackProxy* RefreshGetCanPlay(class UQtnGameInstance* GameInstance);
	void OnCompleteDelegate__DelegateSignature(bool bCanPlay);
};

// 0x0 (0xE0 - 0xE0)
// Class QtnGame.QtnReplicatedSaveDataComponent
class UQtnReplicatedSaveDataComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnReplicatedSaveDataComponent* GetDefaultObj();

	void WaitForReplicationReadiness(class UQtnReplicatedSaveDataComponent* RepSaveData, const struct FLatentActionInfo& LatentInfo, class UQtnReplicatedSaveDataComponent** ReadySaveData);
	bool HasBeenFullyReplicated();
};

// 0x48 (0x70 - 0x28)
// Class QtnGame.QtnRichPresenceManager
class UQtnRichPresenceManager : public UObject
{
public:
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23C5[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  M_lastRichPresenceID;                              // 0x50(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                            RichPresenceDataTable;                             // 0x58(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                   DefaultRichPresence;                               // 0x60(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnRichPresenceManager* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class QtnGame.QtnRunSubProgress
class UQtnRunSubProgress : public UObject
{
public:
	bool                                         M_hasCheckpointHappened;                           // 0x28(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23CE[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UWorld*                                M_pWorld;                                          // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnRunSubProgress* GetDefaultObj();

	void OnRunSubProgressInit_ServerOnly();
	void OnRunProgressReset_ServerOnly();
	void OnRunProgressCheckpoint_ServerOnly(bool FlushMissionProgress);
	void OnPlayerExitWorld_ServerOnly(class AQtnPlayerPawn* PlayerPawn, class AQtnBodyPawn* PlayerBody);
	void OnPlayerEnterWorld_ServerOnly(class AQtnPlayerPawn* PlayerPawn, class AQtnBodyPawn* PlayerBody, bool HasCheckpointHappened);
	void OnMapEndPlay_ServerOnly(bool TravelPending);
	void OnMapBeginPlay_ServerOnly();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnAllExpectedPlayersReady_ServerOnly(int32 NumExpectedPlayers);
	bool HasCheckpointHappened_ServerOnly();
};

// 0x0 (0xA8 - 0xA8)
// Class QtnGame.QtnSaveLoadFSM
class UQtnSaveLoadFSM : public UQtnFSM
{
public:

	static class UClass* StaticClass();
	static class UQtnSaveLoadFSM* GetDefaultObj();

};

// 0x0 (0x38 - 0x38)
// Class QtnGame.QtnSaveLoadIdleState
class UQtnSaveLoadIdleState : public UQtnSaveLoadState
{
public:

	static class UClass* StaticClass();
	static class UQtnSaveLoadIdleState* GetDefaultObj();

};

// 0x58 (0x80 - 0x28)
// Class QtnGame.QtnSaveLoadManager
class UQtnSaveLoadManager : public UObject
{
public:
	bool                                         M_loginDetected;                                   // 0x28(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_haveCloudOptionsBeenLoaded;                      // 0x29(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasProgressBeenLoaded;                           // 0x2A(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_optionsSaveRequested;                            // 0x2B(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_optionsLoadRequested;                            // 0x2C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_progressSaveRequested;                           // 0x2D(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_progressLoadRequested;                           // 0x2E(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23D6[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnSaveLoadFSM*                       M_pSaveLoadFSM;                                    // 0x38(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnSaveLoadIdleState*                 M_pSaveLoadIdleState;                              // 0x40(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnOptionsLoadState*                  M_pOptionsLoadState;                               // 0x48(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnOptionsSaveState*                  M_pOptionsSaveState;                               // 0x50(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnProgressLoadState*                 M_pProgressLoadState;                              // 0x58(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnProgressSaveState*                 M_pProgressSaveState;                              // 0x60(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnLocalOptionsSaveData*              M_pLocalOptionsSaveData;                           // 0x68(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnCloudOptionsSaveData*              M_pCloudOptionsSaveData;                           // 0x70(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQtnProgressSaveData*                  M_pProgressSaveData;                               // 0x78(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSaveLoadManager* GetDefaultObj();

	void SaveProgressDataBP(class AQtnPlayerController* LocalPlayerController);
	void SaveOptionsDataBP(class AQtnPlayerController* LocalPlayerController);
	void ResetProgressDataBP(class AQtnPlayerController* LocalPlayerController);
	void GetSaveLoadDataBP(class AQtnPlayerController* LocalPlayerController, class UQtnLocalOptionsSaveData** LocalOptionsSaveData, class UQtnCloudOptionsSaveData** CloudOptionsSaveData, class UQtnProgressSaveData** ProgressSaveData, enum class EQtnOutputValidityEnum* OutputPin);
	class UQtnDataBag* GetLocalProgressDataBag(class UObject* SelfReference, TSubclassOf<class UQtnDataBag> DatabagArchetype);
};

// 0x1D8 (0x438 - 0x260)
// Class QtnGame.QtnScreenIndicatorWidget
class UQtnScreenIndicatorWidget : public UUserWidget
{
public:
	class UCanvasPanel*                          BaseCanvas;                                        // 0x260(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                          OnScrVerticalBox;                                  // 0x268(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                          OnScr_Distance_Canvas;                             // 0x270(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                            OnScr_Distance_Text;                               // 0x278(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                          OnScr_Texture_Canvas;                              // 0x280(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                OnScrTexture;                                      // 0x288(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                          OffScr_Texture_Canvas;                             // 0x290(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                OffScrTexture;                                     // 0x298(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                          OffScr_Distance_Canvas;                            // 0x2A0(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                            OffScr_Distance_Text;                              // 0x2A8(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnBreadCrumbComponent*               M_pBreadCrumbComponent;                            // 0x2B0(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*              M_pOffScrMat;                                      // 0x2B8(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bStopTryingToGetBreadCrumbComp;                  // 0x2C0(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bBreadcrumbPathConfirmed;                        // 0x2C1(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bIndicatorVisibilityBind;                        // 0x2C2(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23E5[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pTargetActor;                                    // 0x2C8(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bIsTargetSelected;                               // 0x2D0(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23E7[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnIndicatorData                     M_IndicatorData;                                   // 0x2D8(0x130)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector                               M_targetLocation;                                  // 0x408(0xC)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23E8[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPlayerController*                  M_pCachedLocalPlayerController;                    // 0x418(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        M_Degree;                                          // 0x420(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23E9[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_EdgeInterp;                                      // 0x430(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23EA[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnScreenIndicatorWidget* GetDefaultObj();

	void TakeTargetLocation_Cpp();
	class AActor* RefreshTargetActor_Cpp(class AActor* PDesiredTargetActor);
	struct FVector2D OnScreenEdgeClamp_Cpp(struct FVector2D& Position, float Margin);
	void OffScreenPositionAndAngle_Cpp();
	struct FVector2D OffScreenEdgeClamp_Cpp(struct FVector2D& Value);
	void OffScrDistanceText_Cpp(float CurrentAngle);
	struct FVector GetIndicatorLocationfromActor_Cpp(class AActor* PActor);
	float FindClosestEdge_Cpp();
	class AQtnPlayerController* EnsureLocalPlayerController_Cpp();
	void DoSelfRemoval_Cpp();
	void CalculateOffScreenPosition_Cpp(struct FVector2D* OffScreenPosition, float* RenderAngle);
	struct FVector AdjustZOffset_Cpp(struct FVector& InVec);
};

// 0x8 (0x138 - 0x130)
// Class QtnGame.QtnScreenLoading
class UQtnScreenLoading : public UQtnScreen
{
public:
	bool                                         bSeamlessTravelLoading;                            // 0x130(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23EB[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnScreenLoading* GetDefaultObj();

	void OnAnyKeyPressed();
};

// 0x0 (0x130 - 0x130)
// Class QtnGame.QtnScreenMessagingHUD
class UQtnScreenMessagingHUD : public UQtnScreen
{
public:

	static class UClass* StaticClass();
	static class UQtnScreenMessagingHUD* GetDefaultObj();

	void ShowHint(class FText& HintText, float Duration);
	void HideHint();
};

// 0x28 (0x158 - 0x130)
// Class QtnGame.QtnScreenModalDialog
class UQtnScreenModalDialog : public UQtnScreen
{
public:
	TArray<struct FQtnModalMessageInfo>          M_queuedModalMessages;                             // 0x130(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	FDelegateProperty_                           M_pendingFinishDelegate;                           // 0x140(0x10)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	enum class EQtnModalDialogType               M_currentDialogType;                               // 0x150(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isExpectingAnswer;                               // 0x151(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23ED[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnScreenModalDialog* GetDefaultObj();

	void PresentMessageInfo(struct FQtnModalMessageInfo& MessageInfo);
	void HandleRejection();
	void HandleAcceptance();
};

// 0x78 (0x1A8 - 0x130)
// Class QtnGame.QtnScreenNotification
class UQtnScreenNotification : public UQtnScreen
{
public:
	class UUserWidget*                           M_pNotificationWidget;                             // 0x130(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                            M_pTextWidget;                                     // 0x138(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_fadeTimer;                                       // 0x140(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_lineAddTimer;                                    // 0x144(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                M_displayedText;                                   // 0x148(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                M_lastDisplayedText;                               // 0x158(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_introPending;                                    // 0x168(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_zOrder;                                          // 0x16C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_23EF[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UUserWidget>               NotificationWidgetClass;                           // 0x190(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        CharsPerSecond;                                    // 0x198(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FadeDuration;                                      // 0x19C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        TimeBetweenLines;                                  // 0x1A0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        MaxDisplayedLines;                                 // 0x1A4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnScreenNotification* GetDefaultObj();

	void OnOutro();
	void OnIntro();
	class UUserWidget* GetNotificationWidget();
};

// 0x0 (0x130 - 0x130)
// Class QtnGame.QtnScreenPopUpMessage
class UQtnScreenPopUpMessage : public UQtnScreen
{
public:

	static class UClass* StaticClass();
	static class UQtnScreenPopUpMessage* GetDefaultObj();

	void PopUpScreenText(class FText& ScreenText, float PopUpTime, bool IsQueued);
};

// 0x38 (0x2F0 - 0x2B8)
// Class QtnGame.QtnScriptedActorAnimInstance
class UQtnScriptedActorAnimInstance : public UAnimInstance
{
public:
	struct FRotator                              HeadRotation;                                      // 0x2B8(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                        HeadTrackAmount;                                   // 0x2C4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               TargetPosition;                                    // 0x2C8(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHeadTrack;                                        // 0x2D4(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23F1[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        StartIdle;                                         // 0x2D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BackDist;                                          // 0x2DC(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       PitchRange;                                        // 0x2E0(0x8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       YawRange;                                          // 0x2E8(0x8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnScriptedActorAnimInstance* GetDefaultObj();

};

// 0x90 (0x2E0 - 0x250)
// Class QtnGame.QtnScriptedSkeletalActor
class AQtnScriptedSkeletalActor : public AActor
{
public:
	uint8                                        Pad_23FD[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bLocalDamageOnly;                                  // 0x258(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAllowToBeMovementBase;                            // 0x259(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_23FE[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UAnimMontage*>                  DamageReactMontages;                               // 0x260(0x10)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                         bDefaultTicking;                                   // 0x270(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_23FF[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnBodyPawn*>                  TrackedPlayers;                                    // 0x278(0x10)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAnimInstance*                         ThisAnimInst;                                      // 0x288(0x8)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               PrevPosition;                                      // 0x290(0xC)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        HeadTimer;                                         // 0x29C(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        TrackedPlayerIndex;                                // 0x2A0(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  EyeSocketName;                                     // 0x2A4(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        TrackedPositionLerpSpeed;                          // 0x2AC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        TimeMin;                                           // 0x2B0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        TimeMax;                                           // 0x2B4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bShouldHeadTrack;                                  // 0x2B8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bIsHeadTracking;                                   // 0x2B9(0x1)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2400[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_pHeadtrackingInhibitors;                         // 0x2C0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       HeadTrackingPitchRange;                            // 0x2D0(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       HeadTrackingYawRange;                              // 0x2D8(0x8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AQtnScriptedSkeletalActor* GetDefaultObj();

	void SetShouldHeadTrack(bool bNewShouldHeadTrack);
	void SetNextCanPlayTime(TMap<enum class EQtnCuckooEvent, struct FQtnCuckooResponseArray>& CuckooEventResponseMap, enum class EQtnCuckooEvent CuckooEvent, int32 ArrayIndex, float NextCanPlayTime);
	void SetIsHeadTracking(bool bNewIsHeadTracking);
	void RemoveHeadtrackingInhibitor(class UObject* Inhibitor);
	void HeadTrackingToggled(bool On);
	void HandleSimPause(bool Paused);
	bool GetShouldHeadTrack();
	bool GetIsHeadTracking();
	void AddHeadtrackingInhibitor(class UObject* Inhibitor);
	void AddCuckooResponse(TMap<enum class EQtnCuckooEvent, struct FQtnCuckooResponseArray>& CuckooEventResponseMap, enum class EQtnCuckooEvent CuckooEvent, const struct FGameplayTag& ScriptedVOId, class UAnimMontage* Animation, float Cooldown, bool PlayOnceOnly);
};

// 0x58 (0x80 - 0x28)
// Class QtnGame.QtnServerDiagnostics
class UQtnServerDiagnostics : public UObject
{
public:
	class UQtnGameInstance*                      M_pOwningGameInstance;                             // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPlayerState*                       M_pInstigatingPlayerState;                         // 0x30(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2403[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                M_pendingLogFolder;                                // 0x50(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2404[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                M_pendingProfileFolder;                            // 0x70(0x10)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnServerDiagnostics* GetDefaultObj();

};

// 0x0 (0xE0 - 0xE0)
// Class QtnGame.QtnSimPauseResponseComponent
class UQtnSimPauseResponseComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnSimPauseResponseComponent* GetDefaultObj();

	void HandleSimPause(bool Paused);
};

// 0x298 (0x4F0 - 0x258)
// Class QtnGame.QtnSkirmish
class AQtnSkirmish : public ATriggerBox
{
public:
	class UQtnSpokeComponent*                    M_pOwningSpoke;                                    // 0x258(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AQtnBodyPawn*>                  R_playersInsideVolume;                             // 0x260(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UQtnSkirmishTrigger*>           M_skirmishTriggers;                                // 0x270(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FQtnPendingGroupRequest>       M_pendingGroupRequests;                            // 0x280(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AQtnPawn>, struct FQtnTrackedSkirmishPawns> M_trackedSkirmishPawns;                            // 0x290(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FQtnTrackedSkirmishPawns> M_trackedSpawnGroups;                              // 0x2E0(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FName>                          M_spawnGroupHistory;                               // 0x330(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FQtnSkirmishSpawnerInfo>       M_trackedSpawners;                                 // 0x340(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_isEnabled_ServerOnly;                            // 0x350(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         R_preloadArchetypesRequested;                      // 0x351(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         L_preloadArchetypesRequested;                      // 0x352(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2423[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnPawn*>                      R_trackedLivingPawns;                              // 0x358(0x10)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AQtnPawn*>                      R_trackedDeadPawns;                                // 0x368(0x10)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                        M_totalPendingSpawns;                              // 0x378(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_totalTelegraphingPawns;                          // 0x37C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_totalLivingPawns;                                // 0x380(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_totalDeadPawns;                                  // 0x384(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_totalDestroyedPawns;                             // 0x388(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_populationNeedsTabulating;                       // 0x38C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2424[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnSkirmishTrigger*>           M_queuedTriggersToEvaluate;                        // 0x390(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         StartEnabled;                                      // 0x3A0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2426[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnSkirmishPlan                      SkirmishPlan;                                      // 0x3A8(0xB8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       TetherRadii;                                       // 0x460(0x8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                        TetherVerticalRatio;                               // 0x468(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         GrabSpawnersWithinVolume;                          // 0x46C(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2427[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftObjectPtr<class AQtnSpawner>>    Spawners;                                          // 0x470(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SkirmishPlayerEnterEvent_ServerOnly;               // 0x480(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SkirmishPlayerExitEvent_ServerOnly;                // 0x490(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SkirmishSpawnEvent_ServerOnly;                     // 0x4A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SkirmishDeathEvent_ServerOnly;                     // 0x4B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SkirmishSpawnCancelEvent_ServerOnly;               // 0x4C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            TrackedLivingPawnsChange;                          // 0x4D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            TrackedDeadPawnsChange;                            // 0x4E0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnSkirmish* GetDefaultObj();

	void SetSkirmishRequestSpawnCount(struct FQtnSkirmishSpawnRequest& SpawnRequest, const struct FQtnRangedInt& SpawnCount);
	void SetSkirmishEnabled_ServerOnly(bool WantEnabled);
	bool RequestSpawnGroup_ServerOnly(const struct FQtnSkirmishRequestSpawnParams& RequestSpawnParams);
	void QtnSkirmishSpawnCancelEvent__DelegateSignature(class AQtnSkirmish* Skirmish, class FName SpawnGroupName);
	void QtnSkirmishPlayerExitEvent__DelegateSignature(class AQtnSkirmish* ExitedSkirmish, TArray<class AQtnBodyPawn*>& PlayersWithinVolume);
	void QtnSkirmishPlayerEnterEvent__DelegateSignature(class AQtnSkirmish* EnteredSkirmish, TArray<class AQtnBodyPawn*>& PlayersWithinVolume);
	void QtnSkirmishPawnEvent__DelegateSignature(class AQtnSkirmish* Skirmish, class AQtnPawn* SkirmishPawn);
	void QtnSkirmishEvent__DelegateSignature(class AQtnSkirmish* Skirmish);
	void OnRep_TrackedLivingPawns();
	void OnRep_TrackedDeadPawns();
	void OnRep_HasPreloadedArchetypes();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsSkirmishEnabled_ServerOnly();
	void HandlePawnDestroyed_ServerOnly(class AActor* DestroyedActor);
	void HandleOverlapEnd_ServerOnly(class UPrimitiveComponent* POverlappedComponent, class AActor* POtherActor, class UPrimitiveComponent* POtherComp, int32 OtherBodyIndex);
	void HandleOverlapBegin_ServerOnly(class UPrimitiveComponent* POverlappedComponent, class AActor* POtherActor, class UPrimitiveComponent* POtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleBodyAliveChange_ServerOnly(class AQtnBodyPawn* bodyPawn, class AActor* AlivenessInstigator, enum class EQtnBodyAliveness OldBodyAliveness, enum class EQtnBodyAliveness bodyAliveness, bool IsServer);
	struct FLinearColor GetVisualizationColor(class AActor* RelevantActor, bool ForLines);
	TMap<class FName, struct FQtnTrackedSkirmishPawns> GetTrackedSpawnGroups_ServerOnly();
	TMap<TSubclassOf<class AQtnPawn>, struct FQtnTrackedSkirmishPawns> GetTrackedPawns_ServerOnly();
	TArray<class AQtnPawn*> GetTrackedLivingPawns();
	TArray<class AQtnPawn*> GetTrackedDeadPawns();
	void GetTotalPopulationInfo_ServerOnly(int32* NumPending, int32* NumTelegraphing, int32* NumLiving, int32* NumDead, int32* NumDestroyed);
	void GetSpawnGroupInfo_ServerOnly(class FName SpawnGroupName, int32* NumPending, int32* NumTelegraphing, int32* NumLiving, int32* NumDead, int32* NumDestroyed);
	TArray<class FName> GetSpawnGroupHistory_ServerOnly();
	void GetSkirmishRequestSpawnCount(struct FQtnSkirmishSpawnRequest& SpawnRequest, struct FQtnRangedInt* SpawnCount);
	class UQtnSkirmishManager* GetSkirmishManager();
	TArray<class AQtnBodyPawn*> GetPlayersInsideSkirmish();
	class UQtnSpokeComponent* GetOwningSpoke();
	class FString GatherSkirmishInfo();
	void GatherSkirmishActions(TSubclassOf<class UQtnSkirmishAction> ActionType, TArray<class UQtnSkirmishAction*>* GatheredActions);
	void GatherRelevantActors(TArray<class AActor*>* RelevantActors);
	void GatherBPErrors(TArray<class FString>* ErrorMsgs);
	void AcknowledgeSpawnedPawn_ServerOnly(class AQtnPawn* SpawnedPawn, class FName SpawnGroupName, TSubclassOf<class AQtnPawn> ArchetypeBeforeSubstitution);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnSkirmishAction
class UQtnSkirmishAction : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnSkirmishAction* GetDefaultObj();

	void ExecuteSkirmishAction(class AQtnSkirmish* OwningSkirmish, class UQtnSkirmishTrigger* OwningTrigger);
};

// 0x8 (0x30 - 0x28)
// Class QtnGame.QtnSkirmishCondition
class UQtnSkirmishCondition : public UObject
{
public:
	enum class EQtnSkirmishConditionOperator     BooleanPrefix;                                     // 0x28(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         NOT;                                               // 0x29(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2430[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnSkirmishCondition* GetDefaultObj();

	bool IsSkirmishConditionSatisfied(class AQtnSkirmish* OwningSkirmish, class UQtnSkirmishTrigger* OwningTrigger);
};

// 0xE8 (0x110 - 0x28)
// Class QtnGame.QtnSkirmishManager
class UQtnSkirmishManager : public UObject
{
public:
	uint8                                        Pad_2435[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnSkirmish*>                  R_registeredSkirmishes;                            // 0x30(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                        M_enemySpawnedCntInCurFrame;                       // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        GlobalAIPopulationCap;                             // 0x44(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AQtnSpawner>>       ExcludedSpawners;                                  // 0x48(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FQtnSkirmishPlan                      DefaultPlan;                                       // 0x58(0xB8)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSkirmishManager* GetDefaultObj();

	void OnSkirmishSpawn_ServerOnly(class AQtnSkirmish* Skirmish, class AQtnPawn* SpawnedPawn, class FName SpawnGroupName, TSubclassOf<class AQtnPawn> ArchetypeBeforeSubstitution);
	void OnSkirmishManagerDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void HandleSkirmishSpawn(class AQtnSkirmish* Skirmish, class AQtnPawn* SkirmishPawn);
	void HandleReadyForGameplay(bool IsServer);
	class UQtnSkirmishManager* GetSkirmishManager(class UObject* WorldContextObject);
	TSubclassOf<class AQtnPawn> ApplyPawnSubstitution_ServerOnly(TSubclassOf<class AQtnPawn> PawnArchetype);
};

// 0x0 (0xE0 - 0xE0)
// Class QtnGame.QtnSkirmishProxyComponent
class UQtnSkirmishProxyComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UQtnSkirmishProxyComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnSkirmishSpawnerHeuristic
class UQtnSkirmishSpawnerHeuristic : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnSkirmishSpawnerHeuristic* GetDefaultObj();

	float CalculateHeuristicScore(class AQtnSkirmish* OwningSkirmish, class AQtnSpawner* Spawner, struct FVector& PlayerCentroid, class FName& SpawnWaveName);
};

// 0x20 (0x48 - 0x28)
// Class QtnGame.QtnSkirmishTrigger
class UQtnSkirmishTrigger : public UObject
{
public:
	class AQtnSkirmish*                          M_pOwningSkirmish;                                 // 0x28(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FQtnSkirmishResponse>          M_responsesToEvaluate;                             // 0x30(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                        M_evaluationDepth;                                 // 0x40(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_243B[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnSkirmishTrigger* GetDefaultObj();

	void OnSkirmishInit(class AQtnSkirmish* OwningSkirmish);
	class AQtnSkirmish* GetOwningSkirmish();
	void EvaluateTriggerResponses(bool DeferEvaluationToNextTick);
};

// 0x18 (0x60 - 0x48)
// Class QtnGame.QtnSoundNodeSwitchName
class UQtnSoundNodeSwitchName : public USoundNode
{
public:
	class FName                                  NameParameterName;                                 // 0x48(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                          SwitchNames;                                       // 0x50(0x10)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSoundNodeSwitchName* GetDefaultObj();

};

// 0x18 (0x60 - 0x48)
// Class QtnGame.QtnSoundNodeVOVariantSwitch
class UQtnSoundNodeVOVariantSwitch : public USoundNode
{
public:
	TArray<float>                                Weights;                                           // 0x48(0x10)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_243F[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnSoundNodeVOVariantSwitch* GetDefaultObj();

};

// 0x38 (0xA0 - 0x68)
// Class QtnGame.QtnSourceEffectPitchShiftPreset
class UQtnSourceEffectPitchShiftPreset : public USoundEffectSourcePreset
{
public:
	uint8                                        Pad_2444[0x30];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnSourceEffectPitchShiftSettings    Settings;                                          // 0x98(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSourceEffectPitchShiftPreset* GetDefaultObj();

	void SetSettings(struct FQtnSourceEffectPitchShiftSettings& InSettings);
};

// 0x28 (0x108 - 0xE0)
// Class QtnGame.QtnSpawnedActorComponent
class UQtnSpawnedActorComponent : public UActorComponent
{
public:
	class AQtnSpawner*                           R_pOwningSpawner;                                  // 0xE0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasTriggeredSpawnEvents;                         // 0xE8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2449[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_spawnPresentationCountdown;                      // 0xEC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnSkirmish*                          M_pOwningSkirmish_ServerOnly;                      // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  M_skirmishSpawnGroupName_ServerOnly;               // 0xF8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnPawn>                  M_archetypeBeforeSubstitution_ServerOnly;          // 0x100(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSpawnedActorComponent* GetDefaultObj();

	void OnRep_OwningSpawner();
};

// 0x118 (0x368 - 0x250)
// Class QtnGame.QtnSpawner
class AQtnSpawner : public AActor
{
public:
	class AQtnGameState*                         M_pCachedGameState;                                // 0x250(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_queuedSpawnCount;                                // 0x258(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2464[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AActor*>                        M_activeSpawnedActors;                             // 0x260(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                         M_designerWantsThisToAlwaysTick;                   // 0x270(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2465[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_idleTickInterval;                                // 0x274(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_timeToNextSpawn;                                 // 0x278(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isReadyToSpawn;                                  // 0x27C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2466[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnPendingSkirmishGroup>      M_pendingSkirmishGroups;                           // 0x280(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnPendingSkirmishGroup              M_skirmishGroupInProgress;                         // 0x290(0x38)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                    ClassToSpawn;                                      // 0x2C8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        NumToSpawnUponStart;                               // 0x2D0(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               RandomPositionOffset;                              // 0x2D4(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                              RandomRotationOffset;                              // 0x2E0(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_2467[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class FName>                          ActorTagsToAddUponSpawn;                           // 0x2F0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         bSpawnInPersistentLevel;                           // 0x300(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_246A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FGameplayTag>                  GameplayTags;                                      // 0x308(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                  SpawnerRegion;                                     // 0x318(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AQtnPatrolRoute>        TetheredPatrolRoute;                               // 0x320(0x28)(Edit, BlueprintVisible, ExportObject, DisableEditOnTemplate, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IgnoreAILOD;                                       // 0x348(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         StartAsHiddenActor;                                // 0x349(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SnapFeetToSpawnTransform;                          // 0x34A(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_246B[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       DelayBetweenSpawns;                                // 0x34C(0x8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_246D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            QtnSpawnerSpawnedEvent;                            // 0x358(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnSpawner* GetDefaultObj();

	class AActor* SpawnWithTag(class FName ActorTag);
	class AActor* SpawnSpecificActor_Server(TSubclassOf<class AActor> DesiredClassToSpawn);
	void SkirmishGroupTelegraphStart_ServerOnly(class AQtnSkirmish* SpawningSkirmish, struct FQtnSkirmishRequestSpawnParams& SkirmishRequestSpawnParams);
	void SkirmishGroupTelegraphEnd_ServerOnly();
	void QueueSpawns(int32 NumSpawnsToQueue);
	void OnQtnSpawnerSpawned(class AActor* SpawnedActor);
	void OnQtnReadyForGameplay();
	void HandleSimPause(bool Paused);
	void HandleGameStateReadyForGameplay(class AQtnPlayerController* LocalPlayerController, class AQtnPlayerUI* LocalPlayerUI, class AQtnBodyPawn* LocalOccupiedBodyPawn);
	class USceneComponent* GetSpawnTransformComponent(TSubclassOf<class AActor> DesiredClassToSpawn);
	class FName GetSpawnerRegion();
	class AQtnSpawner* GetOwningSpawner(class AActor* Actor);
	class AActor* GetLastActiveSpawnedActor(class FName ActorTagFilter);
	struct FQtnSkirmishRequestSpawnParams GetCurrentSkirmishRequestSpawnParams_ServerOnly();
	TArray<class AActor*> GetActiveSpawnedActorsByFilter(class FName ActorTagFilter);
	TArray<class AActor*> GetActiveSpawnedActors();
};

// 0x18 (0xF8 - 0xE0)
// Class QtnGame.QtnSpokeComponent
class UQtnSpokeComponent : public UActorComponent
{
public:
	bool                                         AutoGatherDuringErrorChecks;                       // 0xE0(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2474[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftObjectPtr<class AQtnSkirmish>>   RegisteredSkirmishes;                              // 0xE8(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSpokeComponent* GetDefaultObj();

	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	struct FLinearColor GetVisualizationColor(class AActor* RelevantActor, bool ForLines);
	void GatherRelevantActors(TArray<class AActor*>* RelevantActors);
	void GatherErrors(TArray<class FString>* ErrorMsgs);
	class FString BuildTextForLabel();
};

// 0x10 (0xF0 - 0xE0)
// Class QtnGame.QtnSpokeManager
class UQtnSpokeManager : public UActorComponent
{
public:
	TArray<class UQtnSpokeComponent*>            M_registeredSpokes;                                // 0xE0(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnSpokeManager* GetDefaultObj();

	void OnSpokeManagerDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	class UQtnSpokeManager* GetSpokeManager(class UObject* WorldContextObject);
	TArray<class UQtnSpokeComponent*> GetRegisteredSpokes();
};

// 0xC8 (0xF0 - 0x28)
// Class QtnGame.QtnStatusEffect
class UQtnStatusEffect : public UObject
{
public:
	uint8                                        Pad_2490[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_remainingTime;                                   // 0x34(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_passiveEscapeAccumulator;                        // 0x38(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_expirationDuration;                              // 0x3C(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        R_refreshCount;                                    // 0x40(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnUIBodyActionEnum              M_lastMashedButton;                                // 0x44(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2492[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnFXActor*                           M_pFXInstance;                                     // 0x48(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pOwningActor;                                    // 0x50(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPawn*                              R_pStatusInstigator;                               // 0x58(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnDamageReceptorComponent*           R_pOwningDamageReceptorComponent;                  // 0x60(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnDamageReceptorComponent*           L_pOwningDamageReceptorComponent;                  // 0x68(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x70(0x28)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         RequestHealthBarVisibilityWhileActive;             // 0x98(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AutoExpires;                                       // 0x99(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2493[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AutoExpirationDuration;                            // 0x9C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ExpireUponDeath;                                   // 0xA0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ExpireDuringCutsceneCleanup;                       // 0xA1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2494[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SecondsPerButtonMash;                              // 0xA4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ButtonMashDrainMultiplier;                         // 0xA8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2496[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  FriendlyName;                                      // 0xB0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0xC8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class AQtnFXActor>               StatusFX;                                          // 0xE0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         PlaceStatusFXAtInstigator;                         // 0xE8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2497[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnStatusEffect* GetDefaultObj();

	void SetExpirationTime_ServerOnly(float DesiredDuration);
	void ServerInduceExpiration();
	void RefreshStatusEffect_ServerOnly();
	void OnStatusEffectTick(float DeltaSeconds);
	void OnStatusEffectRefresh(class AActor* AffectedActor, bool IsServer);
	void OnStatusEffectInit_ServerOnly(class AActor* AffectedActor, class AQtnPawn* Instigator);
	void OnStatusEffectEnd(class AActor* AffectedActor, class AQtnPawn* Instigator, bool IsActorBeingDestroyed);
	void OnStatusEffectBegin(class AActor* AffectedActor, class AQtnPawn* Instigator);
	void OnRep_RefreshCount();
	void OnRep_OwningDamageReceptorComponent();
	void OnRep_ExpirationDuration();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsServer();
	void InduceStatusExpiration_ServerOnly();
	class AQtnPawn* GetStatusInstigator();
	class UQtnStatusEffect* GetStatusEffectArchetype(TSubclassOf<class UQtnStatusEffect> StatusEffectClass);
	float GetRemainingTime();
	class UQtnDamageReceptorComponent* GetOwningDamageReceptorComponent();
	class UTexture2D* GetIconForUI();
	float GetExpirationTime();
	float GetCompletionRatio();
	class AQtnBodyPawn* GetAffectedBody();
	class AActor* GetAffectedActor();
	void DecrementRemainingTime(float Amount);
};

// 0x48 (0x138 - 0xF0)
// Class QtnGame.QtnStatusAllyProximity
class UQtnStatusAllyProximity : public UQtnStatusEffect
{
public:
	class AQtnBodyPawn*                          M_pOwningBody;                                     // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnFriendshipComponent*               M_pFriendshipComponent;                            // 0xF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_smoothedDraftingSpeedMultiplier;                 // 0x100(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_friendshipStrength;                              // 0x104(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_smoothedDraftingStrength;                        // 0x108(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_topStaminaRatioAmongstFriends;                   // 0x10C(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_selfStaminaRatio;                                // 0x110(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       StaminaRegenMultiplier;                            // 0x114(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       StaminaRegenDelayMultiplier;                       // 0x11C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SprintDrainRatio;                                  // 0x124(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       DraftingSpeedMultiplier;                           // 0x12C(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2498[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnStatusAllyProximity* GetDefaultObj();

};

// 0x150 (0x178 - 0x28)
// Class QtnGame.QtnStealthSettings
class UQtnStealthSettings : public UObject
{
public:
	TMap<enum class EQtnNoiseEnum, struct FQtnNoiseConfig> NoiseConfigMap;                                    // 0x28(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                         AINoiseAffectedBySurface;                          // 0x78(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2499[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SurfaceAINoiseMultiplier[0x3F];                    // 0x7C(0xFC)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnStealthSettings* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnStructs
class UQtnStructs : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnStructs* GetDefaultObj();

	class FString ToStringInt(struct FQtnRangedInt& RangedInt);
	class FString ToString(struct FQtnRangedFloat& RangedFloat);
	float GetScaledValue(struct FQtnRangedFloat& RangedFloat, float Ratio);
	float GetRatio(struct FQtnRangedFloat& RangedFloat, float ScaledValue);
	float GetRandomValue(struct FQtnRangedFloat& RangedFloat);
	int32 GetRandomInt(struct FQtnRangedInt& RangedInt);
	float GetClampedValue(struct FQtnRangedFloat& RangedFloat, float RawValue);
	int32 GetClampedInt(struct FQtnRangedInt& RangedInt, int32 RawInt);
};

// 0x1B8 (0x3E0 - 0x228)
// Class QtnGame.QtnSynchComponent
class UQtnSynchComponent : public USceneComponent
{
public:
	uint8                                        Pad_24A0[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USkeletalMeshComponent*                M_pSynchSkeletalMeshComponent;                     // 0x230(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                  M_pSynchStaticMeshComponent;                       // 0x238(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshSocket*>           M_interactionSkeletalMeshSockets;                  // 0x240(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshSocket*>             M_interactionStaticMeshSockets;                    // 0x250(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>               M_interactionSceneComponents;                      // 0x260(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshSocket*>           M_exitSkeletalMeshSockets;                         // 0x270(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshSocket*>             M_exitStaticMeshSockets;                           // 0x280(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>               M_exitSceneComponents;                             // 0x290(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshSocket*>           M_cameraSkeletalMeshSockets;                       // 0x2A0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshSocket*>             M_cameraStaticMeshSockets;                         // 0x2B0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>               M_cameraSceneComponents;                           // 0x2C0(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class USkeletalMeshSocket*                   M_pLookFocusSkeletalMeshSocket;                    // 0x2D0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshSocket*                     M_pLookFocusStaticMeshSocket;                      // 0x2D8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                       M_pLookFocusSceneComponent;                        // 0x2E0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasSynchInfoBeenEnsured;                         // 0x2E8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_24A4[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSoftObjectPtr<class UTexture2D>             ReticleTexture;                                    // 0x2F0(0x28)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  PawnSyncSocketName;                                // 0x318(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                          InteractionSocketNames;                            // 0x320(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        InteractionSocketActorOverrides;                   // 0x330(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                         SnapInteractionToGround;                           // 0x340(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         InduceEmptyHands;                                  // 0x341(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_24A5[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AActor*>                        ActorsToIgnoreDuringInteraction;                   // 0x348(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FName>                          ExitSocketNames;                                   // 0x358(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        ExitSocketActorOverrides;                          // 0x368(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                         SnapExitToGround;                                  // 0x378(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SlideFromStartLocationAfterExit;                   // 0x379(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_24A6[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class FName>                          CameraSocketNames;                                 // 0x380(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        CameraSocketActorOverrides;                        // 0x390(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                  LookFocusSocketName;                               // 0x3A0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                LookFocusSocketActorOverride;                      // 0x3A8(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                             LookLimit;                                         // 0x3B0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CameraAlphaInTime;                                 // 0x3B8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CameraAlphaOutTime;                                // 0x3BC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InterpSpeed;                                       // 0x3C0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UsesFullBodyFrob;                                  // 0x3C4(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_24A8[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnCameraBehavior>        CameraBehaviorDuringUse;                           // 0x3C8(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x3D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnSynchComponent* GetDefaultObj();

	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
};

// 0x90 (0x170 - 0xE0)
// Class QtnGame.QtnTagDescriptionComponent
class UQtnTagDescriptionComponent : public UActorComponent
{
public:
	uint8                                        Pad_24C2[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnTermLocalization*                  LocalizationComponent;                             // 0xE8(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FQtnTagPresence>               DefaultTagDescriptors;                             // 0xF0(0x10)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQtnTagPresence>               R_TagDescriptors;                                  // 0x100(0x10)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                 GameplayTagsContainer;                             // 0x110(0x20)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                         M_HasTagDescriptorsPopulated;                      // 0x130(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_24C5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTag                          M_RarityTag;                                       // 0x134(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_ItemTypeTag;                                     // 0x13C(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_WeaponTypeTag;                                   // 0x144(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_CurrencyTypeTag;                                 // 0x14C(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_ConsumableTypeTag;                               // 0x154(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_24C6[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnTagsChangedEvent;                                // 0x160(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnTagDescriptionComponent* GetDefaultObj();

	bool TagIsChildOfParent(struct FGameplayTag& ChildToCheck, struct FGameplayTag& ParentToCheck);
	void RestoreTagsFromPackedList_ServerOnly(TArray<class FString>& PackedList);
	bool RemoveGameplayTag_ServerOnly(struct FGameplayTag& TagToRemove);
	TMap<int32, float> ProcessTagReactions(TArray<struct FQtnTagReactiveWeighting>& ReactionsToTags, int32 LevelOfCaller);
	void OnRep_TagDescriptors();
	TArray<class FString> MakePackedTagList();
	struct FGameplayTag GetWeaponTypeAsGameplayTag();
	TArray<struct FQtnTagPresence> GetTagDescriptors();
	struct FLinearColor GetRarityColor();
	struct FGameplayTag GetRarityAsGameplayTag();
	struct FGameplayTag GetItemTypeAsGameplayTag(bool* FoundItemType);
	struct FGameplayTag GetCurrencyTypeAsGameplayTag();
	struct FGameplayTag GetConsumableTypeAsGameplayTag();
	class FString GenerateTagListDescription();
	struct FGameplayTag FindTagInTagDescriptors(struct FGameplayTag& ParentTagToFind);
	struct FQtnIndexedTag FindIndexedTag(struct FGameplayTag& TagToFind);
	void AddGameplayTag_ServerOnly(struct FGameplayTag& TagToAdd, float TagPresence);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnTargetableInterface
class IQtnTargetableInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnTargetableInterface* GetDefaultObj();

	bool CanBeInteractedWith(enum class EQtnTargetInteractionEnum TargetInteraction, class AQtnPawn* InteractingPawn, class FText* AffordancePrompt);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnTeamAttitudeUtils
class UQtnTeamAttitudeUtils : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQtnTeamAttitudeUtils* GetDefaultObj();

	bool HasAttitudeSet(enum class EQtnTeamAttitudeFlags AttitudeFlags, enum class EQtnTeamAttitude Attitude);
	enum class EQtnTeamAttitudeFlags Conv_AttitudeToFlags(enum class EQtnTeamAttitude Attitude);
};

// 0xA8 (0xD0 - 0x28)
// Class QtnGame.QtnTeam
class UQtnTeam : public UObject
{
public:
	uint8                                        Pad_24CF[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnTeamManagerComponent*              M_pOwningTeamManager;                              // 0x30(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnTeam>>          DefaultAllyTeams;                                  // 0x38(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnTeam>>          DefaultEnemyTeams;                                 // 0x48(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnTeam>>          R_knownEnemyTeams;                                 // 0x58(0x10)(Net, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UQtnTeam>>          R_knownAllyTeams;                                  // 0x68(0x10)(Net, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x78(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                  FriendlyName;                                      // 0xA0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0xB8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnTeam* GetDefaultObj();

	class UTexture2D* GetIconForUI();
};

// 0x58 (0x138 - 0xE0)
// Class QtnGame.QtnTeamManagerComponent
class UQtnTeamManagerComponent : public UActorComponent
{
public:
	class AQtnGameState*                         M_pOwningGameState;                                // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UQtnTeam>, class UQtnTeam*> M_registeredTeams_ServerOnly;                      // 0xE8(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnTeamManagerComponent* GetDefaultObj();

	void SetTeamAttitudes_ServerOnly(TSubclassOf<class UQtnTeam> TeamClassA, TSubclassOf<class UQtnTeam> TeamClassB, enum class EQtnTeamAttitude TeamAttitude);
};

// 0x240 (0x268 - 0x28)
// Class QtnGame.QtnTermLocalization
class UQtnTermLocalization : public UObject
{
public:
	class UQtnGameInstance*                      M_pGameInstance;                                   // 0x28(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_RarityTag;                                       // 0x30(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_WeaponTypeTag;                                   // 0x38(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          M_ItemTypeTag;                                     // 0x40(0x8)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                TagErrorCode;                                      // 0x48(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                TagLexicon;                                        // 0x58(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                RPGTermLexicon;                                    // 0x68(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                  TagStringTableReference;                           // 0x78(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                  RPGTermStringTableReference;                       // 0x90(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FGameplayTag>     StringCodeToGameplayTagMap;                        // 0xA8(0x50)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FLinearColor> RarityGameplayTagToColorMap;                       // 0xF8(0x50)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FString>           RPGTermNegationTable;                              // 0x148(0x50)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class FString>     GameplayTagToStringCodeMap;                        // 0x198(0x50)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                            ItemNamingSchemeDataTable;                         // 0x1E8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<enum class EQtnStatNameLocationOnItem> OrderedStatNameLocationDesirability;               // 0x1F0(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<enum class EQtnStatNameLocationOnItem> OrderedStatNameLocationApplication;                // 0x200(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<enum class EQtnStatNameLocationOnItem, class FText> StatNameLocationApplicationRulesMap;               // 0x210(0x50)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                        MaximumNumberOfStatsUsedInName;                    // 0x260(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_24EF[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnTermLocalization* GetDefaultObj();

	void InitializeTermLocalization();
	struct FGameplayTag GetWeaponSubtypeGameplayTagFromStringCodes(TArray<class FString>& TagsToFind, bool* TagFound);
	struct FGameplayTag GetWeaponSubtypeGameplayTagFromStringCode(class FString& TagToFind, bool* TagFound);
	class FString GetStringCodeFromGameplayTagEnum(struct FGameplayTag& TagToFind, bool* TagFound);
	struct FGameplayTag GetRarityGameplayTagFromStringCodes(TArray<class FString>& TagsToFind, bool* TagFound);
	struct FGameplayTag GetRarityGameplayTagFromStringCode(class FString& TagToFind, bool* TagFound);
	class FText GetLocalizedTextFromTagCode(class FString& TagCodeToUse, bool* TagFound, bool PrintDebug);
	class FText GetLocalizedTextFromTable(class FString& NamespaceDB, class FString& TextIdentity, bool* ValidResult, bool PrintDebug);
	class FText GetLocalizedTextFromRPGTerm(class FString& RPGTerm, bool* TagFound, bool PrintDebug);
	class FText GetLocalizedTextFromGameplayTag(struct FGameplayTag& TagToUse, bool* TagFound, bool PrintDebug);
	struct FGameplayTag GetItemTypeGameplayTagFromStringCodes(TArray<class FString>& TagsToFind, bool* TagFound);
	struct FGameplayTag GetItemTypeGameplayTagFromStringCode(class FString& TagToFind, bool* TagFound);
	struct FGameplayTag GetGameplayTagFromStringCode(class FString& TagToFind, bool* TagFound);
	struct FLinearColor GetColorFromRarityGameplayTag(struct FGameplayTag& TagToFind, bool* TagFound, bool PrintDebug);
	class FText GenerateNameTextFromItemData(struct FQtnItemData& ItemToName);
	class FText GenerateDescriptionFromStatDelta(class FString& DerivedStatKey, float DeltaValue);
	class FString CheckForTermNegation(class FString& TermToCheck, float ValueOfTerm, bool AllowNegation);
};

// 0x10 (0x4E0 - 0x4D0)
// Class QtnGame.QtnTextRenderComponent
class UQtnTextRenderComponent : public UTextRenderComponent
{
public:
	uint8                                        Pad_24F2[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         GenerateShadowText;                                // 0x4D4(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_24F3[0xB];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnTextRenderComponent* GetDefaultObj();

};

// 0xB0 (0x180 - 0xD0)
// Class QtnGame.QtnThresholdAttribute
class UQtnThresholdAttribute : public UQtnAttribute
{
public:
	class AQtnPawn*                              M_pCulprit;                                        // 0xD0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        R_MaximumAttributeValue;                           // 0xD8(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         R_hasEverReachedThreshold;                         // 0xDC(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         L_hasEverReachedThreshold;                         // 0xDD(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         StartsAtMaximumThreshold;                          // 0xDE(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         RemoveAttributeOnDeath;                            // 0xDF(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         UseThresholdForStatusEffectApplication;            // 0xE0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         UseMaximumHealthAsThreshold;                       // 0xE1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         SkipMaxThresholdCalculation;                       // 0xE2(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2501[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        ThresholdAsFractionOfTotalHealth;                  // 0xE4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         DecreaseOnTick;                                    // 0xE8(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2502[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AttributeDrainPerSecond;                           // 0xEC(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MaxAttributeThreshold;                             // 0xF0(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2503[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnAttribute>             HealthAttribute;                                   // 0xF8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnAttribute>             MaxHealthAttribute;                                // 0x100(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnStatusEffect>          StatusEffectToApply;                               // 0x108(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnThresholdVisuals                  AttributeVisuals;                                  // 0x110(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnValueDepletedEvent;                              // 0x160(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnValueMetThresholdEvent;                          // 0x170(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnThresholdAttribute* GetDefaultObj();

	float UpdateStatusEffectCausingThreshold_ServerOnly();
	void SetSpecificCulprit(class AQtnPawn* Culprit);
	void OnStatusEffectAddedEvent(class UQtnStatusEffect* StatusEffect);
	void OnRep_HasEverReachedThreshold();
	void OnAffectedBodyAlivenessChangeEvent(class AQtnBodyPawn* bodyPawn, class AActor* AlivenessInstigator, enum class EQtnBodyAliveness OldBodyAliveness, enum class EQtnBodyAliveness bodyAliveness, bool IsServer);
	bool HasReachedThreshold();
	bool HasEverReachedThreshold();
	float GetThresholdValue();
	class AQtnPawn* GetCulprit();
};

// 0x150 (0x238 - 0xE8)
// Class QtnGame.QtnThrowableComponent
class UQtnThrowableComponent : public UQtnItemComponent
{
public:
	class AQtnPawn*                              R_pPerpetrator;                                    // 0xE8(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_collisionSoundCooldown;                          // 0xF0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_launchSpeed;                                     // 0xF4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_desiredLaunchVelocity;                           // 0xF8(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isDirectHit;                                     // 0x104(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_IsFractured;                                     // 0x105(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_250B[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_FractureForceReceived;                           // 0x108(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_shouldPlayCollisionSound_Authority;              // 0x10C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_250C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UParticleSystemComponent*              M_AimingArcPSC;                                    // 0x110(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_hasAimingArcHitResult;                           // 0x118(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_250D[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FHitResult                            M_aimingArcHitResult;                              // 0x11C(0x88)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	enum class EQtnProjectileState               R_projectileState;                                 // 0x1A4(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_250E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USoundBase*                            CollisionSoundAsset;                               // 0x1A8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EQtnNoiseEnum                     NoiseType;                                         // 0x1B0(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_250F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnNoiseConfig                       CustomNoiseConfig;                                 // 0x1B4(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2510[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnDamageType>            DeliveredDamageType;                               // 0x1C8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxDamage;                                         // 0x1D0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxWounding;                                       // 0x1D4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        DirectHitImpulse;                                  // 0x1D8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       SpeedToDamageScale;                                // 0x1DC(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       PitchToSpeedScale;                                 // 0x1E4(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                        FractureResilience;                                // 0x1EC(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FractureToughness;                                 // 0x1F0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        FractureBreakingForce;                             // 0x1F4(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AQtnFXActor>               FractureFX;                                        // 0x1F8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AQtnFXActor>               BreakingFX;                                        // 0x200(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AQtnFXActor>               AimingArcFXClass;                                  // 0x208(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        AimingArcSimStepDeltaTime;                         // 0x210(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        AimingArcSimMaxSteps;                              // 0x214(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        AimingArcCapsuleRadius;                            // 0x218(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        AimingArcCapsuleHalfHeight;                        // 0x21C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MaxThrowDistance;                                  // 0x220(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2514[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnProjectileHit;                                   // 0x228(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnThrowableComponent* GetDefaultObj();

	void ServerDoLaunch(class AQtnPawn* POwningPawn, int32 StackCount, const struct FQtnViewPoint& ClientPawnViewPoint);
	void OnRep_ProjectileState();
	void OnPhysicsSleep_Authority(class UPrimitiveComponent* PSleepingComponent, class FName BoneName);
	void OnHit_Authority(class UPrimitiveComponent* PHitComp, class AActor* POtherActor, class UPrimitiveComponent* POtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void MulticastPlayFractureFX();
	void MulticastPlayBreakingFX();
	void MulticastOnDirectHit(class AQtnPawn* PPerpetrator, class AActor* POtherActor, const struct FHitResult& Hit);
	void GetAimingArcEndpoint(class UObject* SelfReference, struct FHitResult* OutHitResult, enum class EQtnOutputValidityEnum* OutputPin);
};

// 0x390 (0x400 - 0x70)
// Class QtnGame.RoundRobinComponentAggregation
class URoundRobinComponentAggregation : public UComponentAggregation
{
public:
	uint8                                        Pad_2517[0x340];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class UActorComponent*, int32>          ComponentLastTurnCache;                            // 0x3B0(0x50)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class URoundRobinComponentAggregation* GetDefaultObj();

};

// 0x340 (0x3B0 - 0x70)
// Class QtnGame.RoundRobinActorAggregation
class URoundRobinActorAggregation : public UActorAggregation
{
public:
	uint8                                        Pad_2518[0x340];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URoundRobinActorAggregation* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnTicketHolderInterface
class IQtnTicketHolderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnTicketHolderInterface* GetDefaultObj();

	void OnTicketLost(TSubclassOf<class UQtnTicketType> TicketType);
};

// 0xA0 (0xC8 - 0x28)
// Class QtnGame.QtnTicketManager
class UQtnTicketManager : public UObject
{
public:
	uint8                                        Pad_251D[0xA0];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnTicketManager* GetDefaultObj();

	void SetTicketOwnerReturnCooldown_ServerOnly(TSubclassOf<class UQtnTicketType> TicketType, class AQtnPawn* TicketOwner, struct FQtnRangedFloat& NewCooldown);
	void SetTicketOwnerHandoutCooldown_ServerOnly(TSubclassOf<class UQtnTicketType> TicketType, class AQtnPawn* TicketOwner, struct FQtnRangedFloat& NewCooldown);
};

// 0x28 (0x50 - 0x28)
// Class QtnGame.QtnTicketType
class UQtnTicketType : public UObject
{
public:
	struct FQtnRangedFloat                       HandoutCooldown;                                   // 0x28(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         M_handoutCooldownMultiticket;                      // 0x30(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_251E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       ReturnCooldown;                                    // 0x34(0x8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        DifficultyCooldownMultiplier[0x4];                 // 0x3C(0x10)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsGlobal;                                          // 0x4C(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_251F[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnTicketType* GetDefaultObj();

};

// 0x50 (0xB20 - 0xAD0)
// Class QtnGame.QtnTurretPawn
class AQtnTurretPawn : public AQtnPawn
{
public:
	uint8                                        Pad_2523[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnTurretController*                  M_pTurretController;                               // 0xAD8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          M_pCommandingBody;                                 // 0xAE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          M_pInstigatorBody;                                 // 0xAE8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPawn*                              R_pMostRelevantEnemy;                              // 0xAF0(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnPlayerPawn*                        M_pHijackingPlayerPawn;                            // 0xAF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnScreen>                TurretHUD;                                         // 0xB00(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bDisableCharacterMovementTick;                   // 0xB08(0x1)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2524[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            RelevantEnemyChangeEvent;                          // 0xB10(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnTurretPawn* GetDefaultObj();

	void QtnRelevantEnemyChangeEvent__DelegateSignature(class AQtnPawn* MostRelevantEnemy);
	void OnRep_MostRelevantEnemy();
	bool IsHijacked();
	class AQtnTurretController* GetTurretController();
	class AQtnPawn* GetMostRelevantEnemy();
	TSubclassOf<class UQtnScreen> GetHijackedHUDArchetype();
	struct FRotator GetEnemyAimRotation();
};

// 0x20 (0xB40 - 0xB20)
// Class QtnGame.QtnTurretBossPawn
class AQtnTurretBossPawn : public AQtnTurretPawn
{
public:
	enum class EQtnTurretBossState               R_CurrentBossState;                                // 0xB20(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnTurretBossState               L_CurrentBossState;                                // 0xB21(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2526[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVerb*                              R_CurrentActiveVerb;                               // 0xB28(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnVerb*                              L_CurrentActiveVerb;                               // 0xB30(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        Internal_ActionRecoveryTime;                       // 0xB38(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_bHasReplicatedBodyState;                         // 0xB3C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2527[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQtnTurretBossPawn* GetDefaultObj();

	void SetCurrentVerb_ServerOnly(TSubclassOf<class UQtnVerb> NextVerbClass);
	void SetCurrentBodyState_ServerOnly(enum class EQtnTurretBossState NewState);
	void OnRep_CurrentVerb();
	void OnRep_CurrentBossState();
	void OnCurrentBodyStateChangedEvent(enum class EQtnTurretBossState NewState, enum class EQtnTurretBossState PreviousState);
};

// 0x28 (0x378 - 0x350)
// Class QtnGame.QtnTurretController
class AQtnTurretController : public AAIController
{
public:
	float                                        M_aiLODCountdown;                                  // 0x350(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2529[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnPawn*                              M_pMostRelevantEnemy;                              // 0x358(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQtnTurretPerceptionComponent*         M_pPerceptionComponent;                            // 0x360(0x8)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnTurretPawn*                        M_pPossessedTurret;                                // 0x368(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnTurretAILOD                   M_aiLOD;                                           // 0x370(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_252A[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        VisionRange;                                       // 0x374(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnTurretController* GetDefaultObj();

	class AQtnPawn* GetMostRelevantEnemy();
};

// 0x18 (0x1D8 - 0x1C0)
// Class QtnGame.QtnTurretPerceptionComponent
class UQtnTurretPerceptionComponent : public UAIPerceptionComponent
{
public:
	class AQtnTurretController*                  M_pOwningController;                               // 0x1C0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AQtnPawn*>                      M_trackedEnemies;                                  // 0x1C8(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnTurretPerceptionComponent* GetDefaultObj();

	void HandleTargetPerceptionUpdated(class AActor* PActor, const struct FAIStimulus& Stimulus);
};

// 0x90 (0xB8 - 0x28)
// Class QtnGame.QtnTutorial
class UQtnTutorial : public UObject
{
public:
	struct FGameplayTag                          TutorialIdentity;                                  // 0x28(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnTutorialType                  TutorialType;                                      // 0x30(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2541[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnScreen>                CustomScreenArchetype;                             // 0x38(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnScreenStackEnum               CustomScreenStack;                                 // 0x40(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2542[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  TutorialTitle;                                     // 0x48(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  TutorialMessage;                                   // 0x60(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FQtnTutorialSubAction>         TutorialSubActions;                                // 0x78(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                        AllowedReminderInterval;                           // 0x88(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnTutorialType                  ReminderTutorialType;                              // 0x8C(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2543[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnScreen>                ReminderCustomScreenArchetype;                     // 0x90(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnScreenStackEnum               ReminderCustomScreenStack;                         // 0x98(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2544[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  ReminderMessage;                                   // 0xA0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnTutorial* GetDefaultObj();

	void UpdateTutorialSubGoalTitle(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName Identity, class FText& TextToUpdate);
	void UpdateTutorialSubGoalMessage(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName Identity, class FText& TextToUpdate);
	void UpdateTutorialGoalTitle(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FText& TextToUpdate);
	void UpdateTutorialGoalMessage(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FText& TextToUpdate);
	void SetTutorialSubgoalState(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName Identity, enum class EQtnTutorialStatus ValueState);
	void SetTutorialState(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, enum class EQtnTutorialStatus ValueState);
	void SetTutorialBoolValue(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName& ValueId, bool ValueState);
	void ResetTutorialReminder(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype);
	void ResetTutorial(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype);
	void ResetAllTutorials(class UObject* SelfReference);
	bool RequestTutorialPresentation(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype);
	void GetTutorialSubGoalText(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName Identity, class FText* OutTitle, class FText* OutMessage);
	enum class EQtnTutorialStatus GetTutorialSubgoalState(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName Identity);
	enum class EQtnTutorialStatus GetTutorialState(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype);
	void GetTutorialGoalText(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FText* OutTitle, class FText* OutMessage);
	bool GetTutorialBoolValue(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName& ValueId);
	class UQtnTutorial* GetQtnTutorialObject(TSubclassOf<class UQtnTutorial> TutorialArchetype);
	TArray<struct FQtnTutorialInstanceData> GetAllActiveTutorials(class UObject* SelfReference);
	class FText FormatSubgoalText(class UObject* WorldReference, class FText& InText);
	void CompleteTutorialSubGoal(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, class FName GoalIdentity, bool AllowTutorialCompletion);
	bool CheckAllTutorialSubGoalsComplete(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype);
	void AddDynamicTutorialSubgoal(class UObject* SelfReference, TSubclassOf<class UQtnTutorial> TutorialArchetype, const struct FQtnTutorialSubAction& SubActionData);
};

// 0x58 (0x178 - 0x120)
// Class QtnGame.QtnTutorialDataBag
class UQtnTutorialDataBag : public UQtnDataBag
{
public:
	float                                        CharsPerSecond;                                    // 0x120(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        MinPopupDuration;                                  // 0x124(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FQtnTutorialInstanceData> TutorialSaveGameMap;                               // 0x128(0x50)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnTutorialDataBag* GetDefaultObj();

};

// 0x158 (0x238 - 0xE0)
// Class QtnGame.QtnUnlocksComponent
class UQtnUnlocksComponent : public UActorComponent
{
public:
	uint8                                        Pad_2559[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UDataTable*                            M_unlocksDataTable;                                // 0xE8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                            M_masterPerksDataTable;                            // 0xF0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                            M_itemStatSettingsDataTable;                       // 0xF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                            M_masterUpgradeSettingsDataTable;                  // 0x100(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                     M_unlockRecords_ClientOnly;                        // 0x108(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class FName>       M_keyToRowMap;                                     // 0x158(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class FText>               M_rewardNames;                                     // 0x1A8(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                  M_unlockKeys;                                      // 0x1F8(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class FName>                          M_sessionUnlockedRowNames;                         // 0x208(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnGrantUnlockRewards_ClientOnly;                   // 0x218(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x228(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUnlocksComponent* GetDefaultObj();

	void SetUnlockRecords_ClientOnly(TMap<class FName, int32>& UnlockRecords);
	void SetSessionUnlockedRowNames_ServerOnly(TArray<class FName>& SessionUnlockedRowNames);
	void ServerCheatReset();
	void ServerAddUnlockKeys(TArray<struct FGameplayTag>& UnlockKeys);
	void ServerAddSessionUnlockedRowName(class FName& SessionUnlockedRowName);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool IsUnlocked(const struct FGameplayTag& UnlockKey);
	class UDataTable* GetUnlocksDataTable();
	TMap<class FName, int32> GetUnlockRecords_ClientOnly();
	void GetUnlockProgress_ClientOnly(class FName UnlocksDataTableRowName, bool* IsUnlocked, int32* NumOccurrences, int32* TargetOccurrences);
	void GetUnlockInfo(class FName UnlocksDataTableRowName, class FText* DisplayName, class FText* Description, bool* IsSecret, class UTexture2D** Icon, struct FGameplayTag* UnlockKey, struct FGameplayTag* UnlockCategory, struct FQtnUnlockRewards* UnlockRewards, class FText* RewardName, TSubclassOf<class UQtnDLCInfo>* RequiredDLC);
	TArray<class FName> GetSessionUnlockedRowNames();
	void GetSessionUnlockedCurrencyRewards(int32* DarkMatter, int32* Fitcoin);
	class FName GetRowNameFromUnlockKey(const struct FGameplayTag& UnlockKey, bool* RowExists);
	void ClientSetSessionUnlockedRowNames(TArray<class FName>& SessionUnlockedRowNames);
	void ClientOnUnlockProgress(class FName DataTableRowName);
};

// 0x50 (0x78 - 0x28)
// Class QtnGame.QtnUpgrade
class UQtnUpgrade : public UObject
{
public:
	uint8                                        Pad_257D[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FDataTableRowHandle                   UpgradeSettings;                                   // 0x30(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                OwningActor;                                       // 0x40(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnUpgradeSlot*                       OwningUpgradeSlot;                                 // 0x48(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQtnInstantUpgrade*>            InstantUpgradeActions;                             // 0x50(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                          UpgradeID;                                         // 0x70(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUpgrade* GetDefaultObj();

	void OnUpgradeRolledDataChangedEvent(class UQtnUpgradeSlot* OwningSlot, struct FQtnRolledUpgradeData& PreviousRolledData, struct FQtnRolledUpgradeData& NewRolledData);
	void OnUnslottedEvent(class UQtnUpgradeSlot* PreviousSlot, struct FQtnRolledUpgradeData& RolledData);
	void OnSlottedEvent(class UQtnUpgradeSlot* TargetSlot, struct FQtnRolledUpgradeData& RolledData, bool LoadedRunProgress);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool K2_CanUpgradeBeSlotted(class UQtnUpgradeSlot* TargetSlot);
	bool IsUnlocked(class AQtnBodyPawn* TargetBodyPawn);
	bool IsRarityUpgradable();
	bool IsLevelUpgradable();
	class UWorld* GetWorld();
	float GetValueOfUpgradeWithSettings(class UQtnUpgrade* UpgradePtr, struct FQtnRolledUpgradeData& RolledData, int32 ArrayIndex);
	float GetValueOfUpgrade(class UQtnUpgradeSlot* OwningSlot, int32 ArrayIndex);
	float GetValueOfRolledUpgrade(struct FQtnUpgradeSettings& RolledUpgradeSettings, struct FQtnRolledUpgradeData& RolledUpgradeData, int32 ArrayIndex);
	struct FQtnUpgradeSettings GetUpgradeSettings();
	struct FGameplayTag GetNextAllowedRarity(struct FGameplayTag& CurrentRarity, struct FGameplayTagContainer& AllowedRarityMask);
	class FText GetFormattedValueAtIndex(struct FQtnUpgradeSettings& InUpgradeSettings, struct FQtnRolledUpgradeData& RolledUpgradeData, int32 ArrayIndex, bool WithStyles, bool ForJokerCard);
	class FText FormatUpgradeText(class FText& FormatText, struct FQtnUpgradeSettings& InUpgradeSettings, struct FQtnRolledUpgradeData& PreviousRolledData, struct FQtnRolledUpgradeData& NewRolledData, bool ForJokerCard);
	class FText CDO_GenerateTextValueForDisplay(struct FQtnUpgradeSettings& InUpgradeSettings, struct FQtnRolledUpgradeData& RolledUpgradeData, int32 ArrayIndex);
	class FName CDO_GenerateTargetModifiableIdentity(class AQtnBodyPawn* TargetPawn, struct FQtnUpgradeSettings& InUpgradeSettings, struct FQtnRolledUpgradeData& RolledUpgradeData, struct FGameplayTag* OutRarityTag, int32* OutLevel);
	bool CanUpgradeBeSlotted(class UQtnUpgradeSlot* TargetSlot);
	bool CanUpgradeBeRolled(class AQtnBodyPawn* TargetBodyPawn);
	bool CanEnemyUpgradeBeRolled(class AQtnGameState* ActiveGameState);
	void CalculateDamageValues(class UQtnUpgradeSlot* OwningSlot, class UQtnVerb* SourceVerb, class AActor* TargetActor, float InBaseDamage, TSubclassOf<class UQtnDamageType> DamageType, float* OutDamageScalar, float* OutBonusDamage);
	void ActivateInstantUpgrade_ServerOnly(class AQtnBodyPawn* TargetPawn, struct FQtnRolledUpgradeResult& RolledUpgradeSettings);
};

// 0xF8 (0x1D8 - 0xE0)
// Class QtnGame.QtnUpgradeComponent
class UQtnUpgradeComponent : public UActorComponent
{
public:
	uint8                                        Pad_2591[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UDataTable*                            ParentUpgradeDataTable;                            // 0xE8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                            GeneralUpgradeDataTable;                           // 0xF0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                            HenriettaUpgradeDataTable;                         // 0xF8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                          HenriettaUpgradeTag;                               // 0x100(0x8)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UQtnUpgradeRestrictionRule>> RestrictionRules;                                  // 0x108(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UQtnUpgradePostProcessingRule>> PostProcessRules;                                  // 0x118(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          OwningBodyPawn;                                    // 0x128(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        PlayerRarityModifier;                              // 0x130(0x4)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2595[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FGameplayTag, struct FRuntimeFloatCurve> RarityCurvesMap;                                   // 0x138(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            UpgradeSlotEvent;                                  // 0x188(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            UpgradeRolledDataChangeEvent;                      // 0x198(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0x1A8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_2596[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UQtnUpgrade>>       M_loadedUpgradeClasses;                            // 0x1C8(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnUpgradeComponent* GetDefaultObj();

	TArray<struct FQtnRolledUpgradeResult> RollUpgrades(TArray<struct FQtnReactionToTag>& NPCPresentationTags, int32 QuantityToRoll, int32 BonusQuantity, TArray<struct FQtnRolledUpgradeResult>& RollHistory, bool AllowRerolls);
	TArray<struct FQtnRolledUpgradeResult> RollGeneralUpgrades(TArray<struct FQtnReactionToTag>& NPCPresentationTags, int32 QuantityToRoll, TArray<struct FQtnRolledUpgradeResult>& RollHistory);
	void QtnUpgradeSlotEvent__DelegateSignature(class UQtnUpgrade* Upgrade, class UQtnUpgradeSlot* UpgradeSlot, bool Slotted);
	void QtnUpgradeRolledDataChangeEvent__DelegateSignature(class UQtnUpgrade* Upgrade, class UQtnUpgradeSlot* UpgradeSlot, struct FQtnRolledUpgradeData& PreviousRolledData, struct FQtnRolledUpgradeData& NewRolledData);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	bool HasAnySlottedUpgrades();
	bool HasAnyIncreasableRarityUpgrades();
	bool HasAnyIncreasableLevelUpgrades();
	void CalculateDamageValues(class UQtnVerb* SourceVerb, class AActor* TargetActor, float InBaseDamage, TSubclassOf<class UQtnDamageType> DamageType, float* OutDamageScalar, float* OutBonusDamage);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnUpgradePostProcessingRule
class UQtnUpgradePostProcessingRule : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnUpgradePostProcessingRule* GetDefaultObj();

	void RunPostProcessingRule(class AQtnBodyPawn* Pawn, TArray<struct FQtnRolledUpgradeResult>& CurrentLootArray);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnUpgradeRestrictionRule
class UQtnUpgradeRestrictionRule : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnUpgradeRestrictionRule* GetDefaultObj();

	void RunRestrictionRule(class AQtnBodyPawn* Pawn, TArray<struct FQtnReactionToTag>& PlayerTagList, TArray<struct FQtnUpgradeSettings>& AvailiableUpgradesSet, TArray<float>& AvailiableUpgradesWeightSet, int32& BonusQuantity, TArray<struct FQtnReactionToTag>& NPCPresentationTags);
};

// 0x98 (0xC0 - 0x28)
// Class QtnGame.QtnUpgradeSession
class UQtnUpgradeSession : public UObject
{
public:
	uint8                                        Pad_25A4[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnUpgradeStationComponent*           R_OwningUpgradeStationComponent;                   // 0x38(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          R_TargetBodyPawn;                                  // 0x40(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQtnBodyPawn*                          L_TargetBodyPawn;                                  // 0x48(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                       R_TargetPlayerSlot;                                // 0x50(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                R_TargetTribunalSlot;                              // 0x58(0x8)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                      R_UniqueNetId;                                     // 0x60(0x28)(BlueprintVisible, BlueprintReadOnly, Net, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EQtnUpgradeSessionState           R_CurrentSessionState;                             // 0x88(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_25A6[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnRolledUpgradeResult>       R_RolledUpgradesArray;                             // 0x90(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FQtnUpgradeModificationHistory> R_HandModifiersArray;                              // 0xA0(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUpgradeSession* GetDefaultObj();

	void SetRolledUpgradesArray_ServerOnly(TArray<struct FQtnRolledUpgradeResult>& RolledUpgrades);
	void SetCurrentState_ServerOnly(enum class EQtnUpgradeSessionState NewState);
	void ServerLinkToBodyPawn(class AQtnBodyPawn* BodyPawnTarget);
	void RequestModifyHandCardHistory_ServerOnly(int32 CardIndex, struct FQtnUpgradeModificationHistory& UpgradeModification);
	void OnRolledUpgradesArrayChangedEvent(TArray<struct FQtnRolledUpgradeResult>& RolledUpgrades);
	void OnRep_RolledUpgradesArray();
	void OnRep_CurrentSessionState();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnCurrentSessionStateChangedEvent(enum class EQtnUpgradeSessionState NewState);
	void LinkToBodyPawn_ServerOnly(class AQtnBodyPawn* BodyPawnTarget);
	void LinkToBodyPawn_LocalOnly(class AQtnBodyPawn* BodyPawnTarget);
	void Initialize_ServerOnly(class UQtnUpgradeStationComponent* OwningComponent, class AQtnBodyPawn* OwningBodyPawn, class USceneComponent* TargetPlayerSlot, class AActor* TargetTribunalSlot);
	class AQtnBodyPawn* GetSessionBodyPawn();
	void ClearModifiedHandCardHistory_ServerOnly();
};

// 0x140 (0x168 - 0x28)
// Class QtnGame.QtnUpgradeSlot
class UQtnUpgradeSlot : public UObject
{
public:
	uint8                                        Pad_25E3[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	enum class EQtnSlotType                      M_SlotType;                                        // 0x2C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_25E4[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyPawn*                          R_pOwningBodyPawn;                                 // 0x30(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnVerb*                              R_pOwningVerb;                                     // 0x38(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnItem*                              R_pOwningItem;                                     // 0x40(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnBodyPawn*                          L_pOwningBodyPawn;                                 // 0x48(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnVerb*                              L_pOwningVerb;                                     // 0x50(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnItem*                              L_pOwningItem;                                     // 0x58(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_isReadyForGameplay;                              // 0x60(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_needsLocalRefresh;                               // 0x61(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_25E6[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnUpgradeInfo                       R_upgradeInfo;                                     // 0x68(0x68)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FQtnUpgradeInfo                       L_upgradeInfo;                                     // 0xD0(0x68)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_25E7[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 R_SlotDesignation;                                 // 0x148(0x20)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUpgradeSlot* GetDefaultObj();

	bool UpdateRolledData_ServerOnly(struct FQtnRolledUpgradeData& NewRolledData, class UObject* Instigator);
	bool UnslotUpgrade_ServerOnly(class UObject* Instigator);
	bool SlotUpgrade_ServerOnly(struct FQtnUpgradeSettings& SettingsData, struct FQtnRolledUpgradeData& RolledData, enum class EQtnSlotCollisionSettings CollisionSettings);
	void ServerUpdateRolledData(struct FQtnRolledUpgradeData& NewRolledData, class UObject* Instigator);
	void ServerUnslotUpgrade(class UObject* Instigator);
	void ServerSlotUpgrade(struct FQtnUpgradeSettings& SettingsData, struct FQtnRolledUpgradeData& RolledData, enum class EQtnSlotCollisionSettings CollisionSettings);
	struct FQtnUpgradeRunProgressData SerializeToRunProgressData_ServerOnly(int32 SlotIndex);
	void OnRep_UpgradeInfo();
	void OnRep_OwningVerb();
	void OnRep_OwningItem();
	void OnRep_OwningBody();
	void LoadFromRunProgressData_ServerOnly(struct FQtnUpgradeRunProgressData& RunProgressData);
	bool IsSlotFilled(bool TreatRecentlyUnslottedAsFilled);
	bool IsAllowedToSlot(struct FQtnUpgradeSettings& SettingsData);
	enum class EQtnSlotType GetSlotType();
	struct FQtnRolledUpgradeData GetRolledUpgradeData();
	class UQtnVerb* GetOwningVerb();
	class AQtnItem* GetOwningItem();
	class AQtnBodyPawn* GetOwningBodyPawn(bool ExtractBodyFromItemOrVerbUpgrades);
	class UQtnUpgrade* GetCurrentSlottedUpgrade();
	int32 CompareUpgrades(struct FQtnUpgradeSettings& CurrentSettingsData, struct FQtnRolledUpgradeData& CurrentRolledData, struct FQtnUpgradeSettings& PotentialSettingsData, struct FQtnRolledUpgradeData& PotentialRolledData);
};

// 0x28 (0x108 - 0xE0)
// Class QtnGame.QtnUpgradeStationComponent
class UQtnUpgradeStationComponent : public UActorComponent
{
public:
	uint8                                        Pad_25EC[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnUpgradeSession*>            R_CurrentPlayerSessionArray;                       // 0xE8(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DebugDisplayEvent;                                 // 0xF8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUpgradeStationComponent* GetDefaultObj();

	void SetCurrentPlayerSessionArray(TArray<class UQtnUpgradeSession*>& NewArrayValues);
	void OnRep_CurrentPlayerSessionArray();
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnCurrentPlayerSessionArrayUpdatedEvent();
	class UQtnUpgradeSession* FindAssociatedUpgradeSession(class AQtnBodyPawn* PlayerInUpgradeSession);
};

// 0x0 (0xA8 - 0xA8)
// Class QtnGame.QtnUpperBodyFSM
class UQtnUpperBodyFSM : public UQtnFSM
{
public:

	static class UClass* StaticClass();
	static class UQtnUpperBodyFSM* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class QtnGame.QtnUpperBodyState
class UQtnUpperBodyState : public UQtnBodyState
{
public:

	static class UClass* StaticClass();
	static class UQtnUpperBodyState* GetDefaultObj();

};

// 0x58 (0x108 - 0xB0)
// Class QtnGame.QtnUpperBodyStateAction
class UQtnUpperBodyStateAction : public UQtnUpperBodyState
{
public:
	bool                                         M_isMonitoringActionIntention;                     // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_25EF[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnActionIntention                   M_actionIntention;                                 // 0xB8(0x28)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_montageIsDone;                                   // 0xE0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_25F1[0x27];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateAction* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class QtnGame.QtnUpperBodyStateClimbing
class UQtnUpperBodyStateClimbing : public UQtnUpperBodyState
{
public:
	bool                                         M_frobbing;                                        // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_25F3[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateClimbing* GetDefaultObj();

};

// 0x58 (0x108 - 0xB0)
// Class QtnGame.QtnUpperBodyStateEquipping
class UQtnUpperBodyStateEquipping : public UQtnUpperBodyState
{
public:
	uint8                                        Pad_25F4[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_simulationTimer;                                 // 0xBC(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pItemToUnequip;                                  // 0xC0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pItemToEquip;                                    // 0xC8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isRangedItem;                                    // 0xD0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_equipNotifyReceived;                             // 0xD1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_unEquipNotifyReceived;                           // 0xD2(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_instant;                                         // 0xD3(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_25F5[0x34];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateEquipping* GetDefaultObj();

};

// 0x48 (0xF8 - 0xB0)
// Class QtnGame.QtnUpperBodyStateFrobbing
class UQtnUpperBodyStateFrobbing : public UQtnUpperBodyState
{
public:
	class UQtnFrobbableComponent*                M_pFrobTarget;                                     // 0xB0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pFrobbedActorBeingCarried;                       // 0xB8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       M_frobBodyAction;                                  // 0xC0(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                         M_montageIsDone;                                   // 0xD0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_inhibitMontageDelegates;                         // 0xD1(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_25F6[0x26];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateFrobbing* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class QtnGame.QtnUpperBodyStateIndisposed
class UQtnUpperBodyStateIndisposed : public UQtnUpperBodyState
{
public:

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateIndisposed* GetDefaultObj();

};

// 0x38 (0xE8 - 0xB0)
// Class QtnGame.QtnUpperBodyStateReady
class UQtnUpperBodyStateReady : public UQtnUpperBodyState
{
public:
	bool                                         M_frobbing;                                        // 0xB0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_25F7[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UObject*                               M_pLocalFillInProgress;                            // 0xB8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pLastActualEquippedRangedItem;                   // 0xC0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pLastActualEquippedMeleeItem;                    // 0xC8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnPawnMontage                       M_equipLoopAction;                                 // 0xD0(0x10)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UBlendSpace*                           M_pCurrentLocoBlend;                               // 0xE0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateReady* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class QtnGame.QtnUpperBodyStateVerb
class UQtnUpperBodyStateVerb : public UQtnUpperBodyState
{
public:

	static class UClass* StaticClass();
	static class UQtnUpperBodyStateVerb* GetDefaultObj();

};

// 0x28 (0x50 - 0x28)
// Class QtnGame.QtnUserWidgetPool
class UQtnUserWidgetPool : public UObject
{
public:
	TSubclassOf<class UUserWidget>               WidgetClass;                                       // 0x28(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUserWidget*>                   ActiveWidgets;                                     // 0x30(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUserWidget*>                   InactiveWidgets;                                   // 0x40(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnUserWidgetPool* GetDefaultObj();

	void ResetPool();
	void Release(class UUserWidget* Widget);
	void InitializeWidgetPool(int32 WarmUpPoolNum);
	class UUserWidget* AcquireWidgetFromPool();
};

// 0x60 (0x88 - 0x28)
// Class QtnGame.QtnUserWidgetPoolManager
class UQtnUserWidgetPoolManager : public UObject
{
public:
	TArray<struct FUserWidgetPoolClassSetting>   UserWidgetPoolClassSetting;                        // 0x28(0x10)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UUserWidget>, class UQtnUserWidgetPool*> UserWidgetPoolMap;                                 // 0x38(0x50)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnUserWidgetPoolManager* GetDefaultObj();

	void ReturnWidgetToPool(TSubclassOf<class UUserWidget> WidgetClass, class UUserWidget* Widget);
	bool IsWidgetPoolEnabled();
	void Initialize();
	class UQtnUserWidgetPool* GetWidgetPoolByClass(TSubclassOf<class UUserWidget> WidgetClass);
	void Cleanup();
	class UUserWidget* AcquireWidgetFromPool(TSubclassOf<class UUserWidget> WidgetClass);
};

// 0x20 (0x48 - 0x28)
// Class QtnGame.QtnUtilities
class UQtnUtilities : public UObject
{
public:
	class FString                                APIGatewayURL;                                     // 0x28(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                APIGatewayKey;                                     // 0x38(0x10)(BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnUtilities* GetDefaultObj();

	bool VolumeEncompassesPoint(class AVolume* Target, const struct FVector& Point, float SphereRadius, float* DistanceToPoint);
	void UpdateBounds(class USceneComponent* SceneComponent);
	void TickAnimationAndRefreshBones(class USkeletalMeshComponent* SkeletalMeshComponent);
	void TickAccumulator(float& RatioRef, bool IsFilling, float DeltaSeconds, float FillDrainDuration, bool* GotFull);
	TSubclassOf<class UQtnVerb> SyncLoadVerbClass(TSoftClassPtr<class UQtnVerb> VerbSoftClass);
	TSubclassOf<class UQtnUpgrade> SyncLoadUpgradeClass(TSoftClassPtr<class UQtnUpgrade> UpgradeSoftClass);
	class UStaticMesh* SyncLoadStaticMesh(TSoftObjectPtr<class UStaticMesh> StaticMesh);
	class USkeletalMesh* SyncLoadSkeletalMesh(TSoftObjectPtr<class USkeletalMesh> SkeletalMesh);
	TSubclassOf<class UQtnScreen> SyncLoadScreenClass(TSoftClassPtr<class UQtnScreen> SoftScreenClass);
	TSubclassOf<class UQtnPerk> SyncLoadPerkClass(TSoftClassPtr<class UQtnPerk> PerkSoftClass);
	class UClass* SyncLoadClass(TSoftClassPtr<class UObject> SoftClass);
	TSubclassOf<class AActor> SyncLoadActorClass(TSoftClassPtr<class AActor> SoftActorClass);
	bool StaticIsEndlessMode(int32 Arc);
	int32 StaticGetEndlessModeArcEnumeration();
	class FText StaticFormatText(class FText InText);
	bool SphereTrace(class AActor* QueryingActor, struct FVector& Start, struct FVector& End, float Radius, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	class AActor* SpawnActor_ServerOnly(class AActor* OwningActor, TSubclassOf<class AActor> ActorClass, struct FTransform& Transform, enum class ESpawnActorCollisionHandlingMethod CollisionHandling);
	void SortVectorArrayWithPredicate(TArray<struct FVector>& InArray, FDelegateProperty_& Predicate);
	void SortTransformArrayWithPredicate(TArray<struct FTransform>& InArray, FDelegateProperty_& Predicate);
	void SortStrings(TArray<class FString>& InArray);
	void SortRotatorArrayWithPredicate(TArray<struct FRotator>& InArray, FDelegateProperty_& Predicate);
	void SortObjectArrayWithPredicate(TArray<class UObject*>& InArray, FDelegateProperty_& Predicate);
	void SortNames(TArray<class FName>& InArray);
	void SortGameplayTags(TArray<struct FGameplayTag>& InArray);
	void SortActorArrayWithPredicate(TArray<class AActor*>& InArray, FDelegateProperty_& Predicate);
	struct FVector SnapToGround(class AActor* OwningActor, struct FVector& UnsnappedPosition, float MaxSnapDistance, bool* FoundGround, struct FVector* HitNormal, enum class EPhysicalSurface* PhysicalSurface);
	void ShowLoadingMovie(class UObject* WorldContextObject);
	void ShowInviteUI(class UObject* WorldContextObject, enum class EQtnOutputSuccessEnum* OutputPin);
	void ShowFriendsUI(class UObject* WorldContextObject, enum class EQtnOutputSuccessEnum* OutputPin);
	bool ShouldPrimeSoundsOnPlatform();
	void SetTransformMotionBlurEnabled(class UObject* WorldContextObject, bool bMotionBlurEnabled);
	void SetSubtitleCategoryEnabled(class FName SubtitleCategory, bool Enabled);
	void SetStreamingLevelTransform(class ULevelStreaming* StreamingLevel, const struct FTransform& Transform);
	void SetScreenPercentage(float ScreenPercentage);
	void SetLightmapType(class UPrimitiveComponent* Component, enum class ELightmapType LightmapType);
	void SetGameDefaultMap(const class FString& NewDefaultMap);
	void SetActorTickComplete(class AActor* ActorToDisableTick, bool bShouldTick);
	void SetActorsInLevelHidden(class ULevelStreaming* StreamingLevel, bool Hidden, const class FString& ContextString);
	void ServerStopListen(class UObject* WorldContextObject);
	void ServerStartListen(class UObject* WorldContextObject);
	struct FGameplayTag SelectBestUpgradeTag(TArray<struct FGameplayTag>& PrimaryTags, TArray<struct FGameplayTag>& SecondaryTags, struct FRandomStream& RandomStream, const struct FGameplayTag& GeneralTag, float TierChance);
	void RunGc(enum class EQtnRunGcMode Mode, bool bFullPurge);
	void QtnPrintStringToFile(const class FString& NewFileHeader, class FString& FileContents, const class FString& FolderName, const class FString& Filename, bool Append, bool OpenFolder);
	void QtnPrintString(class UObject* WorldContextObject, const class FString& InString, enum class EQtnLogCategory LogCategory, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration);
	TArray<class AQtnPawn*> QtnDoRadialKnockback(class UObject* WorldContextObject, struct FVector& Origin, TArray<class AActor*>& ActorsToIgnore, struct FQtnRangedFloat& KnockbackRadii, float KnockbackStrength, bool blockedByDeepSnow);
	TArray<class AActor*> QtnDoRadialDamage(struct FQtnRangedFloat& DamageRadii, struct FQtnDamageInfo& DamageInfo, bool blockedByDeepSnow, class AQtnProjectile* Projectile, bool IgnoreBlockingGeometry, bool UseRadialDamageScaling, const struct FVector& ImpactOffset);
	bool PrimeSoundWaves(TArray<class USoundWave*>& SoundsToPrime);
	bool PrimeSoundCues(TArray<class USoundCue*>& SoundCuesToPrime);
	void PreloadClassArray(const TArray<TSoftClassPtr<class UObject>>& SoftClassArray);
	void PreloadClass(TSoftClassPtr<class UObject> SoftClass);
	void PlaySingleShot3DSound(class AActor* SourceActor, class USoundBase* Sound);
	bool MapAffectsPlayerProgress(class UObject* WorldContextObject);
	struct FLinearColor MakeRandomLinearColor();
	struct FColor MakeRandomColor();
	bool LineTrace(class AActor* QueryingActor, struct FVector& Start, struct FVector& End, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	bool IsWithinVerbRange(class AQtnPawn* AttackingPawn, class AActor* TargetActor, struct FQtnRangedFloat& HorizontalReach, float VerticalReach, struct FQtnRangedFloat& HalfAngleDegrees, bool IsLobbedProjectile, float FutureSeconds);
	bool IsWeaponRanged(struct FQtnItemData& ItemData);
	bool IsViewportFadedUp(class UObject* WorldContextObject);
	bool IsUserAccountCurrency(class FString& CurrencyId);
	bool IsTradeshowDemo();
	bool IsSubtitleCategoryEnabled(class FName SubtitleCategory);
	bool IsShippingBuild();
	bool IsSameVersion(struct FQtnVersion& CurrentVersion, struct FQtnVersion& VersionToCompareAgainst);
	bool IsRunningCommandlet();
	bool IsProxyInventoryCurrency(class FString& CurrencyId);
	bool IsPlayingInEditor();
	bool IsPlatform(enum class EQtnPlatform Platform);
	bool IsOlderVersion(struct FQtnVersion& CurrentVersion, struct FQtnVersion& VersionToCompareAgainst);
	void IsObjectOfType(class UObject* Target, TSoftClassPtr<class UObject> TestClass, enum class EQtnOutputYesNoEnum* OutputPin);
	bool IsItemDataValid(struct FQtnItemData& ItemData);
	bool IsInPIEWorld(class UObject* WorldContextObject);
	bool IsEndPlayShuttingDown(class UWorld* ExpectedWorld, enum class EEndPlayReason EndPlayReason);
	bool IsDeferredSceneCaptureFinished(class USceneCaptureComponent2D* SceneCaptureComponent);
	void IsClassOfType(class UClass* TargetClass, TSoftClassPtr<class UObject> TestClass, enum class EQtnOutputYesNoEnum* OutputPin);
	bool HasVerbClearance(class AQtnPawn* AttackingPawn, class AActor* TargetActor, bool ForRangedAttacks);
	struct FVector GetWorldGravity(class UObject* WorldContextObject);
	class UClass* GetSuperClass(class UClass* ChildClass);
	class ULevelStreaming* GetStreamingLevelFromActor(class AActor* TargetActor);
	float GetScaledFOV(float FOV, float Scalar);
	TSubclassOf<class UQtnVerb> GetPowerVerbClass(struct FQtnItemData& ItemData);
	enum class EQtnPlatform GetPlatform();
	class UWorld* GetExpectedWorld(class AActor* ActorInTheWorld);
	float GetDisplayGamma();
	struct FGameplayTag GetCurrencyGameplayTag(class FString& CurrencyId);
	class FString GetClassNameWithoutSuffix(class UClass* Archetype);
	class FString GetClassNameFromObject(class UObject* ObjectInstance, bool FullPath, bool TrimSuffix);
	class FString GetClassNameFromArchetype(class UClass* Archetype, bool FullPath, bool TrimSuffix);
	class UClass* GetClassFromName(class FString& ClassPath, bool ErrorIfNotFound);
	class UObject* GetClassDefaultObject(class UObject* SelfReference, TSubclassOf<class UObject> ObjectClass);
	class USceneComponent* GetChildComponentByClass(class USceneComponent* ParentComponent, class UClass* ComponentClass);
	int32 GetChangelist();
	class FString GetBuildLabel();
	class FName GetAssetNameForLevel(TSoftObjectPtr<class UWorld> Level);
	class AActor* GetActorInStreamingLevel(TSubclassOf<class AActor> ActorClass, class ULevelStreaming* StreamingLevel);
	TArray<struct FVector2D> GeneratePoissonDiscSamples(int32 Width, int32 Height, float ExclusionRadius, int32 Iterations, struct FRandomStream& RandomStream);
	class FText FormatSubtitles(class FText& SubtitleText, class FName& SpeakerStyle, class FName& SubtitleStyle);
	void FadeUpViewport(class UObject* FadeToken, float Duration);
	void FadeDownViewport(class UObject* FadeToken, float FadeDuration);
	void EmitCustomAINoise_ServerOnly(class AActor* EmittingActor, class AQtnPawn* CulpritPawn, struct FQtnNoiseConfig& CustomNoiseConfig);
	void EmitAINoise_ServerOnly(class AActor* EmittingActor, class AQtnPawn* CulpritPawn, enum class EQtnNoiseEnum NoiseType, float NoiseStrength);
	void DoesMapAffectPlayerProgress(class UObject* WorldContextObject, enum class EQtnOutputYesNoEnum* OutputPin);
	class FText DecorateWithRichTextStyle(class FText TextToDecorate, const class FString& RichTextStyleName);
	class FString ConvertVersionToString(struct FQtnVersion& Version);
	class FString ConvertTimeStampToString(struct FDateTime& Timestamp);
	class FName ConvertSurfaceTypeToName(enum class EPhysicalSurface SurfaceType);
	class FString ConvertEndPlayReasonToString(enum class EEndPlayReason EndPlayReason);
	bool ChooseWeightedRandomItems(TArray<int32>& TargetArray, TArray<float>& WeightArray, int32 NumberToChoose, TArray<int32>* Items);
	int32 ChooseIndexFromWeightedList(TArray<float>& WeightedList);
	bool CheckForButtonMash(class AQtnPawn* MashingPawn, enum class EQtnUIBodyActionEnum LastMashedButton, enum class EQtnUIBodyActionEnum* CurrentMashedButton);
	void CaptureSceneDeferredAndWait(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USceneCaptureComponent2D* SceneCaptureComponent);
	void CaptureSceneDeferred(class USceneCaptureComponent2D* SceneCaptureComponent);
	bool CapsuleTrace(class AActor* QueryingActor, struct FVector& Start, struct FVector& End, float Radius, float HalfHeight, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	bool BoxTrace(class AActor* QueryingActor, struct FVector& Start, struct FVector& End, struct FVector& boxSize, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	void AsyncLoadClassArray(class UObject* WorldContextObject, const TArray<TSoftClassPtr<class UObject>>& SoftClassArray, const struct FLatentActionInfo& LatentInfo, TArray<TSubclassOf<class UObject>>* ArchetypeArray);
	void AsyncLoadClass(class UObject* WorldContextObject, TSoftClassPtr<class UObject> SoftClass, const struct FLatentActionInfo& LatentInfo, TSubclassOf<class UObject>* Archetype);
	void AppendRandomAscii(class FString& String, int32 NumCharacters);
	void AddEventWindowTimestamp(class UObject* EventObject, struct FQtnEventWindow& EventWindow, bool* HitThreshold);
};

// 0x898 (0x8C0 - 0x28)
// Class QtnGame.QtnVerb
class UQtnVerb : public UObject
{
public:
	uint8                                        Pad_26FC[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UQtnAnimWindow*>                M_pendingAnimWindows;                              // 0x38(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              R_pOwningPawn;                                     // 0x48(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQtnItem*                              R_pOwningItem;                                     // 0x50(0x8)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnUIBodyActionEnum              R_associatedInputAction;                           // 0x58(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_26FD[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UDataTable*                            ContactFXDataTable;                                // 0x60(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnContactData*                       ContactFXAsset;                                    // 0x68(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnVerbComponent*                     M_pPawnVerbComponent;                              // 0x70(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_hasBeenLocallyInitialized;                       // 0x78(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_26FE[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UObject*                               M_pIntendedTarget;                                 // 0x80(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_26FF[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnPawnMontage                       AutoplayedVerbAction;                              // 0x90(0x10)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                         M_autoplayedVerbActionLoops;                       // 0xA0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2701[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQtnPawnMontage>               MeleeActions;                                      // 0xA8(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnCameraBehavior>        CameraBehaviorDuringUse;                           // 0xB8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQtnCameraBehavior*                    M_pActiveCameraBehavior;                           // 0xC0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FQtnUpgradeSlotConfiguration>  VerbUpgradeSlots;                                  // 0xC8(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UQtnUpgradeSlot*>               R_UpgradeSlots;                                    // 0xD8(0x10)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                        R_ResourceCostMultiplier;                          // 0xE8(0x4)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        R_ResourceMultiplier;                              // 0xEC(0x4)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FQtnTagPresence>               DescriptiveTags;                                   // 0xF0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         M_isVerbEquipped;                                  // 0x100(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2702[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_lastLocoRatio;                                   // 0x104(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        LocomotionRatio;                                   // 0x108(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2703[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UBlendSpace*                           LocoBlendOverride;                                 // 0x110(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                           M_pCurrentLocoBlend;                               // 0x118(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         AllowJumpToInterrupt;                              // 0x120(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         LockYaw;                                           // 0x121(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_rootMotionPending;                               // 0x122(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_rootMotionStartedOnIce;                          // 0x123(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         TiltRotationAlongSlopes;                           // 0x124(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         CanWalkOffLedges;                                  // 0x125(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         SetPawnSlippery;                                   // 0x126(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2705[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTag                          VerbTag;                                           // 0x128(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>             ReticleTexture;                                    // 0x130(0x28)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x158(0x28)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                M_pCurrentAttackTarget;                            // 0x180(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                M_pLastMeleedActor;                                // 0x188(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_isJumping;                                       // 0x190(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2706[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_numTimesUsed;                                    // 0x194(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2707[0x27C];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         M_releaseDetected;                                 // 0x414(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2708[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_comboIndex;                                      // 0x418(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_chargedAttack;                                   // 0x41C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_2709[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_nextComboIndex;                                  // 0x420(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_dodgeBuffered;                                   // 0x424(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_dodgeReleaseDetected;                            // 0x425(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_jumpBuffered;                                    // 0x426(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_meleeHitDetectedForThisAction;                   // 0x427(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               M_lastDirectionBeforeMeleeHit;                     // 0x428(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_allowComboTransition;                            // 0x434(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_allowComboInput;                                 // 0x435(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         M_allowCancel;                                     // 0x436(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_270B[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        M_elapsedVerbTime;                                 // 0x438(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_270C[0xF4];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnDamageType>            MeleeDamageType;                                   // 0x530(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        DamageAmount;                                      // 0x538(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ImpulseAmount;                                     // 0x53C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         RequiresTarget;                                    // 0x540(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         InduceEmptyHands;                                  // 0x541(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsPowerVerb;                                       // 0x542(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bShouldPrintErrors;                                // 0x543(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsPower;                                          // 0x544(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsWeaponBased;                                    // 0x545(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsCheat;                                          // 0x546(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EQtnStatChannel                   VerbDamageTableChannel;                            // 0x547(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnAttribute>             BonusBaseDamageScalarAttributeClass;               // 0x548(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnAttribute>             BonusDamageScalarAttributeClass;                   // 0x550(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQtnAttribute>             BonusDamageModifierNextStrikeAttributeClass;       // 0x558(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                   VerbRPGData;                                       // 0x560(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         UseRangedTactics;                                  // 0x570(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseForCombatDistancing;                            // 0x571(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         UseFormationDistanceOverride;                      // 0x572(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2710[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnRangedFloat                       FormationDistanceOverride;                         // 0x574(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        EstimatedTimeFromStartToDamage;                    // 0x57C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IgnoreTicketing;                                   // 0x580(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2711[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnTicketType>            AttackTicketType;                                  // 0x588(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       VerbRange;                                         // 0x590(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                        VerbHalfHeight;                                    // 0x598(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       VerbAngle;                                         // 0x59C(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         HoldDownToRepeat;                                  // 0x5A4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2713[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        IdleTurnSpeed;                                     // 0x5A8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        IceMovementMultiplier;                             // 0x5AC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MinTrackingAngle;                                  // 0x5B0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2715[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            VerbEquipChangeEvent;                              // 0x5B8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            VerbDormancyChangeEvent;                           // 0x5C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FQtnAttributeContainer                R_attributeContainer;                              // 0x5D8(0x258)(Edit, Net, DisableEditOnInstance, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnAttributeAddedEvent;                             // 0x830(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAttributeRemovedEvent;                           // 0x840(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                  VerbName;                                          // 0x850(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  VerbDescription;                                   // 0x868(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                          VerbID;                                            // 0x880(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        M_localCooldown;                                   // 0x888(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isLocalCooldownPaused;                           // 0x88C(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2717[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	double                                       M_nextDormantReplicateTime;                        // 0x890(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                       M_lastDormantReplicateTime;                        // 0x898(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_needToCalculateNextDormantReplication;           // 0x8A0(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2718[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MaxCooldown;                                       // 0x8A4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        StartingLocalCooldown;                             // 0x8A8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowFrobToInterrupt;                              // 0x8AC(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2719[0x13];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnVerb* GetDefaultObj();

	bool WillVerbSucceed(class UObject* PotentialTarget);
	bool UseNativeGetFlameThrowerMaxDistance();
	float StartVerbAction(struct FQtnPawnMontage& VerbAction, float PlayRate, float StartTime);
	bool SphereTrace(struct FVector& Start, struct FVector& End, float Radius, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	class AQtnProjectile* SpawnProjectile_ServerOnly(TSubclassOf<class AQtnProjectile> ProjectileClass, struct FVector& MuzzlePosition, struct FVector& ProjectileVelocity, class AQtnPawn* Culprit);
	void SpawnProjectile_LocalOnly(TSubclassOf<class AQtnProjectile> ProjectileClass, struct FVector& MuzzlePosition, struct FVector& ProjectileVelocity);
	class AActor* SpawnNonReplicatedActor(TSubclassOf<class AActor> ActorClass, struct FTransform& Transform);
	class AActor* SpawnActor_ServerOnly(TSubclassOf<class AActor> ActorClass, struct FTransform& Transform, enum class ESpawnActorCollisionHandlingMethod CollisionHandling);
	bool ShouldUseHeadAim();
	bool ShouldTiltRotationAlongSlopes();
	void SetRootMotionSmoothMoveToDynamicLocation(const struct FVector& TargetLocation, class FName InstanceName);
	void SetRootMotionInstantMoveToDynamicLocation(const struct FVector& TargetLocation, class FName InstanceName);
	void SetResourceMultiplier(float Value);
	void SetResourceCostMultiplier(float Value);
	void SetLocalCooldownValue(float Value);
	void SetLocalCooldownPaused(bool WantPause);
	void SetIntendedTarget(class AActor* TargetActor);
	void SetCharacterMovementMode(enum class EMovementMode MovementMode);
	void ServerSpawnProjectile(TSubclassOf<class AQtnProjectile> ProjectileClass, const struct FVector& MuzzlePosition, const struct FVector& ProjectileVelocity);
	void QtnVerbEquipChangeEvent__DelegateSignature(class UQtnVerb* AffectedVerb, bool IsEquipped, bool IsServer);
	void QtnVerbDormancyChangeEvent__DelegateSignature(class UQtnVerb* Verb, bool Dormant);
	void OnVerbUnInit(bool IsServer);
	void OnVerbStop(enum class EQtnStopReason StopReason, bool IsServer);
	void OnVerbStart(class UObject* IntendedTarget, bool IsServer);
	void OnVerbInit(bool IsServer);
	void OnVerbEquipChange(bool IsEquipped, bool IsServer);
	void OnRep_AttributeContainer();
	void OnProjectileSpawned(class AQtnProjectile* SpawnedProjectile, bool IsServer);
	void OnProjectilePreHit_ServerOnly(class AQtnProjectile* Projectile, bool* IgnoreCollision);
	void OnProjectileMelee(class AQtnProjectile* Projectile, bool IsServer, bool* IgnoreDamage);
	void OnMovementBlocked(struct FHitResult& Impact, bool IsServer);
	void OnMontageEnded(class UAnimMontage* Montage, bool Interrupted, bool IsServer);
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool Interrupted, bool IsServer);
	void OnDebugDisplay(class UQtnDebugWrapper* DebugWrapper);
	void OnComboBegin(struct FQtnPawnMontage& ComboAction, bool IsServer);
	void OnAnimWindowEnd(class UQtnAnimWindow* AnimWindow, bool Interrupted, bool IsServer);
	void OnAnimWindowBegin(class UQtnAnimWindow* AnimWindow, float TotalDuration, bool IsServer);
	void OnAnimNotify(class UQtnAnimNotify* AnimNotify, bool IsServer);
	void OnActiveVerbTicked(struct FQtnPawnIntentions& PawnIntentions, float DeltaSeconds, float ElapsedTime, bool IsServer);
	void ModifyAnimWindowBlockParryValues(struct FQtnRangedFloat& OriginalDegrees, float OriginalCm, struct FQtnRangedFloat* ModifiedDegrees, float* ModifiedCm);
	bool LineTrace(struct FVector& Start, struct FVector& End, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	bool IsVerbFinished();
	bool IsVerbEquipped();
	bool IsVerbActive();
	bool IsTargetActorWorthyOfAttack(class AQtnPawn* SelfPawn, class AActor* PotentialVictim);
	bool IsServer();
	bool IsRangedWeaponVerb();
	bool IsMeleeWeaponVerb();
	bool IsMeleeComboPending();
	bool IsAssociatedInputActionPressed();
	bool HasDodgeBeenReleased();
	bool HasAttackTicket();
	void HandleOutgoingDamage(class AActor* DamagedActor, struct FQtnDamageInfo& DamageInfo, struct FQtnHitReactionInfo& HitReactionInfo, bool IsServer);
	bool HandleIncomingParry(struct FQtnDamageInfo& DamageInfo);
	void HandleIncomingDamage(struct FQtnDamageInfo& IncomingDamageInfo, struct FQtnHitReactionInfo& HitReactionInfo, struct FQtnDamageInfo* ModifiedDamageInfo);
	bool HandleIncomingBlock(struct FQtnDamageInfo& DamageInfo);
	struct FVector GetWorldGravity();
	class UWorld* GetWorld();
	struct FQtnVerbTuningDataRow GetVerbTuningData();
	struct FQtnCameraVerbAim GetVerbLocalProjectileAimTarget(class USceneComponent* MuzzleComponentPtr, float Speed, float GravityModifier, const struct FVector& TargetPoint);
	struct FQtnCameraVerbAim GetVerbLocalProjectileAim(class USceneComponent* MuzzleComponentPtr, float Speed, float Range, float GravityModifier, float AimAssistRadius);
	float GetVerbDamageFromChannel(enum class EQtnStatChannel Channel);
	class FString GetVerbButtonGlyph(bool EncloseKeyboardKeysInBrackets);
	class FString GetVerbAffordancePrompt(class UObject* PotentialTarget);
	TArray<class UQtnUpgradeSlot*> GetUpgradeSlots();
	class UTexture2D* GetReticleTexture();
	float GetResourceMultiplier();
	float GetResourceCostMultiplier();
	class AQtnPawn* GetOwningPawn();
	class AQtnItem* GetOwningItem();
	class AQtnBodyPawn* GetOwningBodyPawn();
	float GetLocoTurnSpeed();
	float GetLocomotionRatio();
	class UBlendSpace* GetLocoBlendOverride();
	float GetLocalCooldownValue();
	class UObject* GetIntendedTarget();
	class UTexture2D* GetIconForUI();
	void GetFlameThrowerMaxDistance(struct FVector& InStartLoc, float& InMaxDistance, float* TraceHitDistance, struct FVector* TraceHitPoint, struct FHitResult* HitData);
	float GetEntitiyDamageFromChannel(enum class EQtnStatChannel Channel);
	float GetElapsedVerbTime();
	float GetDamageValueFromChannel(class AActor* VictimActor, float* BaseDamage, enum class EQtnStatChannel LocalDamageTableChannelOverride, float DamageMultiplier);
	float GetDamageValue(class AActor* VictimActor, float* BaseDamage, float DamageMultiplier);
	TSubclassOf<class UQtnDamageType> GetDamageType();
	class FName GetContactFXKey(class FName& MeleeKey);
	class UDataTable* GetContactFXDataTable();
	class AQtnBodyPawn* GetBodyToBlame();
	enum class EQtnUIBodyActionEnum GetAssociatedInputAction();
	void FinishVerbAction(struct FQtnPawnMontage& VerbAction, bool JumpToOutro);
	void EndRootMotion(class FName InstanceName);
	bool CapsuleTrace(struct FVector& Start, struct FVector& End, float Radius, float HalfHeight, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	bool CanVerbStart(class UObject* PotentialTarget);
	bool CanMantle();
	void BufferJumpInput(bool WantBuffer);
	void BufferDodgeInput(bool WantBuffer);
	bool BoxTrace(struct FVector& Start, struct FVector& End, struct FVector& boxSize, enum class ECollisionChannel TraceChannel, TArray<struct FHitResult>* Hits, bool SingleResult, bool IgnorePawns);
	void BeginRootMotionSmoothMoveToDynamic(const struct FVector& StartLocation, const struct FVector& TargetLocation, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName);
	void BeginRootMotionSmoothMoveTo(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName);
	void BeginRootMotionInstantMoveToDynamic(const struct FVector& TargetLocation, float Duration, bool OverrideVelocity, bool ZeroVelocityWhenFinished, class FName InstanceName);
	void BeginRootMotionImpulse(const struct FVector& Impulse, bool OverrideVelocity, class FName InstanceName);
	void BeginRootMotionConstantForce(const struct FVector& Direction, float Strength, float Duration, bool ZeroVelocityWhenFinished, class FName InstanceName);
	bool AreVerbConditionsSatisfied(class UObject* PotentialTarget, bool WillVerbSucceed);
	bool AreAllMeleeSweepsDone();
	void ApplyVerbContactEffect(struct FQtnContactEventInfo& ContactInfo, struct FQtnContactSystemResult& ContactSystemResults);
	void ApplyVerbContact(class UObject* ContactKey, enum class EPhysicalSurface SurfaceType, const struct FQtnContactEventData& ContactEventData);
	void ApplyMeleeDamage(class AActor* MeleeVictim, const struct FQtnDamageInfo& DamageInfo);
	bool AllowOtherVerbToInterrupt(class UQtnVerb* OtherVerb);
};

// 0x1B8 (0x298 - 0xE0)
// Class QtnGame.QtnVerbComponent
class UQtnVerbComponent : public UActorComponent
{
public:
	uint8                                        Pad_2723[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                M_pOwningActor;                                    // 0xE8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnItem*                              M_pOwningItem;                                     // 0xF0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnPawn*                              M_pOwningPawn;                                     // 0xF8(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_wasEquipped;                                     // 0x100(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_readyForGameplayPending;                         // 0x101(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2724[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        R_mappedVerbsOnRepInducer;                         // 0x104(0x4)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FQtnMappedVerbInstanceArray>   R_mappedVerbs;                                     // 0x108(0x10)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FQtnMappedVerbInstanceArray>   L_mappedVerbs;                                     // 0x118(0x10)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                         M_mappingRefreshPending;                           // 0x128(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2725[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       M_verbInhibitors_serverOnly;                       // 0x130(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                  M_timedInhibitors_serverOnly;                      // 0x140(0x50)(Transient, NativeAccessSpecifierPrivate)
	bool                                         R_areVerbsInhibited;                               // 0x190(0x1)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2726[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<TSubclassOf<class UQtnVerb>, class UQtnVerb*> M_instantiatedVerbs;                               // 0x198(0x50)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2727[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<enum class EQtnUIBodyActionEnum, struct FQtnVerbClassArray> VerbMappings;                                      // 0x238(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVerbsChanged;                                    // 0x288(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnVerbComponent* GetDefaultObj();

	void SetPowerUpgrades_ServerOnly(TSubclassOf<class UQtnVerb>& PowerVerbClass, TArray<struct FQtnUpgradeRunProgressData>& PowerUpgrades);
	void RemoveVerbs_ServerOnly(enum class EQtnUIBodyActionEnum AssociatedBodyAction);
	void RemoveVerbInhibitor_ServerOnly(class UObject* VerbInhibitor);
	void RemoveVerb_ServerOnly(TSubclassOf<class UQtnVerb> VerbClass);
	void OnRep_MappedVerbsOnRepInducer();
	void OnRep_MappedVerbs();
	void GetVerbs(enum class EQtnUIBodyActionEnum AssociatedBodyAction, TArray<class UQtnVerb*>* Verbs);
	class UQtnVerb* GetVerb(TSubclassOf<class UQtnVerb> VerbClass);
	void GetAllVerbs(TArray<class UQtnVerb*>* Verbs);
	bool AreVerbsInhibited();
	void AddVerbInhibitor_ServerOnly(class UObject* VerbInhibitor, float Duration);
	class UQtnVerb* AddVerb_ServerOnly(TSubclassOf<class UQtnVerb> VerbClass, enum class EQtnUIBodyActionEnum AssociatedBodyAction, bool RemoveAllOtherVerbs);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnVerbDriverInterface
class IQtnVerbDriverInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IQtnVerbDriverInterface* GetDefaultObj();

};

// 0x10 (0x2A8 - 0x298)
// Class QtnGame.QtnViewportHUD
class UQtnViewportHUD : public UQtnUserWidget
{
public:
	class UCanvasPanel*                          DamageNumberCanvas;                                // 0x298(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                          NameplateCanvas;                                   // 0x2A0(0x8)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnViewportHUD* GetDefaultObj();

};

// 0x20 (0x270 - 0x250)
// Class QtnGame.QtnVisualWaypoint
class AQtnVisualWaypoint : public AActor
{
public:
	class UCapsuleComponent*                     M_pCapsuleComponent;                               // 0x250(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnRangedFloat                       LingerDuration;                                    // 0x258(0x8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FQtnAnimBarkResponse>          AnimBarkResponses;                                 // 0x260(0x10)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnVisualWaypoint* GetDefaultObj();

};

// 0x250 (0xB30 - 0x8E0)
// Class QtnGame.QtnVOComponent
class UQtnVOComponent : public UAudioComponent
{
public:
	class UQtnVOManager*                         M_pVOManager;                                      // 0x8E0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  M_currentVOVariantName;                            // 0x8E8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_lastScore;                                       // 0x8F0(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_finishPlayingTime;                               // 0x8F4(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_isPendingPlayVO;                                 // 0x8F8(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2729[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQtnVOResponse                        M_pendingVOResponse;                               // 0x900(0xB0)(Transient, NativeAccessSpecifierPrivate)
	struct FQtnPlayVOParams                      M_pendingPlayVOParams;                             // 0x9B0(0x68)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FQtnPlayVOParams                      M_playingPlayVOParams;                             // 0xA18(0x68)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          R_voiceAltSpeakerType;                             // 0xA80(0x8)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          R_speakerTypeOverride;                             // 0xA88(0x8)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                  M_subtitleCategoryOverride;                        // 0xA90(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UQtnVOComponent*>               M_lipsyncMirrors;                                  // 0xA98(0x10)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          M_speakerType;                                     // 0xAA8(0x8)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                  M_speakerTypeVoiceAlts;                            // 0xAB0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                  M_speakerTypeVoiceAlts_Full;                       // 0xAC0(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                          M_fallbackSpeakerType;                             // 0xAD0(0x8)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVOPlayed;                                        // 0xAD8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVOStopped;                                       // 0xAE8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVOAudioFinished;                                 // 0xAF8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVOPhoneSpeakerLipsync;                           // 0xB08(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLipsyncMirror;                                   // 0xB18(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_272B[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnVOComponent* GetDefaultObj();

	void OnAudioFinished(class UAudioComponent* PAudioComponent);
	void MulticastStopVO();
	void MulticastSetVOPaused(bool Paused);
	void MulticastPlayVO(const struct FQtnPlayVOParams& PlayVOParams);
	struct FGameplayTag GetSpeakerTypeTag();
};

// 0x1E0 (0x208 - 0x28)
// Class QtnGame.QtnVODatabase
class UQtnVODatabase : public UObject
{
public:
	TMap<struct FGameplayTag, struct FQtnVOEventTypeBucket> M_eventTypeBuckets;                                // 0x28(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UDataTable>> M_cloneRedirects;                                  // 0x78(0x50)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnVOEventTypeArray> M_speakerEventTypes;                               // 0xC8(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnVOLocalizedAudioLanguageMap> M_localizedAudioLanguageMaps;                      // 0x118(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FQtnLocalizedCineAudioMap> M_localizedCineAudioMaps;                          // 0x168(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>             M_localizedVOVolumeMultipliers;                    // 0x1B8(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQtnVODatabase* GetDefaultObj();

};

// 0x730 (0x758 - 0x28)
// Class QtnGame.QtnVOManager
class UQtnVOManager : public UObject
{
public:
	struct FSoftObjectPath                       M_defaultVOManagerClass;                           // 0x28(0x18)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AQtnGameState*                         M_pOwningGameState;                                // 0x40(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_bEnabled;                                        // 0x48(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2753[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UQtnVODatabase>            M_voDatabase;                                      // 0x50(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                            M_pSubtitleSpeakerNamesDataTable;                  // 0x58(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class FText>       M_subtitleSpeakerNamesCache;                       // 0x60(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, float>             M_simpleSharedCooldowns;                           // 0xB0(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, float>             M_simpleSharedCooldowns_NextPlayTime;              // 0x100(0x50)(Transient, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2754[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVOComponent*                       M_pLastExclusiveVOComponent;                       // 0x1A0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_lastExclusiveVOScore;                            // 0x1A8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_lastExclusiveVOIsCommentaryOrLeadIn;             // 0x1AC(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2755[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVOComponent*                       M_pLastScriptedVOComponent;                        // 0x1B0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_lastScriptedVOScore;                             // 0x1B8(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2756[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UQtnVOComponent*                       M_pLastBackgroundVOComponent;                      // 0x1C0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          M_scriptedVOScene;                                 // 0x1C8(0x8)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                        M_phoneSpeakers;                                   // 0x1D0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FQtnVOActorArray> M_perEventPhoneSpeakers;                           // 0x1E0(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, float>                   M_phoneSpeakerWeightMap;                           // 0x230(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                        M_prioritySpeakers;                                // 0x280(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FQtnVOActorArray> M_perEventPrioritySpeakers;                        // 0x290(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                        M_potentialSpeakers;                               // 0x2E0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FQtnVOActorArray> M_perEventPotentialSpeakers;                       // 0x2F0(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_systemicVOInhibitors;                            // 0x340(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_commentaryVOInhibitors;                          // 0x350(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                       M_completeVOInhibitors;                            // 0x360(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, int32>             M_mutedCommentarySpeakerTypes;                     // 0x370(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UDataTable>>     M_desiredDataTables;                               // 0x3C0(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UDataTable>>     M_asyncLoadingDataTables;                          // 0x3D0(0x10)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class UDataTable*>                      M_asyncLoadedDataTables;                           // 0x3E0(0x50)(Transient, NativeAccessSpecifierPrivate)
	class UQtnVOComponent*                       M_pLeadInPendingVOComponent;                       // 0x430(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                M_pLeadInPendingSpeaker;                           // 0x438(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQtnVOResponseKey                     M_leadInPendingResponseKey;                        // 0x440(0x18)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          M_leadInPendingPrimaryKeyTag;                      // 0x458(0x8)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_leadInPendingIsScripted;                         // 0x460(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         M_leadInPendingForceClientSideVO;                  // 0x461(0x1)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2757[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_leadInPendingPrescribedVariant;                  // 0x464(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_leadInPendingPriorityOverride;                   // 0x468(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2758[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSet<class UDataTable*>                      M_handledCloneAssetRedirectTables;                 // 0x470(0x50)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FQtnVOCloneAssetRedirect> M_cloneAssetRedirectMap;                           // 0x4C0(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                  M_defaultLocalizedAudioLanguages;                  // 0x510(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                  M_devDefaultLocalizedAudioLanguages;               // 0x520(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                  M_localizedAudioLanguages;                         // 0x530(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTag                          M_selectedLocalizedAudioLanguage;                  // 0x540(0x8)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_2759[0xE8];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        M_playVOLogSize;                                   // 0x630(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_playVOLogDebugDisplaySize;                       // 0x634(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                        M_playVOLog;                                       // 0x638(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                        M_subtitleMinSubtitleSplit;                        // 0x648(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_subtitleMinSplitRemainder;                       // 0x64C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        M_subtitleNextSplitTolerance;                      // 0x650(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_275A[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class FString>                        M_subtitleSplitSubstrings;                         // 0x658(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class FString, class FString>           M_subtitleNoSplitSubstrings;                       // 0x668(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class FString, float>                   M_languageSubtitleSplitScalarMap;                  // 0x6B8(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class FString, class FString>           M_languageSubtitleSpeakerDelimiterMap;             // 0x708(0x50)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnVOManager* GetDefaultObj();

	void WaitForScriptedVO(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool WaitForVOPlayed);
	void WaitForExclusiveVO(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void WaitForBackgroundVO(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void UnsetSpeakerTypeOverride_ServerOnly(class AActor* Speaker);
	void UnmuteCommentarySpeakerType(const struct FGameplayTag& SpeakerType, class UObject* WorldContextObject);
	void StopVO(class UObject* WorldContextObject);
	void SetVOManagerEnabled(class UObject* WorldContextObject, bool bEnabled);
	void SetSpeakerTypeOverride_ServerOnly(class AActor* Speaker, const struct FGameplayTag& SpeakerType);
	void SetPhoneSpeakerWeight(class AActor* Speaker, float Weight, class UObject* WorldContextObject);
	void RequestScriptedVOWithPlayerCallout(class UObject* WorldContextObject, class AActor* Speaker, class AQtnBodyPawn* PlayerBodyPawn, const struct FGameplayTag& ScriptedId, const struct FGameplayTag& LeadInTag, bool PreferToPlayOnBody, int32 PrescribedVariant, int32 PriorityOverride);
	void RequestScriptedVOForOnePlayer(class UObject* WorldContextObject, class AActor* Speaker, const struct FGameplayTag& ScriptedId, class AQtnBodyPawn* TargetPlayerBodyPawn, bool PreferToPlayOnBody, int32 PrescribedVariant, int32 PriorityOverride);
	void RequestScriptedVOForceClientSide(class UObject* WorldContextObject, class AActor* Speaker, const struct FGameplayTag& ScriptedId, bool PreferToPlayOnBody, int32 PrescribedVariant, int32 PriorityOverride, class UAnimMontage* AnimMontage, bool AutoClosePhone, bool ForCutsceneHUD, bool DoNotStopOtherVO);
	void RequestScriptedVOAndWait(class UObject* WorldContextObject, class AActor* Speaker, const struct FGameplayTag& ScriptedId, const struct FLatentActionInfo& LatentInfo, bool PreferToPlayOnBody, int32 PrescribedVariant, int32 PriorityOverride);
	void RequestScriptedVO(class UObject* WorldContextObject, class AActor* Speaker, const struct FGameplayTag& ScriptedId, bool PreferToPlayOnBody, int32 PrescribedVariant, int32 PriorityOverride);
	void RequestBackgroundVOAndWait(class UObject* WorldContextObject, class AActor* Speaker, const struct FGameplayTag& ScriptedId, const struct FLatentActionInfo& LatentInfo, bool PreferToPlayOnBody, int32 PrescribedVariant);
	void RequestBackgroundVO(class UObject* WorldContextObject, class AActor* Speaker, const struct FGameplayTag& ScriptedId, bool PreferToPlayOnBody, int32 PrescribedVariant);
	void RemoveSystemicVOInhibitor(class UObject* Inhibitor, class UObject* WorldContextObject);
	void RemovePrioritySpeaker(class AActor* Speaker, class UObject* WorldContextObject);
	void RemovePotentialSpeaker(class AActor* Speaker, class UObject* WorldContextObject);
	void RemovePhoneSpeakerByClass(TSubclassOf<class AActor> SpeakerClass, class UObject* WorldContextObject);
	void RemovePhoneSpeaker(class AActor* Speaker, class UObject* WorldContextObject);
	void RemoveCompleteVOInhibitor(class UObject* Inhibitor, class UObject* WorldContextObject);
	void RemoveCommentaryVOInhibitor(class UObject* Inhibitor, class UObject* WorldContextObject);
	void RegisterSpeakerType(class UObject* WorldContextObject, class UClass* SpeakerClass);
	void PreloadVOForCutscene(class UObject* WorldContextObject, class AActor* PSpeaker, const struct FGameplayTag& ScriptedId, bool bBlocking);
	void PreloadAllVOCuesByTagAndSpeaker(class UObject* WorldContextObject, class AActor* PSpeaker, const struct FGameplayTag& PGameplayTag);
	int32 PickScriptedVOVariant(class UObject* WorldContextObject, const struct FGameplayTag& SpeakerType, const struct FGameplayTag& ScriptedId);
	void OnPhoneSpeakerLipsync(class UObject* WorldContextObject, class UQtnVOComponent* PhoneSpeakerVOComponent, class UCurveFloat* LipsyncAnim);
	void OnAudioFinished(class UAudioComponent* PAudioComponent);
	void MuteCommentarySpeakerType(const struct FGameplayTag& SpeakerType, class UObject* WorldContextObject);
	bool IsScriptedVOPlaying(class UObject* WorldContextObject);
	float GetVOVolumeMultiplier(class UObject* WorldContextObject);
	int32 GetPlayVOLogSize(class UObject* WorldContextObject);
	float GetPlayVOLogEntryAlpha(class UObject* WorldContextObject, int32 Index);
	class FString GetPlayVOLogEntry(class UObject* WorldContextObject, int32 Index);
	class USoundCue* GetLocalizedCineAudio(class UObject* WorldContextObject, class USoundCue* EnglishSoundCue);
	TArray<struct FGameplayTag> GetAvailableLocalizedAudioLanguages(class UObject* WorldContextObject);
	void DoMirrorLipsync(class UObject* WorldContextObject, class UQtnVOComponent* FromSpeaker, class UCurveFloat* LipsyncAnim);
	void AddSystemicVOInhibitor(class UObject* Inhibitor, class UObject* WorldContextObject);
	void AddPrioritySpeaker(class AActor* Speaker, class UObject* WorldContextObject);
	void AddPotentialSpeaker(class AActor* Speaker, class UObject* WorldContextObject);
	void AddPhoneSpeaker(class AActor* Speaker, class UObject* WorldContextObject);
	void AddLipsyncMirror(class UObject* WorldContextObject, class UQtnVOComponent* FromSpeaker, class UQtnVOComponent* ToSpeaker);
	void AddCompleteVOInhibitor(class UObject* Inhibitor, class UObject* WorldContextObject);
	void AddCommentaryVOInhibitor(class UObject* Inhibitor, class UObject* WorldContextObject);
};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnVOPatternMatching
class UQtnVOPatternMatching : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnVOPatternMatching* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class QtnGame.QtnVOStructs
class UQtnVOStructs : public UObject
{
public:

	static class UClass* StaticClass();
	static class UQtnVOStructs* GetDefaultObj();

};

// 0x58 (0x2D0 - 0x278)
// Class QtnGame.QtnWaypoint
class AQtnWaypoint : public ANavigationObjectBase
{
public:
	uint8                                        Pad_275B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQtnBodyController*                    M_pAdoptingBodyController;                         // 0x280(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                               M_navLocation;                                     // 0x288(0xC)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        M_cachedSniperCosine;                              // 0x294(0x4)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        VisualAndLingerProbability;                        // 0x298(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQtnRangedFloat                       LingerDuration;                                    // 0x29C(0x8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_275C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AQtnVisualWaypoint*>            VisualWaypoints;                                   // 0x2A8(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FQtnAnimBarkResponse>          AnimBarkResponses;                                 // 0x2B8(0x10)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                        SniperAngleDegrees;                                // 0x2C8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SniperStickinessDistance;                          // 0x2CC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnWaypoint* GetDefaultObj();

};

// 0x8 (0xE8 - 0xE0)
// Class QtnGame.QtnWaypointProxyComponent
class UQtnWaypointProxyComponent : public UActorComponent
{
public:
	TWeakObjectPtr<class UQtnPatrolRouteComponent> M_pOwningPatrolRoute;                              // 0xE0(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UQtnWaypointProxyComponent* GetDefaultObj();

};

// 0x60 (0x88 - 0x28)
// Class QtnGame.QtnWorldCustomization
class UQtnWorldCustomization : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>             IconForUI;                                         // 0x28(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                  UIName;                                            // 0x50(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                  UIDescription;                                     // 0x68(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                         IsDLCCustomization;                                // 0x80(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_275F[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UQtnWorldCustomization* GetDefaultObj();

	class UQtnWorldCustomization* GetWorldCustomizationArchetype(TSubclassOf<class UQtnWorldCustomization> WorldCustomizationClass);
	class UTexture2D* GetIconForUI();
};

// 0x38 (0x408 - 0x3D0)
// Class QtnGame.QtnWorldSettings
class AQtnWorldSettings : public AWorldSettings
{
public:
	TSubclassOf<class UQtnStealthSettings>       StealthSettingsClass;                              // 0x3D0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UQtnGoalManager>           GoalManagerClass;                                  // 0x3D8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ShouldGrantEnemyUpgrades;                          // 0x3E0(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_276B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTag                          MusicDataTableRowTag;                              // 0x3E4(0x8)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AutoSpawnBodyForPlayers;                           // 0x3EC(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AffectsPlayerProgress;                             // 0x3ED(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsAMissionWorld;                                   // 0x3EE(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         IsHordeMap;                                        // 0x3EF(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        WorldRarityModifier;                               // 0x3F0(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_276C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FDataTableRowHandle                   RichPresence;                                      // 0x3F8(0x10)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQtnWorldSettings* GetDefaultObj();

	bool ShouldMapGrantEnemyUpgrades(class UObject* WorldContextObject);
	void IsThisMapForHordeMode(class UObject* WorldContextObject, enum class EQtnOutputYesNoEnum* OutputPin);
	void IsThisMapAMissionWorldBP(class UObject* WorldContextObject, enum class EQtnOutputYesNoEnum* OutputPin);
	class FName GetMusicDataTableRowName(class UObject* WorldContextObject);
	void DoesThisMapSpawnBodiesBP(class UObject* WorldContextObject, enum class EQtnOutputYesNoEnum* OutputPin);
	void DoesThisMapAffectPlayerProgressBP(class UObject* WorldContextObject, enum class EQtnOutputYesNoEnum* OutputPin);
};

}


